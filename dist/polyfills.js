(self["webpackChunkvuexy"] = self["webpackChunkvuexy"] || []).push([["polyfills"],{

/***/ 7435:
/*!**************************!*\
  !*** ./src/polyfills.ts ***!
  \**************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _angular_localize_init__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/localize/init */ 43757);
/* harmony import */ var zone_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zone.js */ 64924);
/* harmony import */ var zone_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(zone_js__WEBPACK_IMPORTED_MODULE_1__);
/***************************************************************************************************
 * Load `$localize` onto the global scope - used if i18n tags appear in Angular templates.
 */

/**
 * This file includes polyfills needed by Angular and is loaded before the app.
 * You can add your own extra polyfills to this file.
 *
 * This file is divided into 2 sections:
 *   1. Browser polyfills. These are applied before loading ZoneJS and are sorted by browsers.
 *   2. Application imports. Files imported after ZoneJS that should be loaded before your main
 *      file.
 *
 * The current setup is for so-called "evergreen" browsers; the last versions of browsers that
 * automatically update themselves. This includes Safari >= 10, Chrome >= 55 (including Opera),
 * Edge >= 13 on the desktop, and iOS 10 and Chrome on mobile.
 *
 * Learn more in https://angular.io/guide/browser-support
 */

/***************************************************************************************************
 * BROWSER POLYFILLS
 */

/** IE9, IE10, IE11, and Chrome <55 requires all of the following polyfills.
 *  This also includes Android Emulators with older versions of Chrome and Google Search/Googlebot
 */
// import 'core-js/es6/symbol';
// import 'core-js/es6/object';
// import 'core-js/es6/function';
// import 'core-js/es6/parse-int';
// import 'core-js/es6/parse-float';
// import 'core-js/es6/number';
// import 'core-js/es6/math';
// import 'core-js/es6/string';
// import 'core-js/es6/date';
// import 'core-js/es6/array';
// import 'core-js/es6/regexp';
// import 'core-js/es6/map';
// import 'core-js/es6/weak-map';
// import 'core-js/es6/set';

/** IE10 and IE11 requires the following for the Reflect API. */
// import 'core-js/es6/reflect';

/**
 * By default, zone.js will patch all possible macroTask and DomEvents
 * user can disable parts of macroTask/DomEvents patch by setting following flags
 * because those flags need to be set before `zone.js` being loaded, and webpack
 * will put import in the top of bundle, so user need to create a separate file
 * in this directory (for example: zone-flags.ts), and put the following flags
 * into that file, and then add the following code before importing zone.js.
 * import './zone-flags.ts';
 *
 * The flags allowed in zone-flags.ts are listed here.
 *
 * The following flags will work for all browsers.
 *
 * (window as any).__Zone_disable_requestAnimationFrame = true; // disable patch requestAnimationFrame
 * (window as any).__Zone_disable_on_property = true; // disable patch onProperty such as onclick
 * (window as any).__zone_symbol__BLACK_LISTED_EVENTS = ['scroll', 'mousemove']; // disable patch specified eventNames
 *
 *  in IE/Edge developer tools, the addEventListener will also be wrapped by zone.js
 *  with the following flag, it will bypass `zone.js` patch for IE/Edge
 *
 *  (window as any).__Zone_enable_cross_context_check = true;
 *
 */

/***************************************************************************************************
 * Zone JS is required by default for Angular itself.
 */

 // Included with Angular CLI.

/***************************************************************************************************
 * APPLICATION IMPORTS
 */
// ng2-dragula

window.global = window;

/***/ }),

/***/ 64924:
/*!***********************************************!*\
  !*** ./node_modules/zone.js/fesm2015/zone.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";

/**
 * @license Angular v12.0.0-next.0
 * (c) 2010-2020 Google LLC. https://angular.io/
 * License: MIT
 */

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

var _createForOfIteratorHelper = (__webpack_require__(/*! ./node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js */ 61845)["default"]);

var _classCallCheck = (__webpack_require__(/*! ./node_modules/@babel/runtime/helpers/classCallCheck.js */ 52677)["default"]);

var _createClass = (__webpack_require__(/*! ./node_modules/@babel/runtime/helpers/createClass.js */ 99010)["default"]);

var Zone$1 = function (global) {
  var performance = global['performance'];

  function mark(name) {
    performance && performance['mark'] && performance['mark'](name);
  }

  function performanceMeasure(name, label) {
    performance && performance['measure'] && performance['measure'](name, label);
  }

  mark('Zone'); // Initialize before it's accessed below.
  // __Zone_symbol_prefix global can be used to override the default zone
  // symbol prefix with a custom one if needed.

  var symbolPrefix = global['__Zone_symbol_prefix'] || '__zone_symbol__';

  function __symbol__(name) {
    return symbolPrefix + name;
  }

  var checkDuplicate = global[__symbol__('forceDuplicateZoneCheck')] === true;

  if (global['Zone']) {
    // if global['Zone'] already exists (maybe zone.js was already loaded or
    // some other lib also registered a global object named Zone), we may need
    // to throw an error, but sometimes user may not want this error.
    // For example,
    // we have two web pages, page1 includes zone.js, page2 doesn't.
    // and the 1st time user load page1 and page2, everything work fine,
    // but when user load page2 again, error occurs because global['Zone'] already exists.
    // so we add a flag to let user choose whether to throw this error or not.
    // By default, if existing Zone is from zone.js, we will not throw the error.
    if (checkDuplicate || typeof global['Zone'].__symbol__ !== 'function') {
      throw new Error('Zone already loaded.');
    } else {
      return global['Zone'];
    }
  }

  var Zone = /*#__PURE__*/function () {
    function Zone(parent, zoneSpec) {
      _classCallCheck(this, Zone);

      this._parent = parent;
      this._name = zoneSpec ? zoneSpec.name || 'unnamed' : '<root>';
      this._properties = zoneSpec && zoneSpec.properties || {};
      this._zoneDelegate = new ZoneDelegate(this, this._parent && this._parent._zoneDelegate, zoneSpec);
    }

    _createClass(Zone, [{
      key: "parent",
      get: function get() {
        return this._parent;
      }
    }, {
      key: "name",
      get: function get() {
        return this._name;
      }
    }, {
      key: "get",
      value: function get(key) {
        var zone = this.getZoneWith(key);
        if (zone) return zone._properties[key];
      }
    }, {
      key: "getZoneWith",
      value: function getZoneWith(key) {
        var current = this;

        while (current) {
          if (current._properties.hasOwnProperty(key)) {
            return current;
          }

          current = current._parent;
        }

        return null;
      }
    }, {
      key: "fork",
      value: function fork(zoneSpec) {
        if (!zoneSpec) throw new Error('ZoneSpec required!');
        return this._zoneDelegate.fork(this, zoneSpec);
      }
    }, {
      key: "wrap",
      value: function wrap(callback, source) {
        if (typeof callback !== 'function') {
          throw new Error('Expecting function got: ' + callback);
        }

        var _callback = this._zoneDelegate.intercept(this, callback, source);

        var zone = this;
        return function () {
          return zone.runGuarded(_callback, this, arguments, source);
        };
      }
    }, {
      key: "run",
      value: function run(callback, applyThis, applyArgs, source) {
        _currentZoneFrame = {
          parent: _currentZoneFrame,
          zone: this
        };

        try {
          return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);
        } finally {
          _currentZoneFrame = _currentZoneFrame.parent;
        }
      }
    }, {
      key: "runGuarded",
      value: function runGuarded(callback) {
        var applyThis = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var applyArgs = arguments.length > 2 ? arguments[2] : undefined;
        var source = arguments.length > 3 ? arguments[3] : undefined;
        _currentZoneFrame = {
          parent: _currentZoneFrame,
          zone: this
        };

        try {
          try {
            return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);
          } catch (error) {
            if (this._zoneDelegate.handleError(this, error)) {
              throw error;
            }
          }
        } finally {
          _currentZoneFrame = _currentZoneFrame.parent;
        }
      }
    }, {
      key: "runTask",
      value: function runTask(task, applyThis, applyArgs) {
        if (task.zone != this) {
          throw new Error('A task can only be run in the zone of creation! (Creation: ' + (task.zone || NO_ZONE).name + '; Execution: ' + this.name + ')');
        } // https://github.com/angular/zone.js/issues/778, sometimes eventTask
        // will run in notScheduled(canceled) state, we should not try to
        // run such kind of task but just return


        if (task.state === notScheduled && (task.type === eventTask || task.type === macroTask)) {
          return;
        }

        var reEntryGuard = task.state != running;
        reEntryGuard && task._transitionTo(running, scheduled);
        task.runCount++;
        var previousTask = _currentTask;
        _currentTask = task;
        _currentZoneFrame = {
          parent: _currentZoneFrame,
          zone: this
        };

        try {
          if (task.type == macroTask && task.data && !task.data.isPeriodic) {
            task.cancelFn = undefined;
          }

          try {
            return this._zoneDelegate.invokeTask(this, task, applyThis, applyArgs);
          } catch (error) {
            if (this._zoneDelegate.handleError(this, error)) {
              throw error;
            }
          }
        } finally {
          // if the task's state is notScheduled or unknown, then it has already been cancelled
          // we should not reset the state to scheduled
          if (task.state !== notScheduled && task.state !== unknown) {
            if (task.type == eventTask || task.data && task.data.isPeriodic) {
              reEntryGuard && task._transitionTo(scheduled, running);
            } else {
              task.runCount = 0;

              this._updateTaskCount(task, -1);

              reEntryGuard && task._transitionTo(notScheduled, running, notScheduled);
            }
          }

          _currentZoneFrame = _currentZoneFrame.parent;
          _currentTask = previousTask;
        }
      }
    }, {
      key: "scheduleTask",
      value: function scheduleTask(task) {
        if (task.zone && task.zone !== this) {
          // check if the task was rescheduled, the newZone
          // should not be the children of the original zone
          var newZone = this;

          while (newZone) {
            if (newZone === task.zone) {
              throw Error("can not reschedule task to ".concat(this.name, " which is descendants of the original zone ").concat(task.zone.name));
            }

            newZone = newZone.parent;
          }
        }

        task._transitionTo(scheduling, notScheduled);

        var zoneDelegates = [];
        task._zoneDelegates = zoneDelegates;
        task._zone = this;

        try {
          task = this._zoneDelegate.scheduleTask(this, task);
        } catch (err) {
          // should set task's state to unknown when scheduleTask throw error
          // because the err may from reschedule, so the fromState maybe notScheduled
          task._transitionTo(unknown, scheduling, notScheduled); // TODO: @JiaLiPassion, should we check the result from handleError?


          this._zoneDelegate.handleError(this, err);

          throw err;
        }

        if (task._zoneDelegates === zoneDelegates) {
          // we have to check because internally the delegate can reschedule the task.
          this._updateTaskCount(task, 1);
        }

        if (task.state == scheduling) {
          task._transitionTo(scheduled, scheduling);
        }

        return task;
      }
    }, {
      key: "scheduleMicroTask",
      value: function scheduleMicroTask(source, callback, data, customSchedule) {
        return this.scheduleTask(new ZoneTask(microTask, source, callback, data, customSchedule, undefined));
      }
    }, {
      key: "scheduleMacroTask",
      value: function scheduleMacroTask(source, callback, data, customSchedule, customCancel) {
        return this.scheduleTask(new ZoneTask(macroTask, source, callback, data, customSchedule, customCancel));
      }
    }, {
      key: "scheduleEventTask",
      value: function scheduleEventTask(source, callback, data, customSchedule, customCancel) {
        return this.scheduleTask(new ZoneTask(eventTask, source, callback, data, customSchedule, customCancel));
      }
    }, {
      key: "cancelTask",
      value: function cancelTask(task) {
        if (task.zone != this) throw new Error('A task can only be cancelled in the zone of creation! (Creation: ' + (task.zone || NO_ZONE).name + '; Execution: ' + this.name + ')');

        task._transitionTo(canceling, scheduled, running);

        try {
          this._zoneDelegate.cancelTask(this, task);
        } catch (err) {
          // if error occurs when cancelTask, transit the state to unknown
          task._transitionTo(unknown, canceling);

          this._zoneDelegate.handleError(this, err);

          throw err;
        }

        this._updateTaskCount(task, -1);

        task._transitionTo(notScheduled, canceling);

        task.runCount = 0;
        return task;
      }
    }, {
      key: "_updateTaskCount",
      value: function _updateTaskCount(task, count) {
        var zoneDelegates = task._zoneDelegates;

        if (count == -1) {
          task._zoneDelegates = null;
        }

        for (var i = 0; i < zoneDelegates.length; i++) {
          zoneDelegates[i]._updateTaskCount(task.type, count);
        }
      }
    }], [{
      key: "assertZonePatched",
      value: function assertZonePatched() {
        if (global['Promise'] !== patches['ZoneAwarePromise']) {
          throw new Error('Zone.js has detected that ZoneAwarePromise `(window|global).Promise` ' + 'has been overwritten.\n' + 'Most likely cause is that a Promise polyfill has been loaded ' + 'after Zone.js (Polyfilling Promise api is not necessary when zone.js is loaded. ' + 'If you must load one, do so before loading zone.js.)');
        }
      }
    }, {
      key: "root",
      get: function get() {
        var zone = Zone.current;

        while (zone.parent) {
          zone = zone.parent;
        }

        return zone;
      }
    }, {
      key: "current",
      get: function get() {
        return _currentZoneFrame.zone;
      }
    }, {
      key: "currentTask",
      get: function get() {
        return _currentTask;
      } // tslint:disable-next-line:require-internal-with-underscore

    }, {
      key: "__load_patch",
      value: function __load_patch(name, fn) {
        var ignoreDuplicate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        if (patches.hasOwnProperty(name)) {
          // `checkDuplicate` option is defined from global variable
          // so it works for all modules.
          // `ignoreDuplicate` can work for the specified module
          if (!ignoreDuplicate && checkDuplicate) {
            throw Error('Already loaded patch: ' + name);
          }
        } else if (!global['__Zone_disable_' + name]) {
          var perfName = 'Zone:' + name;
          mark(perfName);
          patches[name] = fn(global, Zone, _api);
          performanceMeasure(perfName, perfName);
        }
      }
    }]);

    return Zone;
  }(); // tslint:disable-next-line:require-internal-with-underscore


  Zone.__symbol__ = __symbol__;
  var DELEGATE_ZS = {
    name: '',
    onHasTask: function onHasTask(delegate, _, target, hasTaskState) {
      return delegate.hasTask(target, hasTaskState);
    },
    onScheduleTask: function onScheduleTask(delegate, _, target, task) {
      return delegate.scheduleTask(target, task);
    },
    onInvokeTask: function onInvokeTask(delegate, _, target, task, applyThis, applyArgs) {
      return delegate.invokeTask(target, task, applyThis, applyArgs);
    },
    onCancelTask: function onCancelTask(delegate, _, target, task) {
      return delegate.cancelTask(target, task);
    }
  };

  var ZoneDelegate = /*#__PURE__*/function () {
    function ZoneDelegate(zone, parentDelegate, zoneSpec) {
      _classCallCheck(this, ZoneDelegate);

      this._taskCounts = {
        'microTask': 0,
        'macroTask': 0,
        'eventTask': 0
      };
      this.zone = zone;
      this._parentDelegate = parentDelegate;
      this._forkZS = zoneSpec && (zoneSpec && zoneSpec.onFork ? zoneSpec : parentDelegate._forkZS);
      this._forkDlgt = zoneSpec && (zoneSpec.onFork ? parentDelegate : parentDelegate._forkDlgt);
      this._forkCurrZone = zoneSpec && (zoneSpec.onFork ? this.zone : parentDelegate._forkCurrZone);
      this._interceptZS = zoneSpec && (zoneSpec.onIntercept ? zoneSpec : parentDelegate._interceptZS);
      this._interceptDlgt = zoneSpec && (zoneSpec.onIntercept ? parentDelegate : parentDelegate._interceptDlgt);
      this._interceptCurrZone = zoneSpec && (zoneSpec.onIntercept ? this.zone : parentDelegate._interceptCurrZone);
      this._invokeZS = zoneSpec && (zoneSpec.onInvoke ? zoneSpec : parentDelegate._invokeZS);
      this._invokeDlgt = zoneSpec && (zoneSpec.onInvoke ? parentDelegate : parentDelegate._invokeDlgt);
      this._invokeCurrZone = zoneSpec && (zoneSpec.onInvoke ? this.zone : parentDelegate._invokeCurrZone);
      this._handleErrorZS = zoneSpec && (zoneSpec.onHandleError ? zoneSpec : parentDelegate._handleErrorZS);
      this._handleErrorDlgt = zoneSpec && (zoneSpec.onHandleError ? parentDelegate : parentDelegate._handleErrorDlgt);
      this._handleErrorCurrZone = zoneSpec && (zoneSpec.onHandleError ? this.zone : parentDelegate._handleErrorCurrZone);
      this._scheduleTaskZS = zoneSpec && (zoneSpec.onScheduleTask ? zoneSpec : parentDelegate._scheduleTaskZS);
      this._scheduleTaskDlgt = zoneSpec && (zoneSpec.onScheduleTask ? parentDelegate : parentDelegate._scheduleTaskDlgt);
      this._scheduleTaskCurrZone = zoneSpec && (zoneSpec.onScheduleTask ? this.zone : parentDelegate._scheduleTaskCurrZone);
      this._invokeTaskZS = zoneSpec && (zoneSpec.onInvokeTask ? zoneSpec : parentDelegate._invokeTaskZS);
      this._invokeTaskDlgt = zoneSpec && (zoneSpec.onInvokeTask ? parentDelegate : parentDelegate._invokeTaskDlgt);
      this._invokeTaskCurrZone = zoneSpec && (zoneSpec.onInvokeTask ? this.zone : parentDelegate._invokeTaskCurrZone);
      this._cancelTaskZS = zoneSpec && (zoneSpec.onCancelTask ? zoneSpec : parentDelegate._cancelTaskZS);
      this._cancelTaskDlgt = zoneSpec && (zoneSpec.onCancelTask ? parentDelegate : parentDelegate._cancelTaskDlgt);
      this._cancelTaskCurrZone = zoneSpec && (zoneSpec.onCancelTask ? this.zone : parentDelegate._cancelTaskCurrZone);
      this._hasTaskZS = null;
      this._hasTaskDlgt = null;
      this._hasTaskDlgtOwner = null;
      this._hasTaskCurrZone = null;
      var zoneSpecHasTask = zoneSpec && zoneSpec.onHasTask;
      var parentHasTask = parentDelegate && parentDelegate._hasTaskZS;

      if (zoneSpecHasTask || parentHasTask) {
        // If we need to report hasTask, than this ZS needs to do ref counting on tasks. In such
        // a case all task related interceptors must go through this ZD. We can't short circuit it.
        this._hasTaskZS = zoneSpecHasTask ? zoneSpec : DELEGATE_ZS;
        this._hasTaskDlgt = parentDelegate;
        this._hasTaskDlgtOwner = this;
        this._hasTaskCurrZone = zone;

        if (!zoneSpec.onScheduleTask) {
          this._scheduleTaskZS = DELEGATE_ZS;
          this._scheduleTaskDlgt = parentDelegate;
          this._scheduleTaskCurrZone = this.zone;
        }

        if (!zoneSpec.onInvokeTask) {
          this._invokeTaskZS = DELEGATE_ZS;
          this._invokeTaskDlgt = parentDelegate;
          this._invokeTaskCurrZone = this.zone;
        }

        if (!zoneSpec.onCancelTask) {
          this._cancelTaskZS = DELEGATE_ZS;
          this._cancelTaskDlgt = parentDelegate;
          this._cancelTaskCurrZone = this.zone;
        }
      }
    }

    _createClass(ZoneDelegate, [{
      key: "fork",
      value: function fork(targetZone, zoneSpec) {
        return this._forkZS ? this._forkZS.onFork(this._forkDlgt, this.zone, targetZone, zoneSpec) : new Zone(targetZone, zoneSpec);
      }
    }, {
      key: "intercept",
      value: function intercept(targetZone, callback, source) {
        return this._interceptZS ? this._interceptZS.onIntercept(this._interceptDlgt, this._interceptCurrZone, targetZone, callback, source) : callback;
      }
    }, {
      key: "invoke",
      value: function invoke(targetZone, callback, applyThis, applyArgs, source) {
        return this._invokeZS ? this._invokeZS.onInvoke(this._invokeDlgt, this._invokeCurrZone, targetZone, callback, applyThis, applyArgs, source) : callback.apply(applyThis, applyArgs);
      }
    }, {
      key: "handleError",
      value: function handleError(targetZone, error) {
        return this._handleErrorZS ? this._handleErrorZS.onHandleError(this._handleErrorDlgt, this._handleErrorCurrZone, targetZone, error) : true;
      }
    }, {
      key: "scheduleTask",
      value: function scheduleTask(targetZone, task) {
        var returnTask = task;

        if (this._scheduleTaskZS) {
          if (this._hasTaskZS) {
            returnTask._zoneDelegates.push(this._hasTaskDlgtOwner);
          } // clang-format off


          returnTask = this._scheduleTaskZS.onScheduleTask(this._scheduleTaskDlgt, this._scheduleTaskCurrZone, targetZone, task); // clang-format on

          if (!returnTask) returnTask = task;
        } else {
          if (task.scheduleFn) {
            task.scheduleFn(task);
          } else if (task.type == microTask) {
            scheduleMicroTask(task);
          } else {
            throw new Error('Task is missing scheduleFn.');
          }
        }

        return returnTask;
      }
    }, {
      key: "invokeTask",
      value: function invokeTask(targetZone, task, applyThis, applyArgs) {
        return this._invokeTaskZS ? this._invokeTaskZS.onInvokeTask(this._invokeTaskDlgt, this._invokeTaskCurrZone, targetZone, task, applyThis, applyArgs) : task.callback.apply(applyThis, applyArgs);
      }
    }, {
      key: "cancelTask",
      value: function cancelTask(targetZone, task) {
        var value;

        if (this._cancelTaskZS) {
          value = this._cancelTaskZS.onCancelTask(this._cancelTaskDlgt, this._cancelTaskCurrZone, targetZone, task);
        } else {
          if (!task.cancelFn) {
            throw Error('Task is not cancelable');
          }

          value = task.cancelFn(task);
        }

        return value;
      }
    }, {
      key: "hasTask",
      value: function hasTask(targetZone, isEmpty) {
        // hasTask should not throw error so other ZoneDelegate
        // can still trigger hasTask callback
        try {
          this._hasTaskZS && this._hasTaskZS.onHasTask(this._hasTaskDlgt, this._hasTaskCurrZone, targetZone, isEmpty);
        } catch (err) {
          this.handleError(targetZone, err);
        }
      } // tslint:disable-next-line:require-internal-with-underscore

    }, {
      key: "_updateTaskCount",
      value: function _updateTaskCount(type, count) {
        var counts = this._taskCounts;
        var prev = counts[type];
        var next = counts[type] = prev + count;

        if (next < 0) {
          throw new Error('More tasks executed then were scheduled.');
        }

        if (prev == 0 || next == 0) {
          var isEmpty = {
            microTask: counts['microTask'] > 0,
            macroTask: counts['macroTask'] > 0,
            eventTask: counts['eventTask'] > 0,
            change: type
          };
          this.hasTask(this.zone, isEmpty);
        }
      }
    }]);

    return ZoneDelegate;
  }();

  var ZoneTask = /*#__PURE__*/function () {
    function ZoneTask(type, source, callback, options, scheduleFn, cancelFn) {
      _classCallCheck(this, ZoneTask);

      // tslint:disable-next-line:require-internal-with-underscore
      this._zone = null;
      this.runCount = 0; // tslint:disable-next-line:require-internal-with-underscore

      this._zoneDelegates = null; // tslint:disable-next-line:require-internal-with-underscore

      this._state = 'notScheduled';
      this.type = type;
      this.source = source;
      this.data = options;
      this.scheduleFn = scheduleFn;
      this.cancelFn = cancelFn;

      if (!callback) {
        throw new Error('callback is not defined');
      }

      this.callback = callback;
      var self = this; // TODO: @JiaLiPassion options should have interface

      if (type === eventTask && options && options.useG) {
        this.invoke = ZoneTask.invokeTask;
      } else {
        this.invoke = function () {
          return ZoneTask.invokeTask.call(global, self, this, arguments);
        };
      }
    }

    _createClass(ZoneTask, [{
      key: "zone",
      get: function get() {
        return this._zone;
      }
    }, {
      key: "state",
      get: function get() {
        return this._state;
      }
    }, {
      key: "cancelScheduleRequest",
      value: function cancelScheduleRequest() {
        this._transitionTo(notScheduled, scheduling);
      } // tslint:disable-next-line:require-internal-with-underscore

    }, {
      key: "_transitionTo",
      value: function _transitionTo(toState, fromState1, fromState2) {
        if (this._state === fromState1 || this._state === fromState2) {
          this._state = toState;

          if (toState == notScheduled) {
            this._zoneDelegates = null;
          }
        } else {
          throw new Error("".concat(this.type, " '").concat(this.source, "': can not transition to '").concat(toState, "', expecting state '").concat(fromState1, "'").concat(fromState2 ? ' or \'' + fromState2 + '\'' : '', ", was '").concat(this._state, "'."));
        }
      }
    }, {
      key: "toString",
      value: function toString() {
        if (this.data && typeof this.data.handleId !== 'undefined') {
          return this.data.handleId.toString();
        } else {
          return Object.prototype.toString.call(this);
        }
      } // add toJSON method to prevent cyclic error when
      // call JSON.stringify(zoneTask)

    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          type: this.type,
          state: this.state,
          source: this.source,
          zone: this.zone.name,
          runCount: this.runCount
        };
      }
    }], [{
      key: "invokeTask",
      value: function invokeTask(task, target, args) {
        if (!task) {
          task = this;
        }

        _numberOfNestedTaskFrames++;

        try {
          task.runCount++;
          return task.zone.runTask(task, target, args);
        } finally {
          if (_numberOfNestedTaskFrames == 1) {
            drainMicroTaskQueue();
          }

          _numberOfNestedTaskFrames--;
        }
      }
    }]);

    return ZoneTask;
  }(); //////////////////////////////////////////////////////
  //////////////////////////////////////////////////////
  ///  MICROTASK QUEUE
  //////////////////////////////////////////////////////
  //////////////////////////////////////////////////////


  var symbolSetTimeout = __symbol__('setTimeout');

  var symbolPromise = __symbol__('Promise');

  var symbolThen = __symbol__('then');

  var _microTaskQueue = [];
  var _isDrainingMicrotaskQueue = false;
  var nativeMicroTaskQueuePromise;

  function scheduleMicroTask(task) {
    // if we are not running in any task, and there has not been anything scheduled
    // we must bootstrap the initial task creation by manually scheduling the drain
    if (_numberOfNestedTaskFrames === 0 && _microTaskQueue.length === 0) {
      // We are not running in Task, so we need to kickstart the microtask queue.
      if (!nativeMicroTaskQueuePromise) {
        if (global[symbolPromise]) {
          nativeMicroTaskQueuePromise = global[symbolPromise].resolve(0);
        }
      }

      if (nativeMicroTaskQueuePromise) {
        var nativeThen = nativeMicroTaskQueuePromise[symbolThen];

        if (!nativeThen) {
          // native Promise is not patchable, we need to use `then` directly
          // issue 1078
          nativeThen = nativeMicroTaskQueuePromise['then'];
        }

        nativeThen.call(nativeMicroTaskQueuePromise, drainMicroTaskQueue);
      } else {
        global[symbolSetTimeout](drainMicroTaskQueue, 0);
      }
    }

    task && _microTaskQueue.push(task);
  }

  function drainMicroTaskQueue() {
    if (!_isDrainingMicrotaskQueue) {
      _isDrainingMicrotaskQueue = true;

      while (_microTaskQueue.length) {
        var queue = _microTaskQueue;
        _microTaskQueue = [];

        for (var i = 0; i < queue.length; i++) {
          var task = queue[i];

          try {
            task.zone.runTask(task, null, null);
          } catch (error) {
            _api.onUnhandledError(error);
          }
        }
      }

      _api.microtaskDrainDone();

      _isDrainingMicrotaskQueue = false;
    }
  } //////////////////////////////////////////////////////
  //////////////////////////////////////////////////////
  ///  BOOTSTRAP
  //////////////////////////////////////////////////////
  //////////////////////////////////////////////////////


  var NO_ZONE = {
    name: 'NO ZONE'
  };
  var notScheduled = 'notScheduled',
      scheduling = 'scheduling',
      scheduled = 'scheduled',
      running = 'running',
      canceling = 'canceling',
      unknown = 'unknown';
  var microTask = 'microTask',
      macroTask = 'macroTask',
      eventTask = 'eventTask';
  var patches = {};
  var _api = {
    symbol: __symbol__,
    currentZoneFrame: function currentZoneFrame() {
      return _currentZoneFrame;
    },
    onUnhandledError: noop,
    microtaskDrainDone: noop,
    scheduleMicroTask: scheduleMicroTask,
    showUncaughtError: function showUncaughtError() {
      return !Zone[__symbol__('ignoreConsoleErrorUncaughtError')];
    },
    patchEventTarget: function patchEventTarget() {
      return [];
    },
    patchOnProperties: noop,
    patchMethod: function patchMethod() {
      return noop;
    },
    bindArguments: function bindArguments() {
      return [];
    },
    patchThen: function patchThen() {
      return noop;
    },
    patchMacroTask: function patchMacroTask() {
      return noop;
    },
    patchEventPrototype: function patchEventPrototype() {
      return noop;
    },
    isIEOrEdge: function isIEOrEdge() {
      return false;
    },
    getGlobalObjects: function getGlobalObjects() {
      return undefined;
    },
    ObjectDefineProperty: function ObjectDefineProperty() {
      return noop;
    },
    ObjectGetOwnPropertyDescriptor: function ObjectGetOwnPropertyDescriptor() {
      return undefined;
    },
    ObjectCreate: function ObjectCreate() {
      return undefined;
    },
    ArraySlice: function ArraySlice() {
      return [];
    },
    patchClass: function patchClass() {
      return noop;
    },
    wrapWithCurrentZone: function wrapWithCurrentZone() {
      return noop;
    },
    filterProperties: function filterProperties() {
      return [];
    },
    attachOriginToPatched: function attachOriginToPatched() {
      return noop;
    },
    _redefineProperty: function _redefineProperty() {
      return noop;
    },
    patchCallbacks: function patchCallbacks() {
      return noop;
    }
  };
  var _currentZoneFrame = {
    parent: null,
    zone: new Zone(null, null)
  };
  var _currentTask = null;
  var _numberOfNestedTaskFrames = 0;

  function noop() {}

  performanceMeasure('Zone', 'Zone');
  return global['Zone'] = Zone;
}(typeof window !== 'undefined' && window || typeof self !== 'undefined' && self || global);
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * Suppress closure compiler errors about unknown 'Zone' variable
 * @fileoverview
 * @suppress {undefinedVars,globalThis,missingRequire}
 */
/// <reference types="node"/>
// issue #989, to reduce bundle size, use short name

/** Object.getOwnPropertyDescriptor */


var ObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
/** Object.defineProperty */

var ObjectDefineProperty = Object.defineProperty;
/** Object.getPrototypeOf */

var ObjectGetPrototypeOf = Object.getPrototypeOf;
/** Object.create */

var ObjectCreate = Object.create;
/** Array.prototype.slice */

var ArraySlice = Array.prototype.slice;
/** addEventListener string const */

var ADD_EVENT_LISTENER_STR = 'addEventListener';
/** removeEventListener string const */

var REMOVE_EVENT_LISTENER_STR = 'removeEventListener';
/** zoneSymbol addEventListener */

var ZONE_SYMBOL_ADD_EVENT_LISTENER = Zone.__symbol__(ADD_EVENT_LISTENER_STR);
/** zoneSymbol removeEventListener */


var ZONE_SYMBOL_REMOVE_EVENT_LISTENER = Zone.__symbol__(REMOVE_EVENT_LISTENER_STR);
/** true string const */


var TRUE_STR = 'true';
/** false string const */

var FALSE_STR = 'false';
/** Zone symbol prefix string const. */

var ZONE_SYMBOL_PREFIX = Zone.__symbol__('');

function wrapWithCurrentZone(callback, source) {
  return Zone.current.wrap(callback, source);
}

function scheduleMacroTaskWithCurrentZone(source, callback, data, customSchedule, customCancel) {
  return Zone.current.scheduleMacroTask(source, callback, data, customSchedule, customCancel);
}

var zoneSymbol = Zone.__symbol__;
var isWindowExists = typeof window !== 'undefined';
var internalWindow = isWindowExists ? window : undefined;

var _global = isWindowExists && internalWindow || typeof self === 'object' && self || global;

var REMOVE_ATTRIBUTE = 'removeAttribute';
var NULL_ON_PROP_VALUE = [null];

function bindArguments(args, source) {
  for (var i = args.length - 1; i >= 0; i--) {
    if (typeof args[i] === 'function') {
      args[i] = wrapWithCurrentZone(args[i], source + '_' + i);
    }
  }

  return args;
}

function patchPrototype(prototype, fnNames) {
  var source = prototype.constructor['name'];

  var _loop = function _loop(i) {
    var name = fnNames[i];
    var delegate = prototype[name];

    if (delegate) {
      var prototypeDesc = ObjectGetOwnPropertyDescriptor(prototype, name);

      if (!isPropertyWritable(prototypeDesc)) {
        return "continue";
      }

      prototype[name] = function (delegate) {
        var patched = function patched() {
          return delegate.apply(this, bindArguments(arguments, source + '.' + name));
        };

        attachOriginToPatched(patched, delegate);
        return patched;
      }(delegate);
    }
  };

  for (var i = 0; i < fnNames.length; i++) {
    var _ret = _loop(i);

    if (_ret === "continue") continue;
  }
}

function isPropertyWritable(propertyDesc) {
  if (!propertyDesc) {
    return true;
  }

  if (propertyDesc.writable === false) {
    return false;
  }

  return !(typeof propertyDesc.get === 'function' && typeof propertyDesc.set === 'undefined');
}

var isWebWorker = typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope; // Make sure to access `process` through `_global` so that WebPack does not accidentally browserify
// this code.

var isNode = !('nw' in _global) && typeof _global.process !== 'undefined' && {}.toString.call(_global.process) === '[object process]';
var isBrowser = !isNode && !isWebWorker && !!(isWindowExists && internalWindow['HTMLElement']); // we are in electron of nw, so we are both browser and nodejs
// Make sure to access `process` through `_global` so that WebPack does not accidentally browserify
// this code.

var isMix = typeof _global.process !== 'undefined' && {}.toString.call(_global.process) === '[object process]' && !isWebWorker && !!(isWindowExists && internalWindow['HTMLElement']);
var zoneSymbolEventNames = {};

var wrapFn = function wrapFn(event) {
  // https://github.com/angular/zone.js/issues/911, in IE, sometimes
  // event will be undefined, so we need to use window.event
  event = event || _global.event;

  if (!event) {
    return;
  }

  var eventNameSymbol = zoneSymbolEventNames[event.type];

  if (!eventNameSymbol) {
    eventNameSymbol = zoneSymbolEventNames[event.type] = zoneSymbol('ON_PROPERTY' + event.type);
  }

  var target = this || event.target || _global;
  var listener = target[eventNameSymbol];
  var result;

  if (isBrowser && target === internalWindow && event.type === 'error') {
    // window.onerror have different signiture
    // https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onerror#window.onerror
    // and onerror callback will prevent default when callback return true
    var errorEvent = event;
    result = listener && listener.call(this, errorEvent.message, errorEvent.filename, errorEvent.lineno, errorEvent.colno, errorEvent.error);

    if (result === true) {
      event.preventDefault();
    }
  } else {
    result = listener && listener.apply(this, arguments);

    if (result != undefined && !result) {
      event.preventDefault();
    }
  }

  return result;
};

function patchProperty(obj, prop, prototype) {
  var desc = ObjectGetOwnPropertyDescriptor(obj, prop);

  if (!desc && prototype) {
    // when patch window object, use prototype to check prop exist or not
    var prototypeDesc = ObjectGetOwnPropertyDescriptor(prototype, prop);

    if (prototypeDesc) {
      desc = {
        enumerable: true,
        configurable: true
      };
    }
  } // if the descriptor not exists or is not configurable
  // just return


  if (!desc || !desc.configurable) {
    return;
  }

  var onPropPatchedSymbol = zoneSymbol('on' + prop + 'patched');

  if (obj.hasOwnProperty(onPropPatchedSymbol) && obj[onPropPatchedSymbol]) {
    return;
  } // A property descriptor cannot have getter/setter and be writable
  // deleting the writable and value properties avoids this error:
  //
  // TypeError: property descriptors must not specify a value or be writable when a
  // getter or setter has been specified


  delete desc.writable;
  delete desc.value;
  var originalDescGet = desc.get;
  var originalDescSet = desc.set; // substr(2) cuz 'onclick' -> 'click', etc

  var eventName = prop.substr(2);
  var eventNameSymbol = zoneSymbolEventNames[eventName];

  if (!eventNameSymbol) {
    eventNameSymbol = zoneSymbolEventNames[eventName] = zoneSymbol('ON_PROPERTY' + eventName);
  }

  desc.set = function (newValue) {
    // in some of windows's onproperty callback, this is undefined
    // so we need to check it
    var target = this;

    if (!target && obj === _global) {
      target = _global;
    }

    if (!target) {
      return;
    }

    var previousValue = target[eventNameSymbol];

    if (previousValue) {
      target.removeEventListener(eventName, wrapFn);
    } // issue #978, when onload handler was added before loading zone.js
    // we should remove it with originalDescSet


    if (originalDescSet) {
      originalDescSet.apply(target, NULL_ON_PROP_VALUE);
    }

    if (typeof newValue === 'function') {
      target[eventNameSymbol] = newValue;
      target.addEventListener(eventName, wrapFn, false);
    } else {
      target[eventNameSymbol] = null;
    }
  }; // The getter would return undefined for unassigned properties but the default value of an
  // unassigned property is null


  desc.get = function () {
    // in some of windows's onproperty callback, this is undefined
    // so we need to check it
    var target = this;

    if (!target && obj === _global) {
      target = _global;
    }

    if (!target) {
      return null;
    }

    var listener = target[eventNameSymbol];

    if (listener) {
      return listener;
    } else if (originalDescGet) {
      // result will be null when use inline event attribute,
      // such as <button onclick="func();">OK</button>
      // because the onclick function is internal raw uncompiled handler
      // the onclick will be evaluated when first time event was triggered or
      // the property is accessed, https://github.com/angular/zone.js/issues/525
      // so we should use original native get to retrieve the handler
      var value = originalDescGet && originalDescGet.call(this);

      if (value) {
        desc.set.call(this, value);

        if (typeof target[REMOVE_ATTRIBUTE] === 'function') {
          target.removeAttribute(prop);
        }

        return value;
      }
    }

    return null;
  };

  ObjectDefineProperty(obj, prop, desc);
  obj[onPropPatchedSymbol] = true;
}

function patchOnProperties(obj, properties, prototype) {
  if (properties) {
    for (var i = 0; i < properties.length; i++) {
      patchProperty(obj, 'on' + properties[i], prototype);
    }
  } else {
    var onProperties = [];

    for (var prop in obj) {
      if (prop.substr(0, 2) == 'on') {
        onProperties.push(prop);
      }
    }

    for (var j = 0; j < onProperties.length; j++) {
      patchProperty(obj, onProperties[j], prototype);
    }
  }
}

var originalInstanceKey = zoneSymbol('originalInstance'); // wrap some native API on `window`

function patchClass(className) {
  var OriginalClass = _global[className];
  if (!OriginalClass) return; // keep original class in global

  _global[zoneSymbol(className)] = OriginalClass;

  _global[className] = function () {
    var a = bindArguments(arguments, className);

    switch (a.length) {
      case 0:
        this[originalInstanceKey] = new OriginalClass();
        break;

      case 1:
        this[originalInstanceKey] = new OriginalClass(a[0]);
        break;

      case 2:
        this[originalInstanceKey] = new OriginalClass(a[0], a[1]);
        break;

      case 3:
        this[originalInstanceKey] = new OriginalClass(a[0], a[1], a[2]);
        break;

      case 4:
        this[originalInstanceKey] = new OriginalClass(a[0], a[1], a[2], a[3]);
        break;

      default:
        throw new Error('Arg list too long.');
    }
  }; // attach original delegate to patched function


  attachOriginToPatched(_global[className], OriginalClass);
  var instance = new OriginalClass(function () {});
  var prop;

  for (prop in instance) {
    // https://bugs.webkit.org/show_bug.cgi?id=44721
    if (className === 'XMLHttpRequest' && prop === 'responseBlob') continue;

    (function (prop) {
      if (typeof instance[prop] === 'function') {
        _global[className].prototype[prop] = function () {
          return this[originalInstanceKey][prop].apply(this[originalInstanceKey], arguments);
        };
      } else {
        ObjectDefineProperty(_global[className].prototype, prop, {
          set: function set(fn) {
            if (typeof fn === 'function') {
              this[originalInstanceKey][prop] = wrapWithCurrentZone(fn, className + '.' + prop); // keep callback in wrapped function so we can
              // use it in Function.prototype.toString to return
              // the native one.

              attachOriginToPatched(this[originalInstanceKey][prop], fn);
            } else {
              this[originalInstanceKey][prop] = fn;
            }
          },
          get: function get() {
            return this[originalInstanceKey][prop];
          }
        });
      }
    })(prop);
  }

  for (prop in OriginalClass) {
    if (prop !== 'prototype' && OriginalClass.hasOwnProperty(prop)) {
      _global[className][prop] = OriginalClass[prop];
    }
  }
}

function patchMethod(target, name, patchFn) {
  var proto = target;

  while (proto && !proto.hasOwnProperty(name)) {
    proto = ObjectGetPrototypeOf(proto);
  }

  if (!proto && target[name]) {
    // somehow we did not find it, but we can see it. This happens on IE for Window properties.
    proto = target;
  }

  var delegateName = zoneSymbol(name);
  var delegate = null;

  if (proto && (!(delegate = proto[delegateName]) || !proto.hasOwnProperty(delegateName))) {
    delegate = proto[delegateName] = proto[name]; // check whether proto[name] is writable
    // some property is readonly in safari, such as HtmlCanvasElement.prototype.toBlob

    var desc = proto && ObjectGetOwnPropertyDescriptor(proto, name);

    if (isPropertyWritable(desc)) {
      var patchDelegate = patchFn(delegate, delegateName, name);

      proto[name] = function () {
        return patchDelegate(this, arguments);
      };

      attachOriginToPatched(proto[name], delegate);
    }
  }

  return delegate;
} // TODO: @JiaLiPassion, support cancel task later if necessary


function patchMacroTask(obj, funcName, metaCreator) {
  var setNative = null;

  function scheduleTask(task) {
    var data = task.data;

    data.args[data.cbIdx] = function () {
      task.invoke.apply(this, arguments);
    };

    setNative.apply(data.target, data.args);
    return task;
  }

  setNative = patchMethod(obj, funcName, function (delegate) {
    return function (self, args) {
      var meta = metaCreator(self, args);

      if (meta.cbIdx >= 0 && typeof args[meta.cbIdx] === 'function') {
        return scheduleMacroTaskWithCurrentZone(meta.name, args[meta.cbIdx], meta, scheduleTask);
      } else {
        // cause an error by calling it directly.
        return delegate.apply(self, args);
      }
    };
  });
}

function attachOriginToPatched(patched, original) {
  patched[zoneSymbol('OriginalDelegate')] = original;
}

var isDetectedIEOrEdge = false;
var ieOrEdge = false;

function isIE() {
  try {
    var ua = internalWindow.navigator.userAgent;

    if (ua.indexOf('MSIE ') !== -1 || ua.indexOf('Trident/') !== -1) {
      return true;
    }
  } catch (error) {}

  return false;
}

function isIEOrEdge() {
  if (isDetectedIEOrEdge) {
    return ieOrEdge;
  }

  isDetectedIEOrEdge = true;

  try {
    var ua = internalWindow.navigator.userAgent;

    if (ua.indexOf('MSIE ') !== -1 || ua.indexOf('Trident/') !== -1 || ua.indexOf('Edge/') !== -1) {
      ieOrEdge = true;
    }
  } catch (error) {}

  return ieOrEdge;
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */


Zone.__load_patch('ZoneAwarePromise', function (global, Zone, api) {
  var ObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  var ObjectDefineProperty = Object.defineProperty;

  function readableObjectToString(obj) {
    if (obj && obj.toString === Object.prototype.toString) {
      var className = obj.constructor && obj.constructor.name;
      return (className ? className : '') + ': ' + JSON.stringify(obj);
    }

    return obj ? obj.toString() : Object.prototype.toString.call(obj);
  }

  var __symbol__ = api.symbol;
  var _uncaughtPromiseErrors = [];
  var isDisableWrappingUncaughtPromiseRejection = global[__symbol__('DISABLE_WRAPPING_UNCAUGHT_PROMISE_REJECTION')] === true;

  var symbolPromise = __symbol__('Promise');

  var symbolThen = __symbol__('then');

  var creationTrace = '__creationTrace__';

  api.onUnhandledError = function (e) {
    if (api.showUncaughtError()) {
      var rejection = e && e.rejection;

      if (rejection) {
        console.error('Unhandled Promise rejection:', rejection instanceof Error ? rejection.message : rejection, '; Zone:', e.zone.name, '; Task:', e.task && e.task.source, '; Value:', rejection, rejection instanceof Error ? rejection.stack : undefined);
      } else {
        console.error(e);
      }
    }
  };

  api.microtaskDrainDone = function () {
    var _loop2 = function _loop2() {
      var uncaughtPromiseError = _uncaughtPromiseErrors.shift();

      try {
        uncaughtPromiseError.zone.runGuarded(function () {
          if (uncaughtPromiseError.throwOriginal) {
            throw uncaughtPromiseError.rejection;
          }

          throw uncaughtPromiseError;
        });
      } catch (error) {
        handleUnhandledRejection(error);
      }
    };

    while (_uncaughtPromiseErrors.length) {
      _loop2();
    }
  };

  var UNHANDLED_PROMISE_REJECTION_HANDLER_SYMBOL = __symbol__('unhandledPromiseRejectionHandler');

  function handleUnhandledRejection(e) {
    api.onUnhandledError(e);

    try {
      var handler = Zone[UNHANDLED_PROMISE_REJECTION_HANDLER_SYMBOL];

      if (typeof handler === 'function') {
        handler.call(this, e);
      }
    } catch (err) {}
  }

  function isThenable(value) {
    return value && value.then;
  }

  function forwardResolution(value) {
    return value;
  }

  function forwardRejection(rejection) {
    return ZoneAwarePromise.reject(rejection);
  }

  var symbolState = __symbol__('state');

  var symbolValue = __symbol__('value');

  var symbolFinally = __symbol__('finally');

  var symbolParentPromiseValue = __symbol__('parentPromiseValue');

  var symbolParentPromiseState = __symbol__('parentPromiseState');

  var source = 'Promise.then';
  var UNRESOLVED = null;
  var RESOLVED = true;
  var REJECTED = false;
  var REJECTED_NO_CATCH = 0;

  function makeResolver(promise, state) {
    return function (v) {
      try {
        resolvePromise(promise, state, v);
      } catch (err) {
        resolvePromise(promise, false, err);
      } // Do not return value or you will break the Promise spec.

    };
  }

  var once = function once() {
    var wasCalled = false;
    return function wrapper(wrappedFunction) {
      return function () {
        if (wasCalled) {
          return;
        }

        wasCalled = true;
        wrappedFunction.apply(null, arguments);
      };
    };
  };

  var TYPE_ERROR = 'Promise resolved with itself';

  var CURRENT_TASK_TRACE_SYMBOL = __symbol__('currentTaskTrace'); // Promise Resolution


  function resolvePromise(promise, state, value) {
    var onceWrapper = once();

    if (promise === value) {
      throw new TypeError(TYPE_ERROR);
    }

    if (promise[symbolState] === UNRESOLVED) {
      // should only get value.then once based on promise spec.
      var then = null;

      try {
        if (typeof value === 'object' || typeof value === 'function') {
          then = value && value.then;
        }
      } catch (err) {
        onceWrapper(function () {
          resolvePromise(promise, false, err);
        })();
        return promise;
      } // if (value instanceof ZoneAwarePromise) {


      if (state !== REJECTED && value instanceof ZoneAwarePromise && value.hasOwnProperty(symbolState) && value.hasOwnProperty(symbolValue) && value[symbolState] !== UNRESOLVED) {
        clearRejectedNoCatch(value);
        resolvePromise(promise, value[symbolState], value[symbolValue]);
      } else if (state !== REJECTED && typeof then === 'function') {
        try {
          then.call(value, onceWrapper(makeResolver(promise, state)), onceWrapper(makeResolver(promise, false)));
        } catch (err) {
          onceWrapper(function () {
            resolvePromise(promise, false, err);
          })();
        }
      } else {
        promise[symbolState] = state;
        var queue = promise[symbolValue];
        promise[symbolValue] = value;

        if (promise[symbolFinally] === symbolFinally) {
          // the promise is generated by Promise.prototype.finally
          if (state === RESOLVED) {
            // the state is resolved, should ignore the value
            // and use parent promise value
            promise[symbolState] = promise[symbolParentPromiseState];
            promise[symbolValue] = promise[symbolParentPromiseValue];
          }
        } // record task information in value when error occurs, so we can
        // do some additional work such as render longStackTrace


        if (state === REJECTED && value instanceof Error) {
          // check if longStackTraceZone is here
          var trace = Zone.currentTask && Zone.currentTask.data && Zone.currentTask.data[creationTrace];

          if (trace) {
            // only keep the long stack trace into error when in longStackTraceZone
            ObjectDefineProperty(value, CURRENT_TASK_TRACE_SYMBOL, {
              configurable: true,
              enumerable: false,
              writable: true,
              value: trace
            });
          }
        }

        for (var i = 0; i < queue.length;) {
          scheduleResolveOrReject(promise, queue[i++], queue[i++], queue[i++], queue[i++]);
        }

        if (queue.length == 0 && state == REJECTED) {
          promise[symbolState] = REJECTED_NO_CATCH;
          var uncaughtPromiseError = value;

          try {
            // Here we throws a new Error to print more readable error log
            // and if the value is not an error, zone.js builds an `Error`
            // Object here to attach the stack information.
            throw new Error('Uncaught (in promise): ' + readableObjectToString(value) + (value && value.stack ? '\n' + value.stack : ''));
          } catch (err) {
            uncaughtPromiseError = err;
          }

          if (isDisableWrappingUncaughtPromiseRejection) {
            // If disable wrapping uncaught promise reject
            // use the value instead of wrapping it.
            uncaughtPromiseError.throwOriginal = true;
          }

          uncaughtPromiseError.rejection = value;
          uncaughtPromiseError.promise = promise;
          uncaughtPromiseError.zone = Zone.current;
          uncaughtPromiseError.task = Zone.currentTask;

          _uncaughtPromiseErrors.push(uncaughtPromiseError);

          api.scheduleMicroTask(); // to make sure that it is running
        }
      }
    } // Resolving an already resolved promise is a noop.


    return promise;
  }

  var REJECTION_HANDLED_HANDLER = __symbol__('rejectionHandledHandler');

  function clearRejectedNoCatch(promise) {
    if (promise[symbolState] === REJECTED_NO_CATCH) {
      // if the promise is rejected no catch status
      // and queue.length > 0, means there is a error handler
      // here to handle the rejected promise, we should trigger
      // windows.rejectionhandled eventHandler or nodejs rejectionHandled
      // eventHandler
      try {
        var handler = Zone[REJECTION_HANDLED_HANDLER];

        if (handler && typeof handler === 'function') {
          handler.call(this, {
            rejection: promise[symbolValue],
            promise: promise
          });
        }
      } catch (err) {}

      promise[symbolState] = REJECTED;

      for (var i = 0; i < _uncaughtPromiseErrors.length; i++) {
        if (promise === _uncaughtPromiseErrors[i].promise) {
          _uncaughtPromiseErrors.splice(i, 1);
        }
      }
    }
  }

  function scheduleResolveOrReject(promise, zone, chainPromise, onFulfilled, onRejected) {
    clearRejectedNoCatch(promise);
    var promiseState = promise[symbolState];
    var delegate = promiseState ? typeof onFulfilled === 'function' ? onFulfilled : forwardResolution : typeof onRejected === 'function' ? onRejected : forwardRejection;
    zone.scheduleMicroTask(source, function () {
      try {
        var parentPromiseValue = promise[symbolValue];
        var isFinallyPromise = !!chainPromise && symbolFinally === chainPromise[symbolFinally];

        if (isFinallyPromise) {
          // if the promise is generated from finally call, keep parent promise's state and value
          chainPromise[symbolParentPromiseValue] = parentPromiseValue;
          chainPromise[symbolParentPromiseState] = promiseState;
        } // should not pass value to finally callback


        var value = zone.run(delegate, undefined, isFinallyPromise && delegate !== forwardRejection && delegate !== forwardResolution ? [] : [parentPromiseValue]);
        resolvePromise(chainPromise, true, value);
      } catch (error) {
        // if error occurs, should always return this error
        resolvePromise(chainPromise, false, error);
      }
    }, chainPromise);
  }

  var ZONE_AWARE_PROMISE_TO_STRING = 'function ZoneAwarePromise() { [native code] }';

  var noop = function noop() {};

  var ZoneAwarePromise = /*#__PURE__*/function (_Symbol$toStringTag, _Symbol$species) {
    function ZoneAwarePromise(executor) {
      _classCallCheck(this, ZoneAwarePromise);

      var promise = this;

      if (!(promise instanceof ZoneAwarePromise)) {
        throw new Error('Must be an instanceof Promise.');
      }

      promise[symbolState] = UNRESOLVED;
      promise[symbolValue] = []; // queue;

      try {
        executor && executor(makeResolver(promise, RESOLVED), makeResolver(promise, REJECTED));
      } catch (error) {
        resolvePromise(promise, false, error);
      }
    }

    _createClass(ZoneAwarePromise, [{
      key: _Symbol$toStringTag,
      get: function get() {
        return 'Promise';
      }
    }, {
      key: _Symbol$species,
      get: function get() {
        return ZoneAwarePromise;
      }
    }, {
      key: "then",
      value: function then(onFulfilled, onRejected) {
        var C = this.constructor[Symbol.species];

        if (!C || typeof C !== 'function') {
          C = this.constructor || ZoneAwarePromise;
        }

        var chainPromise = new C(noop);
        var zone = Zone.current;

        if (this[symbolState] == UNRESOLVED) {
          this[symbolValue].push(zone, chainPromise, onFulfilled, onRejected);
        } else {
          scheduleResolveOrReject(this, zone, chainPromise, onFulfilled, onRejected);
        }

        return chainPromise;
      }
    }, {
      key: "catch",
      value: function _catch(onRejected) {
        return this.then(null, onRejected);
      }
    }, {
      key: "finally",
      value: function _finally(onFinally) {
        var C = this.constructor[Symbol.species];

        if (!C || typeof C !== 'function') {
          C = ZoneAwarePromise;
        }

        var chainPromise = new C(noop);
        chainPromise[symbolFinally] = symbolFinally;
        var zone = Zone.current;

        if (this[symbolState] == UNRESOLVED) {
          this[symbolValue].push(zone, chainPromise, onFinally, onFinally);
        } else {
          scheduleResolveOrReject(this, zone, chainPromise, onFinally, onFinally);
        }

        return chainPromise;
      }
    }], [{
      key: "toString",
      value: function toString() {
        return ZONE_AWARE_PROMISE_TO_STRING;
      }
    }, {
      key: "resolve",
      value: function resolve(value) {
        return resolvePromise(new this(null), RESOLVED, value);
      }
    }, {
      key: "reject",
      value: function reject(error) {
        return resolvePromise(new this(null), REJECTED, error);
      }
    }, {
      key: "race",
      value: function race(values) {
        var resolve;
        var reject;
        var promise = new this(function (res, rej) {
          resolve = res;
          reject = rej;
        });

        function onResolve(value) {
          resolve(value);
        }

        function onReject(error) {
          reject(error);
        }

        var _iterator = _createForOfIteratorHelper(values),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var value = _step.value;

            if (!isThenable(value)) {
              value = this.resolve(value);
            }

            value.then(onResolve, onReject);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        return promise;
      }
    }, {
      key: "all",
      value: function all(values) {
        return ZoneAwarePromise.allWithCallback(values);
      }
    }, {
      key: "allSettled",
      value: function allSettled(values) {
        var P = this && this.prototype instanceof ZoneAwarePromise ? this : ZoneAwarePromise;
        return P.allWithCallback(values, {
          thenCallback: function thenCallback(value) {
            return {
              status: 'fulfilled',
              value: value
            };
          },
          errorCallback: function errorCallback(err) {
            return {
              status: 'rejected',
              reason: err
            };
          }
        });
      }
    }, {
      key: "allWithCallback",
      value: function allWithCallback(values, callback) {
        var _this = this;

        var resolve;
        var reject;
        var promise = new this(function (res, rej) {
          resolve = res;
          reject = rej;
        }); // Start at 2 to prevent prematurely resolving if .then is called immediately.

        var unresolvedCount = 2;
        var valueIndex = 0;
        var resolvedValues = [];

        var _iterator2 = _createForOfIteratorHelper(values),
            _step2;

        try {
          var _loop3 = function _loop3() {
            var value = _step2.value;

            if (!isThenable(value)) {
              value = _this.resolve(value);
            }

            var curValueIndex = valueIndex;

            try {
              value.then(function (value) {
                resolvedValues[curValueIndex] = callback ? callback.thenCallback(value) : value;
                unresolvedCount--;

                if (unresolvedCount === 0) {
                  resolve(resolvedValues);
                }
              }, function (err) {
                if (!callback) {
                  reject(err);
                } else {
                  resolvedValues[curValueIndex] = callback.errorCallback(err);
                  unresolvedCount--;

                  if (unresolvedCount === 0) {
                    resolve(resolvedValues);
                  }
                }
              });
            } catch (thenErr) {
              reject(thenErr);
            }

            unresolvedCount++;
            valueIndex++;
          };

          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            _loop3();
          } // Make the unresolvedCount zero-based again.

        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }

        unresolvedCount -= 2;

        if (unresolvedCount === 0) {
          resolve(resolvedValues);
        }

        return promise;
      }
    }]);

    return ZoneAwarePromise;
  }(Symbol.toStringTag, Symbol.species); // Protect against aggressive optimizers dropping seemingly unused properties.
  // E.g. Closure Compiler in advanced mode.


  ZoneAwarePromise['resolve'] = ZoneAwarePromise.resolve;
  ZoneAwarePromise['reject'] = ZoneAwarePromise.reject;
  ZoneAwarePromise['race'] = ZoneAwarePromise.race;
  ZoneAwarePromise['all'] = ZoneAwarePromise.all;
  var NativePromise = global[symbolPromise] = global['Promise'];
  global['Promise'] = ZoneAwarePromise;

  var symbolThenPatched = __symbol__('thenPatched');

  function patchThen(Ctor) {
    var proto = Ctor.prototype;
    var prop = ObjectGetOwnPropertyDescriptor(proto, 'then');

    if (prop && (prop.writable === false || !prop.configurable)) {
      // check Ctor.prototype.then propertyDescriptor is writable or not
      // in meteor env, writable is false, we should ignore such case
      return;
    }

    var originalThen = proto.then; // Keep a reference to the original method.

    proto[symbolThen] = originalThen;

    Ctor.prototype.then = function (onResolve, onReject) {
      var _this2 = this;

      var wrapped = new ZoneAwarePromise(function (resolve, reject) {
        originalThen.call(_this2, resolve, reject);
      });
      return wrapped.then(onResolve, onReject);
    };

    Ctor[symbolThenPatched] = true;
  }

  api.patchThen = patchThen;

  function zoneify(fn) {
    return function (self, args) {
      var resultPromise = fn.apply(self, args);

      if (resultPromise instanceof ZoneAwarePromise) {
        return resultPromise;
      }

      var ctor = resultPromise.constructor;

      if (!ctor[symbolThenPatched]) {
        patchThen(ctor);
      }

      return resultPromise;
    };
  }

  if (NativePromise) {
    patchThen(NativePromise);
    patchMethod(global, 'fetch', function (delegate) {
      return zoneify(delegate);
    });
  } // This is not part of public API, but it is useful for tests, so we expose it.


  Promise[Zone.__symbol__('uncaughtPromiseErrors')] = _uncaughtPromiseErrors;
  return ZoneAwarePromise;
});
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
// override Function.prototype.toString to make zone.js patched function
// look like native function


Zone.__load_patch('toString', function (global) {
  // patch Func.prototype.toString to let them look like native
  var originalFunctionToString = Function.prototype.toString;
  var ORIGINAL_DELEGATE_SYMBOL = zoneSymbol('OriginalDelegate');
  var PROMISE_SYMBOL = zoneSymbol('Promise');
  var ERROR_SYMBOL = zoneSymbol('Error');

  var newFunctionToString = function toString() {
    if (typeof this === 'function') {
      var originalDelegate = this[ORIGINAL_DELEGATE_SYMBOL];

      if (originalDelegate) {
        if (typeof originalDelegate === 'function') {
          return originalFunctionToString.call(originalDelegate);
        } else {
          return Object.prototype.toString.call(originalDelegate);
        }
      }

      if (this === Promise) {
        var nativePromise = global[PROMISE_SYMBOL];

        if (nativePromise) {
          return originalFunctionToString.call(nativePromise);
        }
      }

      if (this === Error) {
        var nativeError = global[ERROR_SYMBOL];

        if (nativeError) {
          return originalFunctionToString.call(nativeError);
        }
      }
    }

    return originalFunctionToString.call(this);
  };

  newFunctionToString[ORIGINAL_DELEGATE_SYMBOL] = originalFunctionToString;
  Function.prototype.toString = newFunctionToString; // patch Object.prototype.toString to let them look like native

  var originalObjectToString = Object.prototype.toString;
  var PROMISE_OBJECT_TO_STRING = '[object Promise]';

  Object.prototype.toString = function () {
    if (typeof Promise === 'function' && this instanceof Promise) {
      return PROMISE_OBJECT_TO_STRING;
    }

    return originalObjectToString.call(this);
  };
});
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */


var passiveSupported = false;

if (typeof window !== 'undefined') {
  try {
    var options = Object.defineProperty({}, 'passive', {
      get: function get() {
        passiveSupported = true;
      }
    });
    window.addEventListener('test', options, options);
    window.removeEventListener('test', options, options);
  } catch (err) {
    passiveSupported = false;
  }
} // an identifier to tell ZoneTask do not create a new invoke closure


var OPTIMIZED_ZONE_EVENT_TASK_DATA = {
  useG: true
};
var zoneSymbolEventNames$1 = {};
var globalSources = {};
var EVENT_NAME_SYMBOL_REGX = new RegExp('^' + ZONE_SYMBOL_PREFIX + '(\\w+)(true|false)$');
var IMMEDIATE_PROPAGATION_SYMBOL = zoneSymbol('propagationStopped');

function prepareEventNames(eventName, eventNameToString) {
  var falseEventName = (eventNameToString ? eventNameToString(eventName) : eventName) + FALSE_STR;
  var trueEventName = (eventNameToString ? eventNameToString(eventName) : eventName) + TRUE_STR;
  var symbol = ZONE_SYMBOL_PREFIX + falseEventName;
  var symbolCapture = ZONE_SYMBOL_PREFIX + trueEventName;
  zoneSymbolEventNames$1[eventName] = {};
  zoneSymbolEventNames$1[eventName][FALSE_STR] = symbol;
  zoneSymbolEventNames$1[eventName][TRUE_STR] = symbolCapture;
}

function patchEventTarget(_global, apis, patchOptions) {
  var ADD_EVENT_LISTENER = patchOptions && patchOptions.add || ADD_EVENT_LISTENER_STR;
  var REMOVE_EVENT_LISTENER = patchOptions && patchOptions.rm || REMOVE_EVENT_LISTENER_STR;
  var LISTENERS_EVENT_LISTENER = patchOptions && patchOptions.listeners || 'eventListeners';
  var REMOVE_ALL_LISTENERS_EVENT_LISTENER = patchOptions && patchOptions.rmAll || 'removeAllListeners';
  var zoneSymbolAddEventListener = zoneSymbol(ADD_EVENT_LISTENER);
  var ADD_EVENT_LISTENER_SOURCE = '.' + ADD_EVENT_LISTENER + ':';
  var PREPEND_EVENT_LISTENER = 'prependListener';
  var PREPEND_EVENT_LISTENER_SOURCE = '.' + PREPEND_EVENT_LISTENER + ':';

  var invokeTask = function invokeTask(task, target, event) {
    // for better performance, check isRemoved which is set
    // by removeEventListener
    if (task.isRemoved) {
      return;
    }

    var delegate = task.callback;

    if (typeof delegate === 'object' && delegate.handleEvent) {
      // create the bind version of handleEvent when invoke
      task.callback = function (event) {
        return delegate.handleEvent(event);
      };

      task.originalDelegate = delegate;
    } // invoke static task.invoke


    task.invoke(task, target, [event]);
    var options = task.options;

    if (options && typeof options === 'object' && options.once) {
      // if options.once is true, after invoke once remove listener here
      // only browser need to do this, nodejs eventEmitter will cal removeListener
      // inside EventEmitter.once
      var _delegate = task.originalDelegate ? task.originalDelegate : task.callback;

      target[REMOVE_EVENT_LISTENER].call(target, event.type, _delegate, options);
    }
  }; // global shared zoneAwareCallback to handle all event callback with capture = false


  var globalZoneAwareCallback = function globalZoneAwareCallback(event) {
    // https://github.com/angular/zone.js/issues/911, in IE, sometimes
    // event will be undefined, so we need to use window.event
    event = event || _global.event;

    if (!event) {
      return;
    } // event.target is needed for Samsung TV and SourceBuffer
    // || global is needed https://github.com/angular/zone.js/issues/190


    var target = this || event.target || _global;
    var tasks = target[zoneSymbolEventNames$1[event.type][FALSE_STR]];

    if (tasks) {
      // invoke all tasks which attached to current target with given event.type and capture = false
      // for performance concern, if task.length === 1, just invoke
      if (tasks.length === 1) {
        invokeTask(tasks[0], target, event);
      } else {
        // https://github.com/angular/zone.js/issues/836
        // copy the tasks array before invoke, to avoid
        // the callback will remove itself or other listener
        var copyTasks = tasks.slice();

        for (var i = 0; i < copyTasks.length; i++) {
          if (event && event[IMMEDIATE_PROPAGATION_SYMBOL] === true) {
            break;
          }

          invokeTask(copyTasks[i], target, event);
        }
      }
    }
  }; // global shared zoneAwareCallback to handle all event callback with capture = true


  var globalZoneAwareCaptureCallback = function globalZoneAwareCaptureCallback(event) {
    // https://github.com/angular/zone.js/issues/911, in IE, sometimes
    // event will be undefined, so we need to use window.event
    event = event || _global.event;

    if (!event) {
      return;
    } // event.target is needed for Samsung TV and SourceBuffer
    // || global is needed https://github.com/angular/zone.js/issues/190


    var target = this || event.target || _global;
    var tasks = target[zoneSymbolEventNames$1[event.type][TRUE_STR]];

    if (tasks) {
      // invoke all tasks which attached to current target with given event.type and capture = false
      // for performance concern, if task.length === 1, just invoke
      if (tasks.length === 1) {
        invokeTask(tasks[0], target, event);
      } else {
        // https://github.com/angular/zone.js/issues/836
        // copy the tasks array before invoke, to avoid
        // the callback will remove itself or other listener
        var copyTasks = tasks.slice();

        for (var i = 0; i < copyTasks.length; i++) {
          if (event && event[IMMEDIATE_PROPAGATION_SYMBOL] === true) {
            break;
          }

          invokeTask(copyTasks[i], target, event);
        }
      }
    }
  };

  function patchEventTargetMethods(obj, patchOptions) {
    if (!obj) {
      return false;
    }

    var useGlobalCallback = true;

    if (patchOptions && patchOptions.useG !== undefined) {
      useGlobalCallback = patchOptions.useG;
    }

    var validateHandler = patchOptions && patchOptions.vh;
    var checkDuplicate = true;

    if (patchOptions && patchOptions.chkDup !== undefined) {
      checkDuplicate = patchOptions.chkDup;
    }

    var returnTarget = false;

    if (patchOptions && patchOptions.rt !== undefined) {
      returnTarget = patchOptions.rt;
    }

    var proto = obj;

    while (proto && !proto.hasOwnProperty(ADD_EVENT_LISTENER)) {
      proto = ObjectGetPrototypeOf(proto);
    }

    if (!proto && obj[ADD_EVENT_LISTENER]) {
      // somehow we did not find it, but we can see it. This happens on IE for Window properties.
      proto = obj;
    }

    if (!proto) {
      return false;
    }

    if (proto[zoneSymbolAddEventListener]) {
      return false;
    }

    var eventNameToString = patchOptions && patchOptions.eventNameToString; // a shared global taskData to pass data for scheduleEventTask
    // so we do not need to create a new object just for pass some data

    var taskData = {};
    var nativeAddEventListener = proto[zoneSymbolAddEventListener] = proto[ADD_EVENT_LISTENER];
    var nativeRemoveEventListener = proto[zoneSymbol(REMOVE_EVENT_LISTENER)] = proto[REMOVE_EVENT_LISTENER];
    var nativeListeners = proto[zoneSymbol(LISTENERS_EVENT_LISTENER)] = proto[LISTENERS_EVENT_LISTENER];
    var nativeRemoveAllListeners = proto[zoneSymbol(REMOVE_ALL_LISTENERS_EVENT_LISTENER)] = proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER];
    var nativePrependEventListener;

    if (patchOptions && patchOptions.prepend) {
      nativePrependEventListener = proto[zoneSymbol(patchOptions.prepend)] = proto[patchOptions.prepend];
    }
    /**
     * This util function will build an option object with passive option
     * to handle all possible input from the user.
     */


    function buildEventListenerOptions(options, passive) {
      if (!passiveSupported && typeof options === 'object' && options) {
        // doesn't support passive but user want to pass an object as options.
        // this will not work on some old browser, so we just pass a boolean
        // as useCapture parameter
        return !!options.capture;
      }

      if (!passiveSupported || !passive) {
        return options;
      }

      if (typeof options === 'boolean') {
        return {
          capture: options,
          passive: true
        };
      }

      if (!options) {
        return {
          passive: true
        };
      }

      if (typeof options === 'object' && options.passive !== false) {
        return Object.assign(Object.assign({}, options), {
          passive: true
        });
      }

      return options;
    }

    var customScheduleGlobal = function customScheduleGlobal(task) {
      // if there is already a task for the eventName + capture,
      // just return, because we use the shared globalZoneAwareCallback here.
      if (taskData.isExisting) {
        return;
      }

      return nativeAddEventListener.call(taskData.target, taskData.eventName, taskData.capture ? globalZoneAwareCaptureCallback : globalZoneAwareCallback, taskData.options);
    };

    var customCancelGlobal = function customCancelGlobal(task) {
      // if task is not marked as isRemoved, this call is directly
      // from Zone.prototype.cancelTask, we should remove the task
      // from tasksList of target first
      if (!task.isRemoved) {
        var symbolEventNames = zoneSymbolEventNames$1[task.eventName];
        var symbolEventName;

        if (symbolEventNames) {
          symbolEventName = symbolEventNames[task.capture ? TRUE_STR : FALSE_STR];
        }

        var existingTasks = symbolEventName && task.target[symbolEventName];

        if (existingTasks) {
          for (var i = 0; i < existingTasks.length; i++) {
            var existingTask = existingTasks[i];

            if (existingTask === task) {
              existingTasks.splice(i, 1); // set isRemoved to data for faster invokeTask check

              task.isRemoved = true;

              if (existingTasks.length === 0) {
                // all tasks for the eventName + capture have gone,
                // remove globalZoneAwareCallback and remove the task cache from target
                task.allRemoved = true;
                task.target[symbolEventName] = null;
              }

              break;
            }
          }
        }
      } // if all tasks for the eventName + capture have gone,
      // we will really remove the global event callback,
      // if not, return


      if (!task.allRemoved) {
        return;
      }

      return nativeRemoveEventListener.call(task.target, task.eventName, task.capture ? globalZoneAwareCaptureCallback : globalZoneAwareCallback, task.options);
    };

    var customScheduleNonGlobal = function customScheduleNonGlobal(task) {
      return nativeAddEventListener.call(taskData.target, taskData.eventName, task.invoke, taskData.options);
    };

    var customSchedulePrepend = function customSchedulePrepend(task) {
      return nativePrependEventListener.call(taskData.target, taskData.eventName, task.invoke, taskData.options);
    };

    var customCancelNonGlobal = function customCancelNonGlobal(task) {
      return nativeRemoveEventListener.call(task.target, task.eventName, task.invoke, task.options);
    };

    var customSchedule = useGlobalCallback ? customScheduleGlobal : customScheduleNonGlobal;
    var customCancel = useGlobalCallback ? customCancelGlobal : customCancelNonGlobal;

    var compareTaskCallbackVsDelegate = function compareTaskCallbackVsDelegate(task, delegate) {
      var typeOfDelegate = typeof delegate;
      return typeOfDelegate === 'function' && task.callback === delegate || typeOfDelegate === 'object' && task.originalDelegate === delegate;
    };

    var compare = patchOptions && patchOptions.diff ? patchOptions.diff : compareTaskCallbackVsDelegate;
    var unpatchedEvents = Zone[zoneSymbol('UNPATCHED_EVENTS')];

    var passiveEvents = _global[zoneSymbol('PASSIVE_EVENTS')];

    var makeAddListener = function makeAddListener(nativeListener, addSource, customScheduleFn, customCancelFn) {
      var returnTarget = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
      var prepend = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
      return function () {
        var target = this || _global;
        var eventName = arguments[0];

        if (patchOptions && patchOptions.transferEventName) {
          eventName = patchOptions.transferEventName(eventName);
        }

        var delegate = arguments[1];

        if (!delegate) {
          return nativeListener.apply(this, arguments);
        }

        if (isNode && eventName === 'uncaughtException') {
          // don't patch uncaughtException of nodejs to prevent endless loop
          return nativeListener.apply(this, arguments);
        } // don't create the bind delegate function for handleEvent
        // case here to improve addEventListener performance
        // we will create the bind delegate when invoke


        var isHandleEvent = false;

        if (typeof delegate !== 'function') {
          if (!delegate.handleEvent) {
            return nativeListener.apply(this, arguments);
          }

          isHandleEvent = true;
        }

        if (validateHandler && !validateHandler(nativeListener, delegate, target, arguments)) {
          return;
        }

        var passive = passiveSupported && !!passiveEvents && passiveEvents.indexOf(eventName) !== -1;
        var options = buildEventListenerOptions(arguments[2], passive);

        if (unpatchedEvents) {
          // check upatched list
          for (var i = 0; i < unpatchedEvents.length; i++) {
            if (eventName === unpatchedEvents[i]) {
              if (passive) {
                return nativeListener.call(target, eventName, delegate, options);
              } else {
                return nativeListener.apply(this, arguments);
              }
            }
          }
        }

        var capture = !options ? false : typeof options === 'boolean' ? true : options.capture;
        var once = options && typeof options === 'object' ? options.once : false;
        var zone = Zone.current;
        var symbolEventNames = zoneSymbolEventNames$1[eventName];

        if (!symbolEventNames) {
          prepareEventNames(eventName, eventNameToString);
          symbolEventNames = zoneSymbolEventNames$1[eventName];
        }

        var symbolEventName = symbolEventNames[capture ? TRUE_STR : FALSE_STR];
        var existingTasks = target[symbolEventName];
        var isExisting = false;

        if (existingTasks) {
          // already have task registered
          isExisting = true;

          if (checkDuplicate) {
            for (var _i = 0; _i < existingTasks.length; _i++) {
              if (compare(existingTasks[_i], delegate)) {
                // same callback, same capture, same event name, just return
                return;
              }
            }
          }
        } else {
          existingTasks = target[symbolEventName] = [];
        }

        var source;
        var constructorName = target.constructor['name'];
        var targetSource = globalSources[constructorName];

        if (targetSource) {
          source = targetSource[eventName];
        }

        if (!source) {
          source = constructorName + addSource + (eventNameToString ? eventNameToString(eventName) : eventName);
        } // do not create a new object as task.data to pass those things
        // just use the global shared one


        taskData.options = options;

        if (once) {
          // if addEventListener with once options, we don't pass it to
          // native addEventListener, instead we keep the once setting
          // and handle ourselves.
          taskData.options.once = false;
        }

        taskData.target = target;
        taskData.capture = capture;
        taskData.eventName = eventName;
        taskData.isExisting = isExisting;
        var data = useGlobalCallback ? OPTIMIZED_ZONE_EVENT_TASK_DATA : undefined; // keep taskData into data to allow onScheduleEventTask to access the task information

        if (data) {
          data.taskData = taskData;
        }

        var task = zone.scheduleEventTask(source, delegate, data, customScheduleFn, customCancelFn); // should clear taskData.target to avoid memory leak
        // issue, https://github.com/angular/angular/issues/20442

        taskData.target = null; // need to clear up taskData because it is a global object

        if (data) {
          data.taskData = null;
        } // have to save those information to task in case
        // application may call task.zone.cancelTask() directly


        if (once) {
          options.once = true;
        }

        if (!(!passiveSupported && typeof task.options === 'boolean')) {
          // if not support passive, and we pass an option object
          // to addEventListener, we should save the options to task
          task.options = options;
        }

        task.target = target;
        task.capture = capture;
        task.eventName = eventName;

        if (isHandleEvent) {
          // save original delegate for compare to check duplicate
          task.originalDelegate = delegate;
        }

        if (!prepend) {
          existingTasks.push(task);
        } else {
          existingTasks.unshift(task);
        }

        if (returnTarget) {
          return target;
        }
      };
    };

    proto[ADD_EVENT_LISTENER] = makeAddListener(nativeAddEventListener, ADD_EVENT_LISTENER_SOURCE, customSchedule, customCancel, returnTarget);

    if (nativePrependEventListener) {
      proto[PREPEND_EVENT_LISTENER] = makeAddListener(nativePrependEventListener, PREPEND_EVENT_LISTENER_SOURCE, customSchedulePrepend, customCancel, returnTarget, true);
    }

    proto[REMOVE_EVENT_LISTENER] = function () {
      var target = this || _global;
      var eventName = arguments[0];

      if (patchOptions && patchOptions.transferEventName) {
        eventName = patchOptions.transferEventName(eventName);
      }

      var options = arguments[2];
      var capture = !options ? false : typeof options === 'boolean' ? true : options.capture;
      var delegate = arguments[1];

      if (!delegate) {
        return nativeRemoveEventListener.apply(this, arguments);
      }

      if (validateHandler && !validateHandler(nativeRemoveEventListener, delegate, target, arguments)) {
        return;
      }

      var symbolEventNames = zoneSymbolEventNames$1[eventName];
      var symbolEventName;

      if (symbolEventNames) {
        symbolEventName = symbolEventNames[capture ? TRUE_STR : FALSE_STR];
      }

      var existingTasks = symbolEventName && target[symbolEventName];

      if (existingTasks) {
        for (var i = 0; i < existingTasks.length; i++) {
          var existingTask = existingTasks[i];

          if (compare(existingTask, delegate)) {
            existingTasks.splice(i, 1); // set isRemoved to data for faster invokeTask check

            existingTask.isRemoved = true;

            if (existingTasks.length === 0) {
              // all tasks for the eventName + capture have gone,
              // remove globalZoneAwareCallback and remove the task cache from target
              existingTask.allRemoved = true;
              target[symbolEventName] = null; // in the target, we have an event listener which is added by on_property
              // such as target.onclick = function() {}, so we need to clear this internal
              // property too if all delegates all removed

              if (typeof eventName === 'string') {
                var onPropertySymbol = ZONE_SYMBOL_PREFIX + 'ON_PROPERTY' + eventName;
                target[onPropertySymbol] = null;
              }
            }

            existingTask.zone.cancelTask(existingTask);

            if (returnTarget) {
              return target;
            }

            return;
          }
        }
      } // issue 930, didn't find the event name or callback
      // from zone kept existingTasks, the callback maybe
      // added outside of zone, we need to call native removeEventListener
      // to try to remove it.


      return nativeRemoveEventListener.apply(this, arguments);
    };

    proto[LISTENERS_EVENT_LISTENER] = function () {
      var target = this || _global;
      var eventName = arguments[0];

      if (patchOptions && patchOptions.transferEventName) {
        eventName = patchOptions.transferEventName(eventName);
      }

      var listeners = [];
      var tasks = findEventTasks(target, eventNameToString ? eventNameToString(eventName) : eventName);

      for (var i = 0; i < tasks.length; i++) {
        var task = tasks[i];
        var delegate = task.originalDelegate ? task.originalDelegate : task.callback;
        listeners.push(delegate);
      }

      return listeners;
    };

    proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER] = function () {
      var target = this || _global;
      var eventName = arguments[0];

      if (!eventName) {
        var keys = Object.keys(target);

        for (var i = 0; i < keys.length; i++) {
          var prop = keys[i];
          var match = EVENT_NAME_SYMBOL_REGX.exec(prop);
          var evtName = match && match[1]; // in nodejs EventEmitter, removeListener event is
          // used for monitoring the removeListener call,
          // so just keep removeListener eventListener until
          // all other eventListeners are removed

          if (evtName && evtName !== 'removeListener') {
            this[REMOVE_ALL_LISTENERS_EVENT_LISTENER].call(this, evtName);
          }
        } // remove removeListener listener finally


        this[REMOVE_ALL_LISTENERS_EVENT_LISTENER].call(this, 'removeListener');
      } else {
        if (patchOptions && patchOptions.transferEventName) {
          eventName = patchOptions.transferEventName(eventName);
        }

        var symbolEventNames = zoneSymbolEventNames$1[eventName];

        if (symbolEventNames) {
          var symbolEventName = symbolEventNames[FALSE_STR];
          var symbolCaptureEventName = symbolEventNames[TRUE_STR];
          var tasks = target[symbolEventName];
          var captureTasks = target[symbolCaptureEventName];

          if (tasks) {
            var removeTasks = tasks.slice();

            for (var _i2 = 0; _i2 < removeTasks.length; _i2++) {
              var task = removeTasks[_i2];
              var delegate = task.originalDelegate ? task.originalDelegate : task.callback;
              this[REMOVE_EVENT_LISTENER].call(this, eventName, delegate, task.options);
            }
          }

          if (captureTasks) {
            var _removeTasks = captureTasks.slice();

            for (var _i3 = 0; _i3 < _removeTasks.length; _i3++) {
              var _task = _removeTasks[_i3];

              var _delegate2 = _task.originalDelegate ? _task.originalDelegate : _task.callback;

              this[REMOVE_EVENT_LISTENER].call(this, eventName, _delegate2, _task.options);
            }
          }
        }
      }

      if (returnTarget) {
        return this;
      }
    }; // for native toString patch


    attachOriginToPatched(proto[ADD_EVENT_LISTENER], nativeAddEventListener);
    attachOriginToPatched(proto[REMOVE_EVENT_LISTENER], nativeRemoveEventListener);

    if (nativeRemoveAllListeners) {
      attachOriginToPatched(proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER], nativeRemoveAllListeners);
    }

    if (nativeListeners) {
      attachOriginToPatched(proto[LISTENERS_EVENT_LISTENER], nativeListeners);
    }

    return true;
  }

  var results = [];

  for (var i = 0; i < apis.length; i++) {
    results[i] = patchEventTargetMethods(apis[i], patchOptions);
  }

  return results;
}

function findEventTasks(target, eventName) {
  if (!eventName) {
    var foundTasks = [];

    for (var prop in target) {
      var match = EVENT_NAME_SYMBOL_REGX.exec(prop);
      var evtName = match && match[1];

      if (evtName && (!eventName || evtName === eventName)) {
        var tasks = target[prop];

        if (tasks) {
          for (var i = 0; i < tasks.length; i++) {
            foundTasks.push(tasks[i]);
          }
        }
      }
    }

    return foundTasks;
  }

  var symbolEventName = zoneSymbolEventNames$1[eventName];

  if (!symbolEventName) {
    prepareEventNames(eventName);
    symbolEventName = zoneSymbolEventNames$1[eventName];
  }

  var captureFalseTasks = target[symbolEventName[FALSE_STR]];
  var captureTrueTasks = target[symbolEventName[TRUE_STR]];

  if (!captureFalseTasks) {
    return captureTrueTasks ? captureTrueTasks.slice() : [];
  } else {
    return captureTrueTasks ? captureFalseTasks.concat(captureTrueTasks) : captureFalseTasks.slice();
  }
}

function patchEventPrototype(global, api) {
  var Event = global['Event'];

  if (Event && Event.prototype) {
    api.patchMethod(Event.prototype, 'stopImmediatePropagation', function (delegate) {
      return function (self, args) {
        self[IMMEDIATE_PROPAGATION_SYMBOL] = true; // we need to call the native stopImmediatePropagation
        // in case in some hybrid application, some part of
        // application will be controlled by zone, some are not

        delegate && delegate.apply(self, args);
      };
    });
  }
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */


function patchCallbacks(api, target, targetName, method, callbacks) {
  var symbol = Zone.__symbol__(method);

  if (target[symbol]) {
    return;
  }

  var nativeDelegate = target[symbol] = target[method];

  target[method] = function (name, opts, options) {
    if (opts && opts.prototype) {
      callbacks.forEach(function (callback) {
        var source = "".concat(targetName, ".").concat(method, "::") + callback;
        var prototype = opts.prototype;

        if (prototype.hasOwnProperty(callback)) {
          var descriptor = api.ObjectGetOwnPropertyDescriptor(prototype, callback);

          if (descriptor && descriptor.value) {
            descriptor.value = api.wrapWithCurrentZone(descriptor.value, source);

            api._redefineProperty(opts.prototype, callback, descriptor);
          } else if (prototype[callback]) {
            prototype[callback] = api.wrapWithCurrentZone(prototype[callback], source);
          }
        } else if (prototype[callback]) {
          prototype[callback] = api.wrapWithCurrentZone(prototype[callback], source);
        }
      });
    }

    return nativeDelegate.call(target, name, opts, options);
  };

  api.attachOriginToPatched(target[method], nativeDelegate);
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */


var globalEventHandlersEventNames = ['abort', 'animationcancel', 'animationend', 'animationiteration', 'auxclick', 'beforeinput', 'blur', 'cancel', 'canplay', 'canplaythrough', 'change', 'compositionstart', 'compositionupdate', 'compositionend', 'cuechange', 'click', 'close', 'contextmenu', 'curechange', 'dblclick', 'drag', 'dragend', 'dragenter', 'dragexit', 'dragleave', 'dragover', 'drop', 'durationchange', 'emptied', 'ended', 'error', 'focus', 'focusin', 'focusout', 'gotpointercapture', 'input', 'invalid', 'keydown', 'keypress', 'keyup', 'load', 'loadstart', 'loadeddata', 'loadedmetadata', 'lostpointercapture', 'mousedown', 'mouseenter', 'mouseleave', 'mousemove', 'mouseout', 'mouseover', 'mouseup', 'mousewheel', 'orientationchange', 'pause', 'play', 'playing', 'pointercancel', 'pointerdown', 'pointerenter', 'pointerleave', 'pointerlockchange', 'mozpointerlockchange', 'webkitpointerlockerchange', 'pointerlockerror', 'mozpointerlockerror', 'webkitpointerlockerror', 'pointermove', 'pointout', 'pointerover', 'pointerup', 'progress', 'ratechange', 'reset', 'resize', 'scroll', 'seeked', 'seeking', 'select', 'selectionchange', 'selectstart', 'show', 'sort', 'stalled', 'submit', 'suspend', 'timeupdate', 'volumechange', 'touchcancel', 'touchmove', 'touchstart', 'touchend', 'transitioncancel', 'transitionend', 'waiting', 'wheel'];
var documentEventNames = ['afterscriptexecute', 'beforescriptexecute', 'DOMContentLoaded', 'freeze', 'fullscreenchange', 'mozfullscreenchange', 'webkitfullscreenchange', 'msfullscreenchange', 'fullscreenerror', 'mozfullscreenerror', 'webkitfullscreenerror', 'msfullscreenerror', 'readystatechange', 'visibilitychange', 'resume'];
var windowEventNames = ['absolutedeviceorientation', 'afterinput', 'afterprint', 'appinstalled', 'beforeinstallprompt', 'beforeprint', 'beforeunload', 'devicelight', 'devicemotion', 'deviceorientation', 'deviceorientationabsolute', 'deviceproximity', 'hashchange', 'languagechange', 'message', 'mozbeforepaint', 'offline', 'online', 'paint', 'pageshow', 'pagehide', 'popstate', 'rejectionhandled', 'storage', 'unhandledrejection', 'unload', 'userproximity', 'vrdisplayconnected', 'vrdisplaydisconnected', 'vrdisplaypresentchange'];
var htmlElementEventNames = ['beforecopy', 'beforecut', 'beforepaste', 'copy', 'cut', 'paste', 'dragstart', 'loadend', 'animationstart', 'search', 'transitionrun', 'transitionstart', 'webkitanimationend', 'webkitanimationiteration', 'webkitanimationstart', 'webkittransitionend'];
var mediaElementEventNames = ['encrypted', 'waitingforkey', 'msneedkey', 'mozinterruptbegin', 'mozinterruptend'];
var ieElementEventNames = ['activate', 'afterupdate', 'ariarequest', 'beforeactivate', 'beforedeactivate', 'beforeeditfocus', 'beforeupdate', 'cellchange', 'controlselect', 'dataavailable', 'datasetchanged', 'datasetcomplete', 'errorupdate', 'filterchange', 'layoutcomplete', 'losecapture', 'move', 'moveend', 'movestart', 'propertychange', 'resizeend', 'resizestart', 'rowenter', 'rowexit', 'rowsdelete', 'rowsinserted', 'command', 'compassneedscalibration', 'deactivate', 'help', 'mscontentzoom', 'msmanipulationstatechanged', 'msgesturechange', 'msgesturedoubletap', 'msgestureend', 'msgesturehold', 'msgesturestart', 'msgesturetap', 'msgotpointercapture', 'msinertiastart', 'mslostpointercapture', 'mspointercancel', 'mspointerdown', 'mspointerenter', 'mspointerhover', 'mspointerleave', 'mspointermove', 'mspointerout', 'mspointerover', 'mspointerup', 'pointerout', 'mssitemodejumplistitemremoved', 'msthumbnailclick', 'stop', 'storagecommit'];
var webglEventNames = ['webglcontextrestored', 'webglcontextlost', 'webglcontextcreationerror'];
var formEventNames = ['autocomplete', 'autocompleteerror'];
var detailEventNames = ['toggle'];
var frameEventNames = ['load'];
var frameSetEventNames = ['blur', 'error', 'focus', 'load', 'resize', 'scroll', 'messageerror'];
var marqueeEventNames = ['bounce', 'finish', 'start'];
var XMLHttpRequestEventNames = ['loadstart', 'progress', 'abort', 'error', 'load', 'progress', 'timeout', 'loadend', 'readystatechange'];
var IDBIndexEventNames = ['upgradeneeded', 'complete', 'abort', 'success', 'error', 'blocked', 'versionchange', 'close'];
var websocketEventNames = ['close', 'error', 'open', 'message'];
var workerEventNames = ['error', 'message'];
var eventNames = globalEventHandlersEventNames.concat(webglEventNames, formEventNames, detailEventNames, documentEventNames, windowEventNames, htmlElementEventNames, ieElementEventNames);

function filterProperties(target, onProperties, ignoreProperties) {
  if (!ignoreProperties || ignoreProperties.length === 0) {
    return onProperties;
  }

  var tip = ignoreProperties.filter(function (ip) {
    return ip.target === target;
  });

  if (!tip || tip.length === 0) {
    return onProperties;
  }

  var targetIgnoreProperties = tip[0].ignoreProperties;
  return onProperties.filter(function (op) {
    return targetIgnoreProperties.indexOf(op) === -1;
  });
}

function patchFilteredProperties(target, onProperties, ignoreProperties, prototype) {
  // check whether target is available, sometimes target will be undefined
  // because different browser or some 3rd party plugin.
  if (!target) {
    return;
  }

  var filteredProperties = filterProperties(target, onProperties, ignoreProperties);
  patchOnProperties(target, filteredProperties, prototype);
}

function propertyDescriptorPatch(api, _global) {
  if (isNode && !isMix) {
    return;
  }

  if (Zone[api.symbol('patchEvents')]) {
    // events are already been patched by legacy patch.
    return;
  }

  var supportsWebSocket = typeof WebSocket !== 'undefined';
  var ignoreProperties = _global['__Zone_ignore_on_properties']; // for browsers that we can patch the descriptor:  Chrome & Firefox

  if (isBrowser) {
    var _internalWindow = window;
    var ignoreErrorProperties = isIE() ? [{
      target: _internalWindow,
      ignoreProperties: ['error']
    }] : []; // in IE/Edge, onProp not exist in window object, but in WindowPrototype
    // so we need to pass WindowPrototype to check onProp exist or not

    patchFilteredProperties(_internalWindow, eventNames.concat(['messageerror']), ignoreProperties ? ignoreProperties.concat(ignoreErrorProperties) : ignoreProperties, ObjectGetPrototypeOf(_internalWindow));
    patchFilteredProperties(Document.prototype, eventNames, ignoreProperties);

    if (typeof _internalWindow['SVGElement'] !== 'undefined') {
      patchFilteredProperties(_internalWindow['SVGElement'].prototype, eventNames, ignoreProperties);
    }

    patchFilteredProperties(Element.prototype, eventNames, ignoreProperties);
    patchFilteredProperties(HTMLElement.prototype, eventNames, ignoreProperties);
    patchFilteredProperties(HTMLMediaElement.prototype, mediaElementEventNames, ignoreProperties);
    patchFilteredProperties(HTMLFrameSetElement.prototype, windowEventNames.concat(frameSetEventNames), ignoreProperties);
    patchFilteredProperties(HTMLBodyElement.prototype, windowEventNames.concat(frameSetEventNames), ignoreProperties);
    patchFilteredProperties(HTMLFrameElement.prototype, frameEventNames, ignoreProperties);
    patchFilteredProperties(HTMLIFrameElement.prototype, frameEventNames, ignoreProperties);
    var HTMLMarqueeElement = _internalWindow['HTMLMarqueeElement'];

    if (HTMLMarqueeElement) {
      patchFilteredProperties(HTMLMarqueeElement.prototype, marqueeEventNames, ignoreProperties);
    }

    var Worker = _internalWindow['Worker'];

    if (Worker) {
      patchFilteredProperties(Worker.prototype, workerEventNames, ignoreProperties);
    }
  }

  var XMLHttpRequest = _global['XMLHttpRequest'];

  if (XMLHttpRequest) {
    // XMLHttpRequest is not available in ServiceWorker, so we need to check here
    patchFilteredProperties(XMLHttpRequest.prototype, XMLHttpRequestEventNames, ignoreProperties);
  }

  var XMLHttpRequestEventTarget = _global['XMLHttpRequestEventTarget'];

  if (XMLHttpRequestEventTarget) {
    patchFilteredProperties(XMLHttpRequestEventTarget && XMLHttpRequestEventTarget.prototype, XMLHttpRequestEventNames, ignoreProperties);
  }

  if (typeof IDBIndex !== 'undefined') {
    patchFilteredProperties(IDBIndex.prototype, IDBIndexEventNames, ignoreProperties);
    patchFilteredProperties(IDBRequest.prototype, IDBIndexEventNames, ignoreProperties);
    patchFilteredProperties(IDBOpenDBRequest.prototype, IDBIndexEventNames, ignoreProperties);
    patchFilteredProperties(IDBDatabase.prototype, IDBIndexEventNames, ignoreProperties);
    patchFilteredProperties(IDBTransaction.prototype, IDBIndexEventNames, ignoreProperties);
    patchFilteredProperties(IDBCursor.prototype, IDBIndexEventNames, ignoreProperties);
  }

  if (supportsWebSocket) {
    patchFilteredProperties(WebSocket.prototype, websocketEventNames, ignoreProperties);
  }
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */


Zone.__load_patch('util', function (global, Zone, api) {
  api.patchOnProperties = patchOnProperties;
  api.patchMethod = patchMethod;
  api.bindArguments = bindArguments;
  api.patchMacroTask = patchMacroTask; // In earlier version of zone.js (<0.9.0), we use env name `__zone_symbol__BLACK_LISTED_EVENTS` to
  // define which events will not be patched by `Zone.js`.
  // In newer version (>=0.9.0), we change the env name to `__zone_symbol__UNPATCHED_EVENTS` to keep
  // the name consistent with angular repo.
  // The  `__zone_symbol__BLACK_LISTED_EVENTS` is deprecated, but it is still be supported for
  // backwards compatibility.

  var SYMBOL_BLACK_LISTED_EVENTS = Zone.__symbol__('BLACK_LISTED_EVENTS');

  var SYMBOL_UNPATCHED_EVENTS = Zone.__symbol__('UNPATCHED_EVENTS');

  if (global[SYMBOL_UNPATCHED_EVENTS]) {
    global[SYMBOL_BLACK_LISTED_EVENTS] = global[SYMBOL_UNPATCHED_EVENTS];
  }

  if (global[SYMBOL_BLACK_LISTED_EVENTS]) {
    Zone[SYMBOL_BLACK_LISTED_EVENTS] = Zone[SYMBOL_UNPATCHED_EVENTS] = global[SYMBOL_BLACK_LISTED_EVENTS];
  }

  api.patchEventPrototype = patchEventPrototype;
  api.patchEventTarget = patchEventTarget;
  api.isIEOrEdge = isIEOrEdge;
  api.ObjectDefineProperty = ObjectDefineProperty;
  api.ObjectGetOwnPropertyDescriptor = ObjectGetOwnPropertyDescriptor;
  api.ObjectCreate = ObjectCreate;
  api.ArraySlice = ArraySlice;
  api.patchClass = patchClass;
  api.wrapWithCurrentZone = wrapWithCurrentZone;
  api.filterProperties = filterProperties;
  api.attachOriginToPatched = attachOriginToPatched;
  api._redefineProperty = Object.defineProperty;
  api.patchCallbacks = patchCallbacks;

  api.getGlobalObjects = function () {
    return {
      globalSources: globalSources,
      zoneSymbolEventNames: zoneSymbolEventNames$1,
      eventNames: eventNames,
      isBrowser: isBrowser,
      isMix: isMix,
      isNode: isNode,
      TRUE_STR: TRUE_STR,
      FALSE_STR: FALSE_STR,
      ZONE_SYMBOL_PREFIX: ZONE_SYMBOL_PREFIX,
      ADD_EVENT_LISTENER_STR: ADD_EVENT_LISTENER_STR,
      REMOVE_EVENT_LISTENER_STR: REMOVE_EVENT_LISTENER_STR
    };
  };
});
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */


var taskSymbol = zoneSymbol('zoneTask');

function patchTimer(window, setName, cancelName, nameSuffix) {
  var setNative = null;
  var clearNative = null;
  setName += nameSuffix;
  cancelName += nameSuffix;
  var tasksByHandleId = {};

  function scheduleTask(task) {
    var data = task.data;

    data.args[0] = function () {
      return task.invoke.apply(this, arguments);
    };

    data.handleId = setNative.apply(window, data.args);
    return task;
  }

  function clearTask(task) {
    return clearNative.call(window, task.data.handleId);
  }

  setNative = patchMethod(window, setName, function (delegate) {
    return function (self, args) {
      if (typeof args[0] === 'function') {
        var _options = {
          isPeriodic: nameSuffix === 'Interval',
          delay: nameSuffix === 'Timeout' || nameSuffix === 'Interval' ? args[1] || 0 : undefined,
          args: args
        };
        var callback = args[0];

        args[0] = function timer() {
          try {
            return callback.apply(this, arguments);
          } finally {
            // issue-934, task will be cancelled
            // even it is a periodic task such as
            // setInterval
            // https://github.com/angular/angular/issues/40387
            // Cleanup tasksByHandleId should be handled before scheduleTask
            // Since some zoneSpec may intercept and doesn't trigger
            // scheduleFn(scheduleTask) provided here.
            if (!_options.isPeriodic) {
              if (typeof _options.handleId === 'number') {
                // in non-nodejs env, we remove timerId
                // from local cache
                delete tasksByHandleId[_options.handleId];
              } else if (_options.handleId) {
                // Node returns complex objects as handleIds
                // we remove task reference from timer object
                _options.handleId[taskSymbol] = null;
              }
            }
          }
        };

        var task = scheduleMacroTaskWithCurrentZone(setName, args[0], _options, scheduleTask, clearTask);

        if (!task) {
          return task;
        } // Node.js must additionally support the ref and unref functions.


        var handle = task.data.handleId;

        if (typeof handle === 'number') {
          // for non nodejs env, we save handleId: task
          // mapping in local cache for clearTimeout
          tasksByHandleId[handle] = task;
        } else if (handle) {
          // for nodejs env, we save task
          // reference in timerId Object for clearTimeout
          handle[taskSymbol] = task;
        } // check whether handle is null, because some polyfill or browser
        // may return undefined from setTimeout/setInterval/setImmediate/requestAnimationFrame


        if (handle && handle.ref && handle.unref && typeof handle.ref === 'function' && typeof handle.unref === 'function') {
          task.ref = handle.ref.bind(handle);
          task.unref = handle.unref.bind(handle);
        }

        if (typeof handle === 'number' || handle) {
          return handle;
        }

        return task;
      } else {
        // cause an error by calling it directly.
        return delegate.apply(window, args);
      }
    };
  });
  clearNative = patchMethod(window, cancelName, function (delegate) {
    return function (self, args) {
      var id = args[0];
      var task;

      if (typeof id === 'number') {
        // non nodejs env.
        task = tasksByHandleId[id];
      } else {
        // nodejs env.
        task = id && id[taskSymbol]; // other environments.

        if (!task) {
          task = id;
        }
      }

      if (task && typeof task.type === 'string') {
        if (task.state !== 'notScheduled' && (task.cancelFn && task.data.isPeriodic || task.runCount === 0)) {
          if (typeof id === 'number') {
            delete tasksByHandleId[id];
          } else if (id) {
            id[taskSymbol] = null;
          } // Do not cancel already canceled functions


          task.zone.cancelTask(task);
        }
      } else {
        // cause an error by calling it directly.
        delegate.apply(window, args);
      }
    };
  });
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */


function patchCustomElements(_global, api) {
  var _api$getGlobalObjects = api.getGlobalObjects(),
      isBrowser = _api$getGlobalObjects.isBrowser,
      isMix = _api$getGlobalObjects.isMix;

  if (!isBrowser && !isMix || !_global['customElements'] || !('customElements' in _global)) {
    return;
  }

  var callbacks = ['connectedCallback', 'disconnectedCallback', 'adoptedCallback', 'attributeChangedCallback'];
  api.patchCallbacks(api, _global.customElements, 'customElements', 'define', callbacks);
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */


function eventTargetPatch(_global, api) {
  if (Zone[api.symbol('patchEventTarget')]) {
    // EventTarget is already patched.
    return;
  }

  var _api$getGlobalObjects2 = api.getGlobalObjects(),
      eventNames = _api$getGlobalObjects2.eventNames,
      zoneSymbolEventNames = _api$getGlobalObjects2.zoneSymbolEventNames,
      TRUE_STR = _api$getGlobalObjects2.TRUE_STR,
      FALSE_STR = _api$getGlobalObjects2.FALSE_STR,
      ZONE_SYMBOL_PREFIX = _api$getGlobalObjects2.ZONE_SYMBOL_PREFIX; //  predefine all __zone_symbol__ + eventName + true/false string


  for (var i = 0; i < eventNames.length; i++) {
    var eventName = eventNames[i];
    var falseEventName = eventName + FALSE_STR;
    var trueEventName = eventName + TRUE_STR;
    var symbol = ZONE_SYMBOL_PREFIX + falseEventName;
    var symbolCapture = ZONE_SYMBOL_PREFIX + trueEventName;
    zoneSymbolEventNames[eventName] = {};
    zoneSymbolEventNames[eventName][FALSE_STR] = symbol;
    zoneSymbolEventNames[eventName][TRUE_STR] = symbolCapture;
  }

  var EVENT_TARGET = _global['EventTarget'];

  if (!EVENT_TARGET || !EVENT_TARGET.prototype) {
    return;
  }

  api.patchEventTarget(_global, [EVENT_TARGET && EVENT_TARGET.prototype]);
  return true;
}

function patchEvent(global, api) {
  api.patchEventPrototype(global, api);
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */


Zone.__load_patch('legacy', function (global) {
  var legacyPatch = global[Zone.__symbol__('legacyPatch')];

  if (legacyPatch) {
    legacyPatch();
  }
});

Zone.__load_patch('queueMicrotask', function (global, Zone, api) {
  api.patchMethod(global, 'queueMicrotask', function (delegate) {
    return function (self, args) {
      Zone.current.scheduleMicroTask('queueMicrotask', args[0]);
    };
  });
});

Zone.__load_patch('timers', function (global) {
  var set = 'set';
  var clear = 'clear';
  patchTimer(global, set, clear, 'Timeout');
  patchTimer(global, set, clear, 'Interval');
  patchTimer(global, set, clear, 'Immediate');
});

Zone.__load_patch('requestAnimationFrame', function (global) {
  patchTimer(global, 'request', 'cancel', 'AnimationFrame');
  patchTimer(global, 'mozRequest', 'mozCancel', 'AnimationFrame');
  patchTimer(global, 'webkitRequest', 'webkitCancel', 'AnimationFrame');
});

Zone.__load_patch('blocking', function (global, Zone) {
  var blockingMethods = ['alert', 'prompt', 'confirm'];

  for (var i = 0; i < blockingMethods.length; i++) {
    var name = blockingMethods[i];
    patchMethod(global, name, function (delegate, symbol, name) {
      return function (s, args) {
        return Zone.current.run(delegate, global, args, name);
      };
    });
  }
});

Zone.__load_patch('EventTarget', function (global, Zone, api) {
  patchEvent(global, api);
  eventTargetPatch(global, api); // patch XMLHttpRequestEventTarget's addEventListener/removeEventListener

  var XMLHttpRequestEventTarget = global['XMLHttpRequestEventTarget'];

  if (XMLHttpRequestEventTarget && XMLHttpRequestEventTarget.prototype) {
    api.patchEventTarget(global, [XMLHttpRequestEventTarget.prototype]);
  }
});

Zone.__load_patch('MutationObserver', function (global, Zone, api) {
  patchClass('MutationObserver');
  patchClass('WebKitMutationObserver');
});

Zone.__load_patch('IntersectionObserver', function (global, Zone, api) {
  patchClass('IntersectionObserver');
});

Zone.__load_patch('FileReader', function (global, Zone, api) {
  patchClass('FileReader');
});

Zone.__load_patch('on_property', function (global, Zone, api) {
  propertyDescriptorPatch(api, global);
});

Zone.__load_patch('customElements', function (global, Zone, api) {
  patchCustomElements(global, api);
});

Zone.__load_patch('XHR', function (global, Zone) {
  // Treat XMLHttpRequest as a macrotask.
  patchXHR(global);
  var XHR_TASK = zoneSymbol('xhrTask');
  var XHR_SYNC = zoneSymbol('xhrSync');
  var XHR_LISTENER = zoneSymbol('xhrListener');
  var XHR_SCHEDULED = zoneSymbol('xhrScheduled');
  var XHR_URL = zoneSymbol('xhrURL');
  var XHR_ERROR_BEFORE_SCHEDULED = zoneSymbol('xhrErrorBeforeScheduled');

  function patchXHR(window) {
    var XMLHttpRequest = window['XMLHttpRequest'];

    if (!XMLHttpRequest) {
      // XMLHttpRequest is not available in service worker
      return;
    }

    var XMLHttpRequestPrototype = XMLHttpRequest.prototype;

    function findPendingTask(target) {
      return target[XHR_TASK];
    }

    var oriAddListener = XMLHttpRequestPrototype[ZONE_SYMBOL_ADD_EVENT_LISTENER];
    var oriRemoveListener = XMLHttpRequestPrototype[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];

    if (!oriAddListener) {
      var XMLHttpRequestEventTarget = window['XMLHttpRequestEventTarget'];

      if (XMLHttpRequestEventTarget) {
        var XMLHttpRequestEventTargetPrototype = XMLHttpRequestEventTarget.prototype;
        oriAddListener = XMLHttpRequestEventTargetPrototype[ZONE_SYMBOL_ADD_EVENT_LISTENER];
        oriRemoveListener = XMLHttpRequestEventTargetPrototype[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];
      }
    }

    var READY_STATE_CHANGE = 'readystatechange';
    var SCHEDULED = 'scheduled';

    function scheduleTask(task) {
      var data = task.data;
      var target = data.target;
      target[XHR_SCHEDULED] = false;
      target[XHR_ERROR_BEFORE_SCHEDULED] = false; // remove existing event listener

      var listener = target[XHR_LISTENER];

      if (!oriAddListener) {
        oriAddListener = target[ZONE_SYMBOL_ADD_EVENT_LISTENER];
        oriRemoveListener = target[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];
      }

      if (listener) {
        oriRemoveListener.call(target, READY_STATE_CHANGE, listener);
      }

      var newListener = target[XHR_LISTENER] = function () {
        if (target.readyState === target.DONE) {
          // sometimes on some browsers XMLHttpRequest will fire onreadystatechange with
          // readyState=4 multiple times, so we need to check task state here
          if (!data.aborted && target[XHR_SCHEDULED] && task.state === SCHEDULED) {
            // check whether the xhr has registered onload listener
            // if that is the case, the task should invoke after all
            // onload listeners finish.
            // Also if the request failed without response (status = 0), the load event handler
            // will not be triggered, in that case, we should also invoke the placeholder callback
            // to close the XMLHttpRequest::send macroTask.
            // https://github.com/angular/angular/issues/38795
            var loadTasks = target[Zone.__symbol__('loadfalse')];

            if (target.status !== 0 && loadTasks && loadTasks.length > 0) {
              var oriInvoke = task.invoke;

              task.invoke = function () {
                // need to load the tasks again, because in other
                // load listener, they may remove themselves
                var loadTasks = target[Zone.__symbol__('loadfalse')];

                for (var i = 0; i < loadTasks.length; i++) {
                  if (loadTasks[i] === task) {
                    loadTasks.splice(i, 1);
                  }
                }

                if (!data.aborted && task.state === SCHEDULED) {
                  oriInvoke.call(task);
                }
              };

              loadTasks.push(task);
            } else {
              task.invoke();
            }
          } else if (!data.aborted && target[XHR_SCHEDULED] === false) {
            // error occurs when xhr.send()
            target[XHR_ERROR_BEFORE_SCHEDULED] = true;
          }
        }
      };

      oriAddListener.call(target, READY_STATE_CHANGE, newListener);
      var storedTask = target[XHR_TASK];

      if (!storedTask) {
        target[XHR_TASK] = task;
      }

      sendNative.apply(target, data.args);
      target[XHR_SCHEDULED] = true;
      return task;
    }

    function placeholderCallback() {}

    function clearTask(task) {
      var data = task.data; // Note - ideally, we would call data.target.removeEventListener here, but it's too late
      // to prevent it from firing. So instead, we store info for the event listener.

      data.aborted = true;
      return abortNative.apply(data.target, data.args);
    }

    var openNative = patchMethod(XMLHttpRequestPrototype, 'open', function () {
      return function (self, args) {
        self[XHR_SYNC] = args[2] == false;
        self[XHR_URL] = args[1];
        return openNative.apply(self, args);
      };
    });
    var XMLHTTPREQUEST_SOURCE = 'XMLHttpRequest.send';
    var fetchTaskAborting = zoneSymbol('fetchTaskAborting');
    var fetchTaskScheduling = zoneSymbol('fetchTaskScheduling');
    var sendNative = patchMethod(XMLHttpRequestPrototype, 'send', function () {
      return function (self, args) {
        if (Zone.current[fetchTaskScheduling] === true) {
          // a fetch is scheduling, so we are using xhr to polyfill fetch
          // and because we already schedule macroTask for fetch, we should
          // not schedule a macroTask for xhr again
          return sendNative.apply(self, args);
        }

        if (self[XHR_SYNC]) {
          // if the XHR is sync there is no task to schedule, just execute the code.
          return sendNative.apply(self, args);
        } else {
          var _options2 = {
            target: self,
            url: self[XHR_URL],
            isPeriodic: false,
            args: args,
            aborted: false
          };
          var task = scheduleMacroTaskWithCurrentZone(XMLHTTPREQUEST_SOURCE, placeholderCallback, _options2, scheduleTask, clearTask);

          if (self && self[XHR_ERROR_BEFORE_SCHEDULED] === true && !_options2.aborted && task.state === SCHEDULED) {
            // xhr request throw error when send
            // we should invoke task instead of leaving a scheduled
            // pending macroTask
            task.invoke();
          }
        }
      };
    });
    var abortNative = patchMethod(XMLHttpRequestPrototype, 'abort', function () {
      return function (self, args) {
        var task = findPendingTask(self);

        if (task && typeof task.type == 'string') {
          // If the XHR has already completed, do nothing.
          // If the XHR has already been aborted, do nothing.
          // Fix #569, call abort multiple times before done will cause
          // macroTask task count be negative number
          if (task.cancelFn == null || task.data && task.data.aborted) {
            return;
          }

          task.zone.cancelTask(task);
        } else if (Zone.current[fetchTaskAborting] === true) {
          // the abort is called from fetch polyfill, we need to call native abort of XHR.
          return abortNative.apply(self, args);
        } // Otherwise, we are trying to abort an XHR which has not yet been sent, so there is no
        // task
        // to cancel. Do nothing.

      };
    });
  }
});

Zone.__load_patch('geolocation', function (global) {
  /// GEO_LOCATION
  if (global['navigator'] && global['navigator'].geolocation) {
    patchPrototype(global['navigator'].geolocation, ['getCurrentPosition', 'watchPosition']);
  }
});

Zone.__load_patch('PromiseRejectionEvent', function (global, Zone) {
  // handle unhandled promise rejection
  function findPromiseRejectionHandler(evtName) {
    return function (e) {
      var eventTasks = findEventTasks(global, evtName);
      eventTasks.forEach(function (eventTask) {
        // windows has added unhandledrejection event listener
        // trigger the event listener
        var PromiseRejectionEvent = global['PromiseRejectionEvent'];

        if (PromiseRejectionEvent) {
          var evt = new PromiseRejectionEvent(evtName, {
            promise: e.promise,
            reason: e.rejection
          });
          eventTask.invoke(evt);
        }
      });
    };
  }

  if (global['PromiseRejectionEvent']) {
    Zone[zoneSymbol('unhandledPromiseRejectionHandler')] = findPromiseRejectionHandler('unhandledrejection');
    Zone[zoneSymbol('rejectionHandledHandler')] = findPromiseRejectionHandler('rejectionhandled');
  }
});

/***/ }),

/***/ 86315:
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayLikeToArray.js ***!
  \*****************************************************************/
/***/ (function(module) {

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

module.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 52677:
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/classCallCheck.js ***!
  \***************************************************************/
/***/ (function(module) {

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 99010:
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/createClass.js ***!
  \************************************************************/
/***/ (function(module) {

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

module.exports = _createClass, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 61845:
/*!**************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js ***!
  \**************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var unsupportedIterableToArray = __webpack_require__(/*! ./unsupportedIterableToArray.js */ 74098);

function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

  if (!it) {
    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function F() {};

      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

module.exports = _createForOfIteratorHelper, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 74098:
/*!***************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js ***!
  \***************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(/*! ./arrayLikeToArray.js */ 86315);

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}

module.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 28305:
/*!**************************************************************!*\
  !*** ./node_modules/@angular/compiler/fesm2015/compiler.mjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AST": function() { return /* binding */ AST; },
/* harmony export */   "ASTWithName": function() { return /* binding */ ASTWithName; },
/* harmony export */   "ASTWithSource": function() { return /* binding */ ASTWithSource; },
/* harmony export */   "AbsoluteSourceSpan": function() { return /* binding */ AbsoluteSourceSpan; },
/* harmony export */   "ArrayType": function() { return /* binding */ ArrayType; },
/* harmony export */   "AstMemoryEfficientTransformer": function() { return /* binding */ AstMemoryEfficientTransformer; },
/* harmony export */   "AstTransformer": function() { return /* binding */ AstTransformer; },
/* harmony export */   "Attribute": function() { return /* binding */ Attribute; },
/* harmony export */   "Binary": function() { return /* binding */ Binary; },
/* harmony export */   "BinaryOperator": function() { return /* binding */ BinaryOperator; },
/* harmony export */   "BinaryOperatorExpr": function() { return /* binding */ BinaryOperatorExpr; },
/* harmony export */   "BindingPipe": function() { return /* binding */ BindingPipe; },
/* harmony export */   "BoundElementProperty": function() { return /* binding */ BoundElementProperty; },
/* harmony export */   "BuiltinType": function() { return /* binding */ BuiltinType; },
/* harmony export */   "BuiltinTypeName": function() { return /* binding */ BuiltinTypeName; },
/* harmony export */   "CUSTOM_ELEMENTS_SCHEMA": function() { return /* binding */ CUSTOM_ELEMENTS_SCHEMA; },
/* harmony export */   "Call": function() { return /* binding */ Call; },
/* harmony export */   "Chain": function() { return /* binding */ Chain; },
/* harmony export */   "ChangeDetectionStrategy": function() { return /* binding */ ChangeDetectionStrategy; },
/* harmony export */   "CommaExpr": function() { return /* binding */ CommaExpr; },
/* harmony export */   "Comment": function() { return /* binding */ Comment; },
/* harmony export */   "CompilerConfig": function() { return /* binding */ CompilerConfig; },
/* harmony export */   "Conditional": function() { return /* binding */ Conditional; },
/* harmony export */   "ConditionalExpr": function() { return /* binding */ ConditionalExpr; },
/* harmony export */   "ConstantPool": function() { return /* binding */ ConstantPool; },
/* harmony export */   "CssSelector": function() { return /* binding */ CssSelector; },
/* harmony export */   "DEFAULT_INTERPOLATION_CONFIG": function() { return /* binding */ DEFAULT_INTERPOLATION_CONFIG; },
/* harmony export */   "DYNAMIC_TYPE": function() { return /* binding */ DYNAMIC_TYPE; },
/* harmony export */   "DeclareFunctionStmt": function() { return /* binding */ DeclareFunctionStmt; },
/* harmony export */   "DeclareVarStmt": function() { return /* binding */ DeclareVarStmt; },
/* harmony export */   "DomElementSchemaRegistry": function() { return /* binding */ DomElementSchemaRegistry; },
/* harmony export */   "EOF": function() { return /* binding */ EOF; },
/* harmony export */   "Element": function() { return /* binding */ Element; },
/* harmony export */   "ElementSchemaRegistry": function() { return /* binding */ ElementSchemaRegistry; },
/* harmony export */   "EmitterVisitorContext": function() { return /* binding */ EmitterVisitorContext; },
/* harmony export */   "EmptyExpr": function() { return /* binding */ EmptyExpr; },
/* harmony export */   "Expansion": function() { return /* binding */ Expansion; },
/* harmony export */   "ExpansionCase": function() { return /* binding */ ExpansionCase; },
/* harmony export */   "Expression": function() { return /* binding */ Expression; },
/* harmony export */   "ExpressionBinding": function() { return /* binding */ ExpressionBinding; },
/* harmony export */   "ExpressionStatement": function() { return /* binding */ ExpressionStatement; },
/* harmony export */   "ExpressionType": function() { return /* binding */ ExpressionType; },
/* harmony export */   "ExternalExpr": function() { return /* binding */ ExternalExpr; },
/* harmony export */   "ExternalReference": function() { return /* binding */ ExternalReference; },
/* harmony export */   "FactoryTarget": function() { return /* binding */ FactoryTarget$1; },
/* harmony export */   "FunctionExpr": function() { return /* binding */ FunctionExpr; },
/* harmony export */   "HtmlParser": function() { return /* binding */ HtmlParser; },
/* harmony export */   "HtmlTagDefinition": function() { return /* binding */ HtmlTagDefinition; },
/* harmony export */   "I18NHtmlParser": function() { return /* binding */ I18NHtmlParser; },
/* harmony export */   "IfStmt": function() { return /* binding */ IfStmt; },
/* harmony export */   "ImplicitReceiver": function() { return /* binding */ ImplicitReceiver; },
/* harmony export */   "InstantiateExpr": function() { return /* binding */ InstantiateExpr; },
/* harmony export */   "Interpolation": function() { return /* binding */ Interpolation; },
/* harmony export */   "InterpolationConfig": function() { return /* binding */ InterpolationConfig; },
/* harmony export */   "InvokeFunctionExpr": function() { return /* binding */ InvokeFunctionExpr; },
/* harmony export */   "JSDocComment": function() { return /* binding */ JSDocComment; },
/* harmony export */   "JitEvaluator": function() { return /* binding */ JitEvaluator; },
/* harmony export */   "KeyedRead": function() { return /* binding */ KeyedRead; },
/* harmony export */   "KeyedWrite": function() { return /* binding */ KeyedWrite; },
/* harmony export */   "LeadingComment": function() { return /* binding */ LeadingComment; },
/* harmony export */   "Lexer": function() { return /* binding */ Lexer; },
/* harmony export */   "LiteralArray": function() { return /* binding */ LiteralArray; },
/* harmony export */   "LiteralArrayExpr": function() { return /* binding */ LiteralArrayExpr; },
/* harmony export */   "LiteralExpr": function() { return /* binding */ LiteralExpr; },
/* harmony export */   "LiteralMap": function() { return /* binding */ LiteralMap; },
/* harmony export */   "LiteralMapExpr": function() { return /* binding */ LiteralMapExpr; },
/* harmony export */   "LiteralPrimitive": function() { return /* binding */ LiteralPrimitive; },
/* harmony export */   "LocalizedString": function() { return /* binding */ LocalizedString; },
/* harmony export */   "MapType": function() { return /* binding */ MapType; },
/* harmony export */   "MessageBundle": function() { return /* binding */ MessageBundle; },
/* harmony export */   "NONE_TYPE": function() { return /* binding */ NONE_TYPE; },
/* harmony export */   "NO_ERRORS_SCHEMA": function() { return /* binding */ NO_ERRORS_SCHEMA; },
/* harmony export */   "NodeWithI18n": function() { return /* binding */ NodeWithI18n; },
/* harmony export */   "NonNullAssert": function() { return /* binding */ NonNullAssert; },
/* harmony export */   "NotExpr": function() { return /* binding */ NotExpr; },
/* harmony export */   "ParseError": function() { return /* binding */ ParseError; },
/* harmony export */   "ParseErrorLevel": function() { return /* binding */ ParseErrorLevel; },
/* harmony export */   "ParseLocation": function() { return /* binding */ ParseLocation; },
/* harmony export */   "ParseSourceFile": function() { return /* binding */ ParseSourceFile; },
/* harmony export */   "ParseSourceSpan": function() { return /* binding */ ParseSourceSpan; },
/* harmony export */   "ParseSpan": function() { return /* binding */ ParseSpan; },
/* harmony export */   "ParseTreeResult": function() { return /* binding */ ParseTreeResult; },
/* harmony export */   "ParsedEvent": function() { return /* binding */ ParsedEvent; },
/* harmony export */   "ParsedProperty": function() { return /* binding */ ParsedProperty; },
/* harmony export */   "ParsedPropertyType": function() { return /* binding */ ParsedPropertyType; },
/* harmony export */   "ParsedVariable": function() { return /* binding */ ParsedVariable; },
/* harmony export */   "Parser": function() { return /* binding */ Parser$1; },
/* harmony export */   "ParserError": function() { return /* binding */ ParserError; },
/* harmony export */   "PrefixNot": function() { return /* binding */ PrefixNot; },
/* harmony export */   "PropertyRead": function() { return /* binding */ PropertyRead; },
/* harmony export */   "PropertyWrite": function() { return /* binding */ PropertyWrite; },
/* harmony export */   "R3BoundTarget": function() { return /* binding */ R3BoundTarget; },
/* harmony export */   "R3Identifiers": function() { return /* binding */ Identifiers; },
/* harmony export */   "R3SelectorScopeMode": function() { return /* binding */ R3SelectorScopeMode; },
/* harmony export */   "R3TargetBinder": function() { return /* binding */ R3TargetBinder; },
/* harmony export */   "R3TemplateDependencyKind": function() { return /* binding */ R3TemplateDependencyKind; },
/* harmony export */   "ReadKeyExpr": function() { return /* binding */ ReadKeyExpr; },
/* harmony export */   "ReadPropExpr": function() { return /* binding */ ReadPropExpr; },
/* harmony export */   "ReadVarExpr": function() { return /* binding */ ReadVarExpr; },
/* harmony export */   "RecursiveAstVisitor": function() { return /* binding */ RecursiveAstVisitor; },
/* harmony export */   "RecursiveVisitor": function() { return /* binding */ RecursiveVisitor; },
/* harmony export */   "ResourceLoader": function() { return /* binding */ ResourceLoader; },
/* harmony export */   "ReturnStatement": function() { return /* binding */ ReturnStatement; },
/* harmony export */   "STRING_TYPE": function() { return /* binding */ STRING_TYPE; },
/* harmony export */   "SafeCall": function() { return /* binding */ SafeCall; },
/* harmony export */   "SafeKeyedRead": function() { return /* binding */ SafeKeyedRead; },
/* harmony export */   "SafePropertyRead": function() { return /* binding */ SafePropertyRead; },
/* harmony export */   "SelectorContext": function() { return /* binding */ SelectorContext; },
/* harmony export */   "SelectorListContext": function() { return /* binding */ SelectorListContext; },
/* harmony export */   "SelectorMatcher": function() { return /* binding */ SelectorMatcher; },
/* harmony export */   "Serializer": function() { return /* binding */ Serializer; },
/* harmony export */   "SplitInterpolation": function() { return /* binding */ SplitInterpolation; },
/* harmony export */   "Statement": function() { return /* binding */ Statement; },
/* harmony export */   "StmtModifier": function() { return /* binding */ StmtModifier; },
/* harmony export */   "TagContentType": function() { return /* binding */ TagContentType; },
/* harmony export */   "TaggedTemplateExpr": function() { return /* binding */ TaggedTemplateExpr; },
/* harmony export */   "TemplateBindingParseResult": function() { return /* binding */ TemplateBindingParseResult; },
/* harmony export */   "TemplateLiteral": function() { return /* binding */ TemplateLiteral; },
/* harmony export */   "TemplateLiteralElement": function() { return /* binding */ TemplateLiteralElement; },
/* harmony export */   "Text": function() { return /* binding */ Text; },
/* harmony export */   "ThisReceiver": function() { return /* binding */ ThisReceiver; },
/* harmony export */   "TmplAstBoundAttribute": function() { return /* binding */ BoundAttribute; },
/* harmony export */   "TmplAstBoundEvent": function() { return /* binding */ BoundEvent; },
/* harmony export */   "TmplAstBoundText": function() { return /* binding */ BoundText; },
/* harmony export */   "TmplAstContent": function() { return /* binding */ Content; },
/* harmony export */   "TmplAstElement": function() { return /* binding */ Element$1; },
/* harmony export */   "TmplAstIcu": function() { return /* binding */ Icu$1; },
/* harmony export */   "TmplAstRecursiveVisitor": function() { return /* binding */ RecursiveVisitor$1; },
/* harmony export */   "TmplAstReference": function() { return /* binding */ Reference; },
/* harmony export */   "TmplAstTemplate": function() { return /* binding */ Template; },
/* harmony export */   "TmplAstText": function() { return /* binding */ Text$3; },
/* harmony export */   "TmplAstTextAttribute": function() { return /* binding */ TextAttribute; },
/* harmony export */   "TmplAstVariable": function() { return /* binding */ Variable; },
/* harmony export */   "Token": function() { return /* binding */ Token; },
/* harmony export */   "TokenType": function() { return /* binding */ TokenType; },
/* harmony export */   "TreeError": function() { return /* binding */ TreeError; },
/* harmony export */   "Type": function() { return /* binding */ Type; },
/* harmony export */   "TypeModifier": function() { return /* binding */ TypeModifier; },
/* harmony export */   "TypeofExpr": function() { return /* binding */ TypeofExpr; },
/* harmony export */   "Unary": function() { return /* binding */ Unary; },
/* harmony export */   "UnaryOperator": function() { return /* binding */ UnaryOperator; },
/* harmony export */   "UnaryOperatorExpr": function() { return /* binding */ UnaryOperatorExpr; },
/* harmony export */   "VERSION": function() { return /* binding */ VERSION; },
/* harmony export */   "VariableBinding": function() { return /* binding */ VariableBinding; },
/* harmony export */   "Version": function() { return /* binding */ Version; },
/* harmony export */   "ViewEncapsulation": function() { return /* binding */ ViewEncapsulation; },
/* harmony export */   "WrappedNodeExpr": function() { return /* binding */ WrappedNodeExpr; },
/* harmony export */   "WriteKeyExpr": function() { return /* binding */ WriteKeyExpr; },
/* harmony export */   "WritePropExpr": function() { return /* binding */ WritePropExpr; },
/* harmony export */   "WriteVarExpr": function() { return /* binding */ WriteVarExpr; },
/* harmony export */   "Xliff": function() { return /* binding */ Xliff; },
/* harmony export */   "Xliff2": function() { return /* binding */ Xliff2; },
/* harmony export */   "Xmb": function() { return /* binding */ Xmb; },
/* harmony export */   "XmlParser": function() { return /* binding */ XmlParser; },
/* harmony export */   "Xtb": function() { return /* binding */ Xtb; },
/* harmony export */   "_ParseAST": function() { return /* binding */ _ParseAST; },
/* harmony export */   "compileClassMetadata": function() { return /* binding */ compileClassMetadata; },
/* harmony export */   "compileComponentFromMetadata": function() { return /* binding */ compileComponentFromMetadata; },
/* harmony export */   "compileDeclareClassMetadata": function() { return /* binding */ compileDeclareClassMetadata; },
/* harmony export */   "compileDeclareComponentFromMetadata": function() { return /* binding */ compileDeclareComponentFromMetadata; },
/* harmony export */   "compileDeclareDirectiveFromMetadata": function() { return /* binding */ compileDeclareDirectiveFromMetadata; },
/* harmony export */   "compileDeclareFactoryFunction": function() { return /* binding */ compileDeclareFactoryFunction; },
/* harmony export */   "compileDeclareInjectableFromMetadata": function() { return /* binding */ compileDeclareInjectableFromMetadata; },
/* harmony export */   "compileDeclareInjectorFromMetadata": function() { return /* binding */ compileDeclareInjectorFromMetadata; },
/* harmony export */   "compileDeclareNgModuleFromMetadata": function() { return /* binding */ compileDeclareNgModuleFromMetadata; },
/* harmony export */   "compileDeclarePipeFromMetadata": function() { return /* binding */ compileDeclarePipeFromMetadata; },
/* harmony export */   "compileDirectiveFromMetadata": function() { return /* binding */ compileDirectiveFromMetadata; },
/* harmony export */   "compileFactoryFunction": function() { return /* binding */ compileFactoryFunction; },
/* harmony export */   "compileInjectable": function() { return /* binding */ _compileInjectable; },
/* harmony export */   "compileInjector": function() { return /* binding */ _compileInjector; },
/* harmony export */   "compileNgModule": function() { return /* binding */ _compileNgModule; },
/* harmony export */   "compilePipeFromMetadata": function() { return /* binding */ compilePipeFromMetadata; },
/* harmony export */   "computeMsgId": function() { return /* binding */ computeMsgId; },
/* harmony export */   "core": function() { return /* binding */ core; },
/* harmony export */   "createInjectableType": function() { return /* binding */ createInjectableType; },
/* harmony export */   "createMayBeForwardRefExpression": function() { return /* binding */ createMayBeForwardRefExpression; },
/* harmony export */   "devOnlyGuardedExpression": function() { return /* binding */ devOnlyGuardedExpression; },
/* harmony export */   "emitDistinctChangesOnlyDefaultValue": function() { return /* binding */ emitDistinctChangesOnlyDefaultValue; },
/* harmony export */   "getHtmlTagDefinition": function() { return /* binding */ getHtmlTagDefinition; },
/* harmony export */   "getNsPrefix": function() { return /* binding */ getNsPrefix; },
/* harmony export */   "getSafePropertyAccessString": function() { return /* binding */ getSafePropertyAccessString; },
/* harmony export */   "identifierName": function() { return /* binding */ identifierName; },
/* harmony export */   "isIdentifier": function() { return /* binding */ isIdentifier; },
/* harmony export */   "isNgContainer": function() { return /* binding */ isNgContainer; },
/* harmony export */   "isNgContent": function() { return /* binding */ isNgContent; },
/* harmony export */   "isNgTemplate": function() { return /* binding */ isNgTemplate; },
/* harmony export */   "jsDocComment": function() { return /* binding */ jsDocComment; },
/* harmony export */   "leadingComment": function() { return /* binding */ leadingComment; },
/* harmony export */   "literalMap": function() { return /* binding */ literalMap; },
/* harmony export */   "makeBindingParser": function() { return /* binding */ makeBindingParser; },
/* harmony export */   "mergeNsAndName": function() { return /* binding */ mergeNsAndName; },
/* harmony export */   "outputAst": function() { return /* binding */ output_ast; },
/* harmony export */   "parseHostBindings": function() { return /* binding */ parseHostBindings; },
/* harmony export */   "parseTemplate": function() { return /* binding */ parseTemplate; },
/* harmony export */   "preserveWhitespacesDefault": function() { return /* binding */ preserveWhitespacesDefault; },
/* harmony export */   "publishFacade": function() { return /* binding */ publishFacade; },
/* harmony export */   "r3JitTypeSourceSpan": function() { return /* binding */ r3JitTypeSourceSpan; },
/* harmony export */   "sanitizeIdentifier": function() { return /* binding */ sanitizeIdentifier; },
/* harmony export */   "splitNsName": function() { return /* binding */ splitNsName; },
/* harmony export */   "verifyHostBindings": function() { return /* binding */ verifyHostBindings; },
/* harmony export */   "visitAll": function() { return /* binding */ visitAll; }
/* harmony export */ });
/* harmony import */ var _Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_possibleConstructorReturn_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js */ 8633);
/* harmony import */ var _Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/toArray.js */ 60609);
/* harmony import */ var _Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_construct_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/construct.js */ 32162);
/* harmony import */ var _Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_slicedToArray_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/slicedToArray.js */ 10507);
/* harmony import */ var _Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_assertThisInitialized_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js */ 35488);
/* harmony import */ var _Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/get.js */ 64756);
/* harmony import */ var _Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js */ 20265);
/* harmony import */ var _Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/inherits.js */ 24582);
/* harmony import */ var _Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/createSuper.js */ 2496);
/* harmony import */ var _Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js */ 95106);
/* harmony import */ var _Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js */ 58277);
/* harmony import */ var _Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js */ 78069);
/* harmony import */ var _Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/createClass.js */ 48047);














function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

/**
 * @license Angular v14.0.2
 * (c) 2010-2022 Google LLC. https://angular.io/
 * License: MIT
 */

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var TagContentType;

(function (TagContentType) {
  TagContentType[TagContentType["RAW_TEXT"] = 0] = "RAW_TEXT";
  TagContentType[TagContentType["ESCAPABLE_RAW_TEXT"] = 1] = "ESCAPABLE_RAW_TEXT";
  TagContentType[TagContentType["PARSABLE_DATA"] = 2] = "PARSABLE_DATA";
})(TagContentType || (TagContentType = {}));

function splitNsName(elementName) {
  if (elementName[0] != ':') {
    return [null, elementName];
  }

  var colonIndex = elementName.indexOf(':', 1);

  if (colonIndex === -1) {
    throw new Error("Unsupported format \"".concat(elementName, "\" expecting \":namespace:name\""));
  }

  return [elementName.slice(1, colonIndex), elementName.slice(colonIndex + 1)];
} // `<ng-container>` tags work the same regardless the namespace


function isNgContainer(tagName) {
  return splitNsName(tagName)[1] === 'ng-container';
} // `<ng-content>` tags work the same regardless the namespace


function isNgContent(tagName) {
  return splitNsName(tagName)[1] === 'ng-content';
} // `<ng-template>` tags work the same regardless the namespace


function isNgTemplate(tagName) {
  return splitNsName(tagName)[1] === 'ng-template';
}

function getNsPrefix(fullName) {
  return fullName === null ? null : splitNsName(fullName)[0];
}

function mergeNsAndName(prefix, localName) {
  return prefix ? ":".concat(prefix, ":").concat(localName) : localName;
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */


var HtmlTagDefinition = /*#__PURE__*/function () {
  function HtmlTagDefinition() {
    var _this = this;

    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        closedByChildren = _ref2.closedByChildren,
        implicitNamespacePrefix = _ref2.implicitNamespacePrefix,
        _ref2$contentType = _ref2.contentType,
        contentType = _ref2$contentType === void 0 ? TagContentType.PARSABLE_DATA : _ref2$contentType,
        _ref2$closedByParent = _ref2.closedByParent,
        closedByParent = _ref2$closedByParent === void 0 ? false : _ref2$closedByParent,
        _ref2$isVoid = _ref2.isVoid,
        isVoid = _ref2$isVoid === void 0 ? false : _ref2$isVoid,
        _ref2$ignoreFirstLf = _ref2.ignoreFirstLf,
        ignoreFirstLf = _ref2$ignoreFirstLf === void 0 ? false : _ref2$ignoreFirstLf,
        _ref2$preventNamespac = _ref2.preventNamespaceInheritance,
        preventNamespaceInheritance = _ref2$preventNamespac === void 0 ? false : _ref2$preventNamespac;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, HtmlTagDefinition);

    this.closedByChildren = {};
    this.closedByParent = false;
    this.canSelfClose = false;

    if (closedByChildren && closedByChildren.length > 0) {
      closedByChildren.forEach(function (tagName) {
        return _this.closedByChildren[tagName] = true;
      });
    }

    this.isVoid = isVoid;
    this.closedByParent = closedByParent || isVoid;
    this.implicitNamespacePrefix = implicitNamespacePrefix || null;
    this.contentType = contentType;
    this.ignoreFirstLf = ignoreFirstLf;
    this.preventNamespaceInheritance = preventNamespaceInheritance;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(HtmlTagDefinition, [{
    key: "isClosedByChild",
    value: function isClosedByChild(name) {
      return this.isVoid || name.toLowerCase() in this.closedByChildren;
    }
  }, {
    key: "getContentType",
    value: function getContentType(prefix) {
      if (typeof this.contentType === 'object') {
        var overrideType = prefix === undefined ? undefined : this.contentType[prefix];
        return overrideType !== null && overrideType !== void 0 ? overrideType : this.contentType.default;
      }

      return this.contentType;
    }
  }]);

  return HtmlTagDefinition;
}();

var _DEFAULT_TAG_DEFINITION; // see https://www.w3.org/TR/html51/syntax.html#optional-tags
// This implementation does not fully conform to the HTML5 spec.


var TAG_DEFINITIONS;

function getHtmlTagDefinition(tagName) {
  var _a, _b;

  if (!TAG_DEFINITIONS) {
    _DEFAULT_TAG_DEFINITION = new HtmlTagDefinition();
    TAG_DEFINITIONS = {
      'base': new HtmlTagDefinition({
        isVoid: true
      }),
      'meta': new HtmlTagDefinition({
        isVoid: true
      }),
      'area': new HtmlTagDefinition({
        isVoid: true
      }),
      'embed': new HtmlTagDefinition({
        isVoid: true
      }),
      'link': new HtmlTagDefinition({
        isVoid: true
      }),
      'img': new HtmlTagDefinition({
        isVoid: true
      }),
      'input': new HtmlTagDefinition({
        isVoid: true
      }),
      'param': new HtmlTagDefinition({
        isVoid: true
      }),
      'hr': new HtmlTagDefinition({
        isVoid: true
      }),
      'br': new HtmlTagDefinition({
        isVoid: true
      }),
      'source': new HtmlTagDefinition({
        isVoid: true
      }),
      'track': new HtmlTagDefinition({
        isVoid: true
      }),
      'wbr': new HtmlTagDefinition({
        isVoid: true
      }),
      'p': new HtmlTagDefinition({
        closedByChildren: ['address', 'article', 'aside', 'blockquote', 'div', 'dl', 'fieldset', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hgroup', 'hr', 'main', 'nav', 'ol', 'p', 'pre', 'section', 'table', 'ul'],
        closedByParent: true
      }),
      'thead': new HtmlTagDefinition({
        closedByChildren: ['tbody', 'tfoot']
      }),
      'tbody': new HtmlTagDefinition({
        closedByChildren: ['tbody', 'tfoot'],
        closedByParent: true
      }),
      'tfoot': new HtmlTagDefinition({
        closedByChildren: ['tbody'],
        closedByParent: true
      }),
      'tr': new HtmlTagDefinition({
        closedByChildren: ['tr'],
        closedByParent: true
      }),
      'td': new HtmlTagDefinition({
        closedByChildren: ['td', 'th'],
        closedByParent: true
      }),
      'th': new HtmlTagDefinition({
        closedByChildren: ['td', 'th'],
        closedByParent: true
      }),
      'col': new HtmlTagDefinition({
        isVoid: true
      }),
      'svg': new HtmlTagDefinition({
        implicitNamespacePrefix: 'svg'
      }),
      'foreignObject': new HtmlTagDefinition({
        // Usually the implicit namespace here would be redundant since it will be inherited from
        // the parent `svg`, but we have to do it for `foreignObject`, because the way the parser
        // works is that the parent node of an end tag is its own start tag which means that
        // the `preventNamespaceInheritance` on `foreignObject` would have it default to the
        // implicit namespace which is `html`, unless specified otherwise.
        implicitNamespacePrefix: 'svg',
        // We want to prevent children of foreignObject from inheriting its namespace, because
        // the point of the element is to allow nodes from other namespaces to be inserted.
        preventNamespaceInheritance: true
      }),
      'math': new HtmlTagDefinition({
        implicitNamespacePrefix: 'math'
      }),
      'li': new HtmlTagDefinition({
        closedByChildren: ['li'],
        closedByParent: true
      }),
      'dt': new HtmlTagDefinition({
        closedByChildren: ['dt', 'dd']
      }),
      'dd': new HtmlTagDefinition({
        closedByChildren: ['dt', 'dd'],
        closedByParent: true
      }),
      'rb': new HtmlTagDefinition({
        closedByChildren: ['rb', 'rt', 'rtc', 'rp'],
        closedByParent: true
      }),
      'rt': new HtmlTagDefinition({
        closedByChildren: ['rb', 'rt', 'rtc', 'rp'],
        closedByParent: true
      }),
      'rtc': new HtmlTagDefinition({
        closedByChildren: ['rb', 'rtc', 'rp'],
        closedByParent: true
      }),
      'rp': new HtmlTagDefinition({
        closedByChildren: ['rb', 'rt', 'rtc', 'rp'],
        closedByParent: true
      }),
      'optgroup': new HtmlTagDefinition({
        closedByChildren: ['optgroup'],
        closedByParent: true
      }),
      'option': new HtmlTagDefinition({
        closedByChildren: ['option', 'optgroup'],
        closedByParent: true
      }),
      'pre': new HtmlTagDefinition({
        ignoreFirstLf: true
      }),
      'listing': new HtmlTagDefinition({
        ignoreFirstLf: true
      }),
      'style': new HtmlTagDefinition({
        contentType: TagContentType.RAW_TEXT
      }),
      'script': new HtmlTagDefinition({
        contentType: TagContentType.RAW_TEXT
      }),
      'title': new HtmlTagDefinition({
        // The browser supports two separate `title` tags which have to use
        // a different content type: `HTMLTitleElement` and `SVGTitleElement`
        contentType: {
          default: TagContentType.ESCAPABLE_RAW_TEXT,
          svg: TagContentType.PARSABLE_DATA
        }
      }),
      'textarea': new HtmlTagDefinition({
        contentType: TagContentType.ESCAPABLE_RAW_TEXT,
        ignoreFirstLf: true
      })
    };
  } // We have to make both a case-sensitive and a case-insensitive lookup, because
  // HTML tag names are case insensitive, whereas some SVG tags are case sensitive.


  return (_b = (_a = TAG_DEFINITIONS[tagName]) !== null && _a !== void 0 ? _a : TAG_DEFINITIONS[tagName.toLowerCase()]) !== null && _b !== void 0 ? _b : _DEFAULT_TAG_DEFINITION;
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */


var _SELECTOR_REGEXP = new RegExp('(\\:not\\()|' + // 1: ":not("
'(([\\.\\#]?)[-\\w]+)|' + // 2: "tag"; 3: "."/"#";
// "-" should appear first in the regexp below as FF31 parses "[.-\w]" as a range
// 4: attribute; 5: attribute_string; 6: attribute_value
'(?:\\[([-.\\w*\\\\$]+)(?:=([\"\']?)([^\\]\"\']*)\\5)?\\])|' + // "[name]", "[name=value]",
// "[name="value"]",
// "[name='value']"
'(\\))|' + // 7: ")"
'(\\s*,\\s*)', // 8: ","
'g');
/**
 * A css selector contains an element name,
 * css classes and attribute/value pairs with the purpose
 * of selecting subsets out of them.
 */


var CssSelector = /*#__PURE__*/function () {
  function CssSelector() {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, CssSelector);

    this.element = null;
    this.classNames = [];
    /**
     * The selectors are encoded in pairs where:
     * - even locations are attribute names
     * - odd locations are attribute values.
     *
     * Example:
     * Selector: `[key1=value1][key2]` would parse to:
     * ```
     * ['key1', 'value1', 'key2', '']
     * ```
     */

    this.attrs = [];
    this.notSelectors = [];
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(CssSelector, [{
    key: "unescapeAttribute",
    value:
    /**
     * Unescape `\$` sequences from the CSS attribute selector.
     *
     * This is needed because `$` can have a special meaning in CSS selectors,
     * but we might want to match an attribute that contains `$`.
     * [MDN web link for more
     * info](https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors).
     * @param attr the attribute to unescape.
     * @returns the unescaped string.
     */
    function unescapeAttribute(attr) {
      var result = '';
      var escaping = false;

      for (var i = 0; i < attr.length; i++) {
        var char = attr.charAt(i);

        if (char === '\\') {
          escaping = true;
          continue;
        }

        if (char === '$' && !escaping) {
          throw new Error("Error in attribute selector \"".concat(attr, "\". ") + "Unescaped \"$\" is not supported. Please escape with \"\\$\".");
        }

        escaping = false;
        result += char;
      }

      return result;
    }
    /**
     * Escape `$` sequences from the CSS attribute selector.
     *
     * This is needed because `$` can have a special meaning in CSS selectors,
     * with this method we are escaping `$` with `\$'.
     * [MDN web link for more
     * info](https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors).
     * @param attr the attribute to escape.
     * @returns the escaped string.
     */

  }, {
    key: "escapeAttribute",
    value: function escapeAttribute(attr) {
      return attr.replace(/\\/g, '\\\\').replace(/\$/g, '\\$');
    }
  }, {
    key: "isElementSelector",
    value: function isElementSelector() {
      return this.hasElementSelector() && this.classNames.length == 0 && this.attrs.length == 0 && this.notSelectors.length === 0;
    }
  }, {
    key: "hasElementSelector",
    value: function hasElementSelector() {
      return !!this.element;
    }
  }, {
    key: "setElement",
    value: function setElement() {
      var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      this.element = element;
    }
    /** Gets a template string for an element that matches the selector. */

  }, {
    key: "getMatchingElementTemplate",
    value: function getMatchingElementTemplate() {
      var tagName = this.element || 'div';
      var classAttr = this.classNames.length > 0 ? " class=\"".concat(this.classNames.join(' '), "\"") : '';
      var attrs = '';

      for (var i = 0; i < this.attrs.length; i += 2) {
        var attrName = this.attrs[i];
        var attrValue = this.attrs[i + 1] !== '' ? "=\"".concat(this.attrs[i + 1], "\"") : '';
        attrs += " ".concat(attrName).concat(attrValue);
      }

      return getHtmlTagDefinition(tagName).isVoid ? "<".concat(tagName).concat(classAttr).concat(attrs, "/>") : "<".concat(tagName).concat(classAttr).concat(attrs, "></").concat(tagName, ">");
    }
  }, {
    key: "getAttrs",
    value: function getAttrs() {
      var result = [];

      if (this.classNames.length > 0) {
        result.push('class', this.classNames.join(' '));
      }

      return result.concat(this.attrs);
    }
  }, {
    key: "addAttribute",
    value: function addAttribute(name) {
      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      this.attrs.push(name, value && value.toLowerCase() || '');
    }
  }, {
    key: "addClassName",
    value: function addClassName(name) {
      this.classNames.push(name.toLowerCase());
    }
  }, {
    key: "toString",
    value: function toString() {
      var res = this.element || '';

      if (this.classNames) {
        this.classNames.forEach(function (klass) {
          return res += ".".concat(klass);
        });
      }

      if (this.attrs) {
        for (var i = 0; i < this.attrs.length; i += 2) {
          var name = this.escapeAttribute(this.attrs[i]);
          var value = this.attrs[i + 1];
          res += "[".concat(name).concat(value ? '=' + value : '', "]");
        }
      }

      this.notSelectors.forEach(function (notSelector) {
        return res += ":not(".concat(notSelector, ")");
      });
      return res;
    }
  }], [{
    key: "parse",
    value: function parse(selector) {
      var results = [];

      var _addResult = function _addResult(res, cssSel) {
        if (cssSel.notSelectors.length > 0 && !cssSel.element && cssSel.classNames.length == 0 && cssSel.attrs.length == 0) {
          cssSel.element = '*';
        }

        res.push(cssSel);
      };

      var cssSelector = new CssSelector();
      var match;
      var current = cssSelector;
      var inNot = false;
      _SELECTOR_REGEXP.lastIndex = 0;

      while (match = _SELECTOR_REGEXP.exec(selector)) {
        if (match[1
        /* SelectorRegexp.NOT */
        ]) {
          if (inNot) {
            throw new Error('Nesting :not in a selector is not allowed');
          }

          inNot = true;
          current = new CssSelector();
          cssSelector.notSelectors.push(current);
        }

        var tag = match[2
        /* SelectorRegexp.TAG */
        ];

        if (tag) {
          var prefix = match[3
          /* SelectorRegexp.PREFIX */
          ];

          if (prefix === '#') {
            // #hash
            current.addAttribute('id', tag.slice(1));
          } else if (prefix === '.') {
            // Class
            current.addClassName(tag.slice(1));
          } else {
            // Element
            current.setElement(tag);
          }
        }

        var attribute = match[4
        /* SelectorRegexp.ATTRIBUTE */
        ];

        if (attribute) {
          current.addAttribute(current.unescapeAttribute(attribute), match[6
          /* SelectorRegexp.ATTRIBUTE_VALUE */
          ]);
        }

        if (match[7
        /* SelectorRegexp.NOT_END */
        ]) {
          inNot = false;
          current = cssSelector;
        }

        if (match[8
        /* SelectorRegexp.SEPARATOR */
        ]) {
          if (inNot) {
            throw new Error('Multiple selectors in :not are not supported');
          }

          _addResult(results, cssSelector);

          cssSelector = current = new CssSelector();
        }
      }

      _addResult(results, cssSelector);

      return results;
    }
  }]);

  return CssSelector;
}();
/**
 * Reads a list of CssSelectors and allows to calculate which ones
 * are contained in a given CssSelector.
 */


var SelectorMatcher = /*#__PURE__*/function () {
  function SelectorMatcher() {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, SelectorMatcher);

    this._elementMap = new Map();
    this._elementPartialMap = new Map();
    this._classMap = new Map();
    this._classPartialMap = new Map();
    this._attrValueMap = new Map();
    this._attrValuePartialMap = new Map();
    this._listContexts = [];
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(SelectorMatcher, [{
    key: "addSelectables",
    value: function addSelectables(cssSelectors, callbackCtxt) {
      var listContext = null;

      if (cssSelectors.length > 1) {
        listContext = new SelectorListContext(cssSelectors);

        this._listContexts.push(listContext);
      }

      for (var i = 0; i < cssSelectors.length; i++) {
        this._addSelectable(cssSelectors[i], callbackCtxt, listContext);
      }
    }
    /**
     * Add an object that can be found later on by calling `match`.
     * @param cssSelector A css selector
     * @param callbackCtxt An opaque object that will be given to the callback of the `match` function
     */

  }, {
    key: "_addSelectable",
    value: function _addSelectable(cssSelector, callbackCtxt, listContext) {
      var matcher = this;
      var element = cssSelector.element;
      var classNames = cssSelector.classNames;
      var attrs = cssSelector.attrs;
      var selectable = new SelectorContext(cssSelector, callbackCtxt, listContext);

      if (element) {
        var isTerminal = attrs.length === 0 && classNames.length === 0;

        if (isTerminal) {
          this._addTerminal(matcher._elementMap, element, selectable);
        } else {
          matcher = this._addPartial(matcher._elementPartialMap, element);
        }
      }

      if (classNames) {
        for (var i = 0; i < classNames.length; i++) {
          var _isTerminal = attrs.length === 0 && i === classNames.length - 1;

          var className = classNames[i];

          if (_isTerminal) {
            this._addTerminal(matcher._classMap, className, selectable);
          } else {
            matcher = this._addPartial(matcher._classPartialMap, className);
          }
        }
      }

      if (attrs) {
        for (var _i = 0; _i < attrs.length; _i += 2) {
          var _isTerminal2 = _i === attrs.length - 2;

          var name = attrs[_i];
          var value = attrs[_i + 1];

          if (_isTerminal2) {
            var terminalMap = matcher._attrValueMap;
            var terminalValuesMap = terminalMap.get(name);

            if (!terminalValuesMap) {
              terminalValuesMap = new Map();
              terminalMap.set(name, terminalValuesMap);
            }

            this._addTerminal(terminalValuesMap, value, selectable);
          } else {
            var partialMap = matcher._attrValuePartialMap;
            var partialValuesMap = partialMap.get(name);

            if (!partialValuesMap) {
              partialValuesMap = new Map();
              partialMap.set(name, partialValuesMap);
            }

            matcher = this._addPartial(partialValuesMap, value);
          }
        }
      }
    }
  }, {
    key: "_addTerminal",
    value: function _addTerminal(map, name, selectable) {
      var terminalList = map.get(name);

      if (!terminalList) {
        terminalList = [];
        map.set(name, terminalList);
      }

      terminalList.push(selectable);
    }
  }, {
    key: "_addPartial",
    value: function _addPartial(map, name) {
      var matcher = map.get(name);

      if (!matcher) {
        matcher = new SelectorMatcher();
        map.set(name, matcher);
      }

      return matcher;
    }
    /**
     * Find the objects that have been added via `addSelectable`
     * whose css selector is contained in the given css selector.
     * @param cssSelector A css selector
     * @param matchedCallback This callback will be called with the object handed into `addSelectable`
     * @return boolean true if a match was found
     */

  }, {
    key: "match",
    value: function match(cssSelector, matchedCallback) {
      var result = false;
      var element = cssSelector.element;
      var classNames = cssSelector.classNames;
      var attrs = cssSelector.attrs;

      for (var i = 0; i < this._listContexts.length; i++) {
        this._listContexts[i].alreadyMatched = false;
      }

      result = this._matchTerminal(this._elementMap, element, cssSelector, matchedCallback) || result;
      result = this._matchPartial(this._elementPartialMap, element, cssSelector, matchedCallback) || result;

      if (classNames) {
        for (var _i2 = 0; _i2 < classNames.length; _i2++) {
          var className = classNames[_i2];
          result = this._matchTerminal(this._classMap, className, cssSelector, matchedCallback) || result;
          result = this._matchPartial(this._classPartialMap, className, cssSelector, matchedCallback) || result;
        }
      }

      if (attrs) {
        for (var _i3 = 0; _i3 < attrs.length; _i3 += 2) {
          var name = attrs[_i3];
          var value = attrs[_i3 + 1];

          var terminalValuesMap = this._attrValueMap.get(name);

          if (value) {
            result = this._matchTerminal(terminalValuesMap, '', cssSelector, matchedCallback) || result;
          }

          result = this._matchTerminal(terminalValuesMap, value, cssSelector, matchedCallback) || result;

          var partialValuesMap = this._attrValuePartialMap.get(name);

          if (value) {
            result = this._matchPartial(partialValuesMap, '', cssSelector, matchedCallback) || result;
          }

          result = this._matchPartial(partialValuesMap, value, cssSelector, matchedCallback) || result;
        }
      }

      return result;
    }
    /** @internal */

  }, {
    key: "_matchTerminal",
    value: function _matchTerminal(map, name, cssSelector, matchedCallback) {
      if (!map || typeof name !== 'string') {
        return false;
      }

      var selectables = map.get(name) || [];
      var starSelectables = map.get('*');

      if (starSelectables) {
        selectables = selectables.concat(starSelectables);
      }

      if (selectables.length === 0) {
        return false;
      }

      var selectable;
      var result = false;

      for (var i = 0; i < selectables.length; i++) {
        selectable = selectables[i];
        result = selectable.finalize(cssSelector, matchedCallback) || result;
      }

      return result;
    }
    /** @internal */

  }, {
    key: "_matchPartial",
    value: function _matchPartial(map, name, cssSelector, matchedCallback) {
      if (!map || typeof name !== 'string') {
        return false;
      }

      var nestedSelector = map.get(name);

      if (!nestedSelector) {
        return false;
      } // TODO(perf): get rid of recursion and measure again
      // TODO(perf): don't pass the whole selector into the recursion,
      // but only the not processed parts


      return nestedSelector.match(cssSelector, matchedCallback);
    }
  }], [{
    key: "createNotMatcher",
    value: function createNotMatcher(notSelectors) {
      var notMatcher = new SelectorMatcher();
      notMatcher.addSelectables(notSelectors, null);
      return notMatcher;
    }
  }]);

  return SelectorMatcher;
}();

var SelectorListContext = /*#__PURE__*/(0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(function SelectorListContext(selectors) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, SelectorListContext);

  this.selectors = selectors;
  this.alreadyMatched = false;
}); // Store context to pass back selector and context when a selector is matched


var SelectorContext = /*#__PURE__*/function () {
  function SelectorContext(selector, cbContext, listContext) {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, SelectorContext);

    this.selector = selector;
    this.cbContext = cbContext;
    this.listContext = listContext;
    this.notSelectors = selector.notSelectors;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(SelectorContext, [{
    key: "finalize",
    value: function finalize(cssSelector, callback) {
      var result = true;

      if (this.notSelectors.length > 0 && (!this.listContext || !this.listContext.alreadyMatched)) {
        var notMatcher = SelectorMatcher.createNotMatcher(this.notSelectors);
        result = !notMatcher.match(cssSelector, null);
      }

      if (result && callback && (!this.listContext || !this.listContext.alreadyMatched)) {
        if (this.listContext) {
          this.listContext.alreadyMatched = true;
        }

        callback(this.selector, this.cbContext);
      }

      return result;
    }
  }]);

  return SelectorContext;
}();
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
// Stores the default value of `emitDistinctChangesOnly` when the `emitDistinctChangesOnly` is not
// explicitly set.


var emitDistinctChangesOnlyDefaultValue = true;
var ViewEncapsulation;

(function (ViewEncapsulation) {
  ViewEncapsulation[ViewEncapsulation["Emulated"] = 0] = "Emulated"; // Historically the 1 value was for `Native` encapsulation which has been removed as of v11.

  ViewEncapsulation[ViewEncapsulation["None"] = 2] = "None";
  ViewEncapsulation[ViewEncapsulation["ShadowDom"] = 3] = "ShadowDom";
})(ViewEncapsulation || (ViewEncapsulation = {}));

var ChangeDetectionStrategy;

(function (ChangeDetectionStrategy) {
  ChangeDetectionStrategy[ChangeDetectionStrategy["OnPush"] = 0] = "OnPush";
  ChangeDetectionStrategy[ChangeDetectionStrategy["Default"] = 1] = "Default";
})(ChangeDetectionStrategy || (ChangeDetectionStrategy = {}));

var CUSTOM_ELEMENTS_SCHEMA = {
  name: 'custom-elements'
};
var NO_ERRORS_SCHEMA = {
  name: 'no-errors-schema'
};
var Type$1 = Function;
var SecurityContext;

(function (SecurityContext) {
  SecurityContext[SecurityContext["NONE"] = 0] = "NONE";
  SecurityContext[SecurityContext["HTML"] = 1] = "HTML";
  SecurityContext[SecurityContext["STYLE"] = 2] = "STYLE";
  SecurityContext[SecurityContext["SCRIPT"] = 3] = "SCRIPT";
  SecurityContext[SecurityContext["URL"] = 4] = "URL";
  SecurityContext[SecurityContext["RESOURCE_URL"] = 5] = "RESOURCE_URL";
})(SecurityContext || (SecurityContext = {}));

var MissingTranslationStrategy;

(function (MissingTranslationStrategy) {
  MissingTranslationStrategy[MissingTranslationStrategy["Error"] = 0] = "Error";
  MissingTranslationStrategy[MissingTranslationStrategy["Warning"] = 1] = "Warning";
  MissingTranslationStrategy[MissingTranslationStrategy["Ignore"] = 2] = "Ignore";
})(MissingTranslationStrategy || (MissingTranslationStrategy = {}));

function parserSelectorToSimpleSelector(selector) {
  var classes = selector.classNames && selector.classNames.length ? [8
  /* SelectorFlags.CLASS */
  ].concat((0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(selector.classNames)) : [];
  var elementName = selector.element && selector.element !== '*' ? selector.element : '';
  return [elementName].concat((0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(selector.attrs), (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(classes));
}

function parserSelectorToNegativeSelector(selector) {
  var classes = selector.classNames && selector.classNames.length ? [8
  /* SelectorFlags.CLASS */
  ].concat((0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(selector.classNames)) : [];

  if (selector.element) {
    return [1
    /* SelectorFlags.NOT */
    | 4
    /* SelectorFlags.ELEMENT */
    , selector.element].concat((0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(selector.attrs), (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(classes));
  } else if (selector.attrs.length) {
    return [1
    /* SelectorFlags.NOT */
    | 2
    /* SelectorFlags.ATTRIBUTE */
    ].concat((0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(selector.attrs), (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(classes));
  } else {
    return selector.classNames && selector.classNames.length ? [1
    /* SelectorFlags.NOT */
    | 8
    /* SelectorFlags.CLASS */
    ].concat((0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(selector.classNames)) : [];
  }
}

function parserSelectorToR3Selector(selector) {
  var positive = parserSelectorToSimpleSelector(selector);
  var negative = selector.notSelectors && selector.notSelectors.length ? selector.notSelectors.map(function (notSelector) {
    return parserSelectorToNegativeSelector(notSelector);
  }) : [];
  return positive.concat.apply(positive, (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(negative));
}

function parseSelectorToR3Selector(selector) {
  return selector ? CssSelector.parse(selector).map(parserSelectorToR3Selector) : [];
}

var core = /*#__PURE__*/Object.freeze({
  __proto__: null,
  emitDistinctChangesOnlyDefaultValue: emitDistinctChangesOnlyDefaultValue,

  get ViewEncapsulation() {
    return ViewEncapsulation;
  },

  get ChangeDetectionStrategy() {
    return ChangeDetectionStrategy;
  },

  CUSTOM_ELEMENTS_SCHEMA: CUSTOM_ELEMENTS_SCHEMA,
  NO_ERRORS_SCHEMA: NO_ERRORS_SCHEMA,
  Type: Type$1,

  get SecurityContext() {
    return SecurityContext;
  },

  get MissingTranslationStrategy() {
    return MissingTranslationStrategy;
  },

  parseSelectorToR3Selector: parseSelectorToR3Selector
});
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

var DASH_CASE_REGEXP = /-+([a-z0-9])/g;

function dashCaseToCamelCase(input) {
  return input.replace(DASH_CASE_REGEXP, function () {
    for (var _len = arguments.length, m = new Array(_len), _key = 0; _key < _len; _key++) {
      m[_key] = arguments[_key];
    }

    return m[1].toUpperCase();
  });
}

function splitAtColon(input, defaultValues) {
  return _splitAt(input, ':', defaultValues);
}

function splitAtPeriod(input, defaultValues) {
  return _splitAt(input, '.', defaultValues);
}

function _splitAt(input, character, defaultValues) {
  var characterIndex = input.indexOf(character);
  if (characterIndex == -1) return defaultValues;
  return [input.slice(0, characterIndex).trim(), input.slice(characterIndex + 1).trim()];
}

function noUndefined(val) {
  return val === undefined ? null : val;
}

function error(msg) {
  throw new Error("Internal Error: ".concat(msg));
} // Escape characters that have a special meaning in Regular Expressions


function escapeRegExp(s) {
  return s.replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');
}

function utf8Encode(str) {
  var encoded = [];

  for (var index = 0; index < str.length; index++) {
    var codePoint = str.charCodeAt(index); // decode surrogate
    // see https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae

    if (codePoint >= 0xd800 && codePoint <= 0xdbff && str.length > index + 1) {
      var low = str.charCodeAt(index + 1);

      if (low >= 0xdc00 && low <= 0xdfff) {
        index++;
        codePoint = (codePoint - 0xd800 << 10) + low - 0xdc00 + 0x10000;
      }
    }

    if (codePoint <= 0x7f) {
      encoded.push(codePoint);
    } else if (codePoint <= 0x7ff) {
      encoded.push(codePoint >> 6 & 0x1F | 0xc0, codePoint & 0x3f | 0x80);
    } else if (codePoint <= 0xffff) {
      encoded.push(codePoint >> 12 | 0xe0, codePoint >> 6 & 0x3f | 0x80, codePoint & 0x3f | 0x80);
    } else if (codePoint <= 0x1fffff) {
      encoded.push(codePoint >> 18 & 0x07 | 0xf0, codePoint >> 12 & 0x3f | 0x80, codePoint >> 6 & 0x3f | 0x80, codePoint & 0x3f | 0x80);
    }
  }

  return encoded;
}

function stringify(token) {
  if (typeof token === 'string') {
    return token;
  }

  if (Array.isArray(token)) {
    return '[' + token.map(stringify).join(', ') + ']';
  }

  if (token == null) {
    return '' + token;
  }

  if (token.overriddenName) {
    return "".concat(token.overriddenName);
  }

  if (token.name) {
    return "".concat(token.name);
  }

  if (!token.toString) {
    return 'object';
  } // WARNING: do not try to `JSON.stringify(token)` here
  // see https://github.com/angular/angular/issues/23440


  var res = token.toString();

  if (res == null) {
    return '' + res;
  }

  var newLineIndex = res.indexOf('\n');
  return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
}

var Version = /*#__PURE__*/(0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(function Version(full) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, Version);

  this.full = full;
  var splits = full.split('.');
  this.major = splits[0];
  this.minor = splits[1];
  this.patch = splits.slice(2).join('.');
}); // Check `global` first, because in Node tests both `global` and `window` may be defined and our
// `_global` variable should point to the NodeJS `global` in that case. Note: Typeof/Instanceof
// checks are considered side-effects in Terser. We explicitly mark this as side-effect free:
// https://github.com/terser/terser/issues/250.


var _global = /* @__PURE__ */function () {
  return typeof global !== 'undefined' && global || typeof window !== 'undefined' && window || typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope && self;
}();

function newArray(size, value) {
  var list = [];

  for (var i = 0; i < size; i++) {
    list.push(value);
  }

  return list;
}
/**
 * Partitions a given array into 2 arrays, based on a boolean value returned by the condition
 * function.
 *
 * @param arr Input array that should be partitioned
 * @param conditionFn Condition function that is called for each item in a given array and returns a
 * boolean value.
 */


function partitionArray(arr, conditionFn) {
  var truthy = [];
  var falsy = [];

  var _iterator = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper_js__WEBPACK_IMPORTED_MODULE_9__["default"])(arr),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var item = _step.value;
      (conditionFn(item) ? truthy : falsy).push(item);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return [truthy, falsy];
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * Represents a big integer using a buffer of its individual digits, with the least significant
 * digit stored at the beginning of the array (little endian).
 *
 * For performance reasons, each instance is mutable. The addition operation can be done in-place
 * to reduce memory pressure of allocation for the digits array.
 */


var BigInteger = /*#__PURE__*/function () {
  /**
   * Creates a big integer using its individual digits in little endian storage.
   */
  function BigInteger(digits) {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, BigInteger);

    this.digits = digits;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(BigInteger, [{
    key: "clone",
    value:
    /**
     * Creates a clone of this instance.
     */
    function clone() {
      return new BigInteger(this.digits.slice());
    }
    /**
     * Returns a new big integer with the sum of `this` and `other` as its value. This does not mutate
     * `this` but instead returns a new instance, unlike `addToSelf`.
     */

  }, {
    key: "add",
    value: function add(other) {
      var result = this.clone();
      result.addToSelf(other);
      return result;
    }
    /**
     * Adds `other` to the instance itself, thereby mutating its value.
     */

  }, {
    key: "addToSelf",
    value: function addToSelf(other) {
      var maxNrOfDigits = Math.max(this.digits.length, other.digits.length);
      var carry = 0;

      for (var i = 0; i < maxNrOfDigits; i++) {
        var digitSum = carry;

        if (i < this.digits.length) {
          digitSum += this.digits[i];
        }

        if (i < other.digits.length) {
          digitSum += other.digits[i];
        }

        if (digitSum >= 10) {
          this.digits[i] = digitSum - 10;
          carry = 1;
        } else {
          this.digits[i] = digitSum;
          carry = 0;
        }
      } // Apply a remaining carry if needed.


      if (carry > 0) {
        this.digits[maxNrOfDigits] = 1;
      }
    }
    /**
     * Builds the decimal string representation of the big integer. As this is stored in
     * little endian, the digits are concatenated in reverse order.
     */

  }, {
    key: "toString",
    value: function toString() {
      var res = '';

      for (var i = this.digits.length - 1; i >= 0; i--) {
        res += this.digits[i];
      }

      return res;
    }
  }], [{
    key: "zero",
    value: function zero() {
      return new BigInteger([0]);
    }
  }, {
    key: "one",
    value: function one() {
      return new BigInteger([1]);
    }
  }]);

  return BigInteger;
}();
/**
 * Represents a big integer which is optimized for multiplication operations, as its power-of-twos
 * are memoized. See `multiplyBy()` for details on the multiplication algorithm.
 */


var BigIntForMultiplication = /*#__PURE__*/function () {
  function BigIntForMultiplication(value) {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, BigIntForMultiplication);

    this.powerOfTwos = [value];
  }
  /**
   * Returns the big integer itself.
   */


  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(BigIntForMultiplication, [{
    key: "getValue",
    value: function getValue() {
      return this.powerOfTwos[0];
    }
    /**
     * Computes the value for `num * b`, where `num` is a JS number and `b` is a big integer. The
     * value for `b` is represented by a storage model that is optimized for this computation.
     *
     * This operation is implemented in N(log2(num)) by continuous halving of the number, where the
     * least-significant bit (LSB) is tested in each iteration. If the bit is set, the bit's index is
     * used as exponent into the power-of-two multiplication of `b`.
     *
     * As an example, consider the multiplication num=42, b=1337. In binary 42 is 0b00101010 and the
     * algorithm unrolls into the following iterations:
     *
     *  Iteration | num        | LSB  | b * 2^iter | Add? | product
     * -----------|------------|------|------------|------|--------
     *  0         | 0b00101010 | 0    | 1337       | No   | 0
     *  1         | 0b00010101 | 1    | 2674       | Yes  | 2674
     *  2         | 0b00001010 | 0    | 5348       | No   | 2674
     *  3         | 0b00000101 | 1    | 10696      | Yes  | 13370
     *  4         | 0b00000010 | 0    | 21392      | No   | 13370
     *  5         | 0b00000001 | 1    | 42784      | Yes  | 56154
     *  6         | 0b00000000 | 0    | 85568      | No   | 56154
     *
     * The computed product of 56154 is indeed the correct result.
     *
     * The `BigIntForMultiplication` representation for a big integer provides memoized access to the
     * power-of-two values to reduce the workload in computing those values.
     */

  }, {
    key: "multiplyBy",
    value: function multiplyBy(num) {
      var product = BigInteger.zero();
      this.multiplyByAndAddTo(num, product);
      return product;
    }
    /**
     * See `multiplyBy()` for details. This function allows for the computed product to be added
     * directly to the provided result big integer.
     */

  }, {
    key: "multiplyByAndAddTo",
    value: function multiplyByAndAddTo(num, result) {
      for (var exponent = 0; num !== 0; num = num >>> 1, exponent++) {
        if (num & 1) {
          var value = this.getMultipliedByPowerOfTwo(exponent);
          result.addToSelf(value);
        }
      }
    }
    /**
     * Computes and memoizes the big integer value for `this.number * 2^exponent`.
     */

  }, {
    key: "getMultipliedByPowerOfTwo",
    value: function getMultipliedByPowerOfTwo(exponent) {
      // Compute the powers up until the requested exponent, where each value is computed from its
      // predecessor. This is simple as `this.number * 2^(exponent - 1)` only has to be doubled (i.e.
      // added to itself) to reach `this.number * 2^exponent`.
      for (var i = this.powerOfTwos.length; i <= exponent; i++) {
        var previousPower = this.powerOfTwos[i - 1];
        this.powerOfTwos[i] = previousPower.add(previousPower);
      }

      return this.powerOfTwos[exponent];
    }
  }]);

  return BigIntForMultiplication;
}();
/**
 * Represents an exponentiation operation for the provided base, of which exponents are computed and
 * memoized. The results are represented by a `BigIntForMultiplication` which is tailored for
 * multiplication operations by memoizing the power-of-twos. This effectively results in a matrix
 * representation that is lazily computed upon request.
 */


var BigIntExponentiation = /*#__PURE__*/function () {
  function BigIntExponentiation(base) {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, BigIntExponentiation);

    this.base = base;
    this.exponents = [new BigIntForMultiplication(BigInteger.one())];
  }
  /**
   * Compute the value for `this.base^exponent`, resulting in a big integer that is optimized for
   * further multiplication operations.
   */


  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(BigIntExponentiation, [{
    key: "toThePowerOf",
    value: function toThePowerOf(exponent) {
      // Compute the results up until the requested exponent, where every value is computed from its
      // predecessor. This is because `this.base^(exponent - 1)` only has to be multiplied by `base`
      // to reach `this.base^exponent`.
      for (var i = this.exponents.length; i <= exponent; i++) {
        var value = this.exponents[i - 1].multiplyBy(this.base);
        this.exponents[i] = new BigIntForMultiplication(value);
      }

      return this.exponents[exponent];
    }
  }]);

  return BigIntExponentiation;
}();
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * Return the message id or compute it using the XLIFF1 digest.
 */


function digest$1(message) {
  return message.id || computeDigest(message);
}
/**
 * Compute the message id using the XLIFF1 digest.
 */


function computeDigest(message) {
  return sha1(serializeNodes(message.nodes).join('') + "[".concat(message.meaning, "]"));
}
/**
 * Return the message id or compute it using the XLIFF2/XMB/$localize digest.
 */


function decimalDigest(message) {
  return message.id || computeDecimalDigest(message);
}
/**
 * Compute the message id using the XLIFF2/XMB/$localize digest.
 */


function computeDecimalDigest(message) {
  var visitor = new _SerializerIgnoreIcuExpVisitor();
  var parts = message.nodes.map(function (a) {
    return a.visit(visitor, null);
  });
  return computeMsgId(parts.join(''), message.meaning);
}
/**
 * Serialize the i18n ast to something xml-like in order to generate an UID.
 *
 * The visitor is also used in the i18n parser tests
 *
 * @internal
 */


var _SerializerVisitor = /*#__PURE__*/function () {
  function _SerializerVisitor() {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, _SerializerVisitor);
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(_SerializerVisitor, [{
    key: "visitText",
    value: function visitText(text, context) {
      return text.value;
    }
  }, {
    key: "visitContainer",
    value: function visitContainer(container, context) {
      var _this2 = this;

      return "[".concat(container.children.map(function (child) {
        return child.visit(_this2);
      }).join(', '), "]");
    }
  }, {
    key: "visitIcu",
    value: function visitIcu(icu, context) {
      var _this3 = this;

      var strCases = Object.keys(icu.cases).map(function (k) {
        return "".concat(k, " {").concat(icu.cases[k].visit(_this3), "}");
      });
      return "{".concat(icu.expression, ", ").concat(icu.type, ", ").concat(strCases.join(', '), "}");
    }
  }, {
    key: "visitTagPlaceholder",
    value: function visitTagPlaceholder(ph, context) {
      var _this4 = this;

      return ph.isVoid ? "<ph tag name=\"".concat(ph.startName, "\"/>") : "<ph tag name=\"".concat(ph.startName, "\">").concat(ph.children.map(function (child) {
        return child.visit(_this4);
      }).join(', '), "</ph name=\"").concat(ph.closeName, "\">");
    }
  }, {
    key: "visitPlaceholder",
    value: function visitPlaceholder(ph, context) {
      return ph.value ? "<ph name=\"".concat(ph.name, "\">").concat(ph.value, "</ph>") : "<ph name=\"".concat(ph.name, "\"/>");
    }
  }, {
    key: "visitIcuPlaceholder",
    value: function visitIcuPlaceholder(ph, context) {
      return "<ph icu name=\"".concat(ph.name, "\">").concat(ph.value.visit(this), "</ph>");
    }
  }]);

  return _SerializerVisitor;
}();

var serializerVisitor$1 = new _SerializerVisitor();

function serializeNodes(nodes) {
  return nodes.map(function (a) {
    return a.visit(serializerVisitor$1, null);
  });
}
/**
 * Serialize the i18n ast to something xml-like in order to generate an UID.
 *
 * Ignore the ICU expressions so that message IDs stays identical if only the expression changes.
 *
 * @internal
 */


var _SerializerIgnoreIcuExpVisitor = /*#__PURE__*/function (_SerializerVisitor2) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(_SerializerIgnoreIcuExpVisitor, _SerializerVisitor2);

  var _super = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(_SerializerIgnoreIcuExpVisitor);

  function _SerializerIgnoreIcuExpVisitor() {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, _SerializerIgnoreIcuExpVisitor);

    return _super.apply(this, arguments);
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(_SerializerIgnoreIcuExpVisitor, [{
    key: "visitIcu",
    value: function visitIcu(icu, context) {
      var _this5 = this;

      var strCases = Object.keys(icu.cases).map(function (k) {
        return "".concat(k, " {").concat(icu.cases[k].visit(_this5), "}");
      }); // Do not take the expression into account

      return "{".concat(icu.type, ", ").concat(strCases.join(', '), "}");
    }
  }]);

  return _SerializerIgnoreIcuExpVisitor;
}(_SerializerVisitor);
/**
 * Compute the SHA1 of the given string
 *
 * see https://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf
 *
 * WARNING: this function has not been designed not tested with security in mind.
 *          DO NOT USE IT IN A SECURITY SENSITIVE CONTEXT.
 */


function sha1(str) {
  var utf8 = utf8Encode(str);
  var words32 = bytesToWords32(utf8, Endian.Big);
  var len = utf8.length * 8;
  var w = newArray(80);
  var a = 0x67452301,
      b = 0xefcdab89,
      c = 0x98badcfe,
      d = 0x10325476,
      e = 0xc3d2e1f0;
  words32[len >> 5] |= 0x80 << 24 - len % 32;
  words32[(len + 64 >> 9 << 4) + 15] = len;

  for (var i = 0; i < words32.length; i += 16) {
    var h0 = a,
        h1 = b,
        h2 = c,
        h3 = d,
        h4 = e;

    for (var j = 0; j < 80; j++) {
      if (j < 16) {
        w[j] = words32[i + j];
      } else {
        w[j] = rol32(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
      }

      var fkVal = fk(j, b, c, d);
      var f = fkVal[0];
      var k = fkVal[1];
      var temp = [rol32(a, 5), f, e, k, w[j]].reduce(add32);
      e = d;
      d = c;
      c = rol32(b, 30);
      b = a;
      a = temp;
    }

    a = add32(a, h0);
    b = add32(b, h1);
    c = add32(c, h2);
    d = add32(d, h3);
    e = add32(e, h4);
  }

  return bytesToHexString(words32ToByteString([a, b, c, d, e]));
}

function fk(index, b, c, d) {
  if (index < 20) {
    return [b & c | ~b & d, 0x5a827999];
  }

  if (index < 40) {
    return [b ^ c ^ d, 0x6ed9eba1];
  }

  if (index < 60) {
    return [b & c | b & d | c & d, 0x8f1bbcdc];
  }

  return [b ^ c ^ d, 0xca62c1d6];
}
/**
 * Compute the fingerprint of the given string
 *
 * The output is 64 bit number encoded as a decimal string
 *
 * based on:
 * https://github.com/google/closure-compiler/blob/master/src/com/google/javascript/jscomp/GoogleJsMessageIdGenerator.java
 */


function fingerprint(str) {
  var utf8 = utf8Encode(str);
  var hi = hash32(utf8, 0);
  var lo = hash32(utf8, 102072);

  if (hi == 0 && (lo == 0 || lo == 1)) {
    hi = hi ^ 0x130f9bef;
    lo = lo ^ -0x6b5f56d8;
  }

  return [hi, lo];
}

function computeMsgId(msg) {
  var meaning = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var msgFingerprint = fingerprint(msg);

  if (meaning) {
    var meaningFingerprint = fingerprint(meaning);
    msgFingerprint = add64(rol64(msgFingerprint, 1), meaningFingerprint);
  }

  var hi = msgFingerprint[0];
  var lo = msgFingerprint[1];
  return wordsToDecimalString(hi & 0x7fffffff, lo);
}

function hash32(bytes, c) {
  var a = 0x9e3779b9,
      b = 0x9e3779b9;
  var i;
  var len = bytes.length;

  for (i = 0; i + 12 <= len; i += 12) {
    a = add32(a, wordAt(bytes, i, Endian.Little));
    b = add32(b, wordAt(bytes, i + 4, Endian.Little));
    c = add32(c, wordAt(bytes, i + 8, Endian.Little));
    var res = mix(a, b, c);
    a = res[0], b = res[1], c = res[2];
  }

  a = add32(a, wordAt(bytes, i, Endian.Little));
  b = add32(b, wordAt(bytes, i + 4, Endian.Little)); // the first byte of c is reserved for the length

  c = add32(c, len);
  c = add32(c, wordAt(bytes, i + 8, Endian.Little) << 8);
  return mix(a, b, c)[2];
} // clang-format off


function mix(a, b, c) {
  a = sub32(a, b);
  a = sub32(a, c);
  a ^= c >>> 13;
  b = sub32(b, c);
  b = sub32(b, a);
  b ^= a << 8;
  c = sub32(c, a);
  c = sub32(c, b);
  c ^= b >>> 13;
  a = sub32(a, b);
  a = sub32(a, c);
  a ^= c >>> 12;
  b = sub32(b, c);
  b = sub32(b, a);
  b ^= a << 16;
  c = sub32(c, a);
  c = sub32(c, b);
  c ^= b >>> 5;
  a = sub32(a, b);
  a = sub32(a, c);
  a ^= c >>> 3;
  b = sub32(b, c);
  b = sub32(b, a);
  b ^= a << 10;
  c = sub32(c, a);
  c = sub32(c, b);
  c ^= b >>> 15;
  return [a, b, c];
} // clang-format on
// Utils


var Endian;

(function (Endian) {
  Endian[Endian["Little"] = 0] = "Little";
  Endian[Endian["Big"] = 1] = "Big";
})(Endian || (Endian = {}));

function add32(a, b) {
  return add32to64(a, b)[1];
}

function add32to64(a, b) {
  var low = (a & 0xffff) + (b & 0xffff);
  var high = (a >>> 16) + (b >>> 16) + (low >>> 16);
  return [high >>> 16, high << 16 | low & 0xffff];
}

function add64(a, b) {
  var ah = a[0],
      al = a[1];
  var bh = b[0],
      bl = b[1];
  var result = add32to64(al, bl);
  var carry = result[0];
  var l = result[1];
  var h = add32(add32(ah, bh), carry);
  return [h, l];
}

function sub32(a, b) {
  var low = (a & 0xffff) - (b & 0xffff);
  var high = (a >> 16) - (b >> 16) + (low >> 16);
  return high << 16 | low & 0xffff;
} // Rotate a 32b number left `count` position


function rol32(a, count) {
  return a << count | a >>> 32 - count;
} // Rotate a 64b number left `count` position


function rol64(num, count) {
  var hi = num[0],
      lo = num[1];
  var h = hi << count | lo >>> 32 - count;
  var l = lo << count | hi >>> 32 - count;
  return [h, l];
}

function bytesToWords32(bytes, endian) {
  var size = bytes.length + 3 >>> 2;
  var words32 = [];

  for (var i = 0; i < size; i++) {
    words32[i] = wordAt(bytes, i * 4, endian);
  }

  return words32;
}

function byteAt(bytes, index) {
  return index >= bytes.length ? 0 : bytes[index];
}

function wordAt(bytes, index, endian) {
  var word = 0;

  if (endian === Endian.Big) {
    for (var i = 0; i < 4; i++) {
      word += byteAt(bytes, index + i) << 24 - 8 * i;
    }
  } else {
    for (var _i4 = 0; _i4 < 4; _i4++) {
      word += byteAt(bytes, index + _i4) << 8 * _i4;
    }
  }

  return word;
}

function words32ToByteString(words32) {
  return words32.reduce(function (bytes, word) {
    return bytes.concat(word32ToByteString(word));
  }, []);
}

function word32ToByteString(word) {
  var bytes = [];

  for (var i = 0; i < 4; i++) {
    bytes.push(word >>> 8 * (3 - i) & 0xff);
  }

  return bytes;
}

function bytesToHexString(bytes) {
  var hex = '';

  for (var i = 0; i < bytes.length; i++) {
    var b = byteAt(bytes, i);
    hex += (b >>> 4).toString(16) + (b & 0x0f).toString(16);
  }

  return hex.toLowerCase();
}
/**
 * Create a shared exponentiation pool for base-256 computations. This shared pool provides memoized
 * power-of-256 results with memoized power-of-two computations for efficient multiplication.
 *
 * For our purposes, this can be safely stored as a global without memory concerns. The reason is
 * that we encode two words, so only need the 0th (for the low word) and 4th (for the high word)
 * exponent.
 */


var base256 = new BigIntExponentiation(256);
/**
 * Represents two 32-bit words as a single decimal number. This requires a big integer storage
 * model as JS numbers are not accurate enough to represent the 64-bit number.
 *
 * Based on https://www.danvk.org/hex2dec.html
 */

function wordsToDecimalString(hi, lo) {
  // Encode the four bytes in lo in the lower digits of the decimal number.
  // Note: the multiplication results in lo itself but represented by a big integer using its
  // decimal digits.
  var decimal = base256.toThePowerOf(0).multiplyBy(lo); // Encode the four bytes in hi above the four lo bytes. lo is a maximum of (2^8)^4, which is why
  // this multiplication factor is applied.

  base256.toThePowerOf(4).multiplyByAndAddTo(hi, decimal);
  return decimal.toString();
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
//// Types


var TypeModifier;

(function (TypeModifier) {
  TypeModifier[TypeModifier["None"] = 0] = "None";
  TypeModifier[TypeModifier["Const"] = 1] = "Const";
})(TypeModifier || (TypeModifier = {}));

var Type = /*#__PURE__*/function () {
  function Type() {
    var modifiers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : TypeModifier.None;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, Type);

    this.modifiers = modifiers;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(Type, [{
    key: "hasModifier",
    value: function hasModifier(modifier) {
      return (this.modifiers & modifier) !== 0;
    }
  }]);

  return Type;
}();

var BuiltinTypeName;

(function (BuiltinTypeName) {
  BuiltinTypeName[BuiltinTypeName["Dynamic"] = 0] = "Dynamic";
  BuiltinTypeName[BuiltinTypeName["Bool"] = 1] = "Bool";
  BuiltinTypeName[BuiltinTypeName["String"] = 2] = "String";
  BuiltinTypeName[BuiltinTypeName["Int"] = 3] = "Int";
  BuiltinTypeName[BuiltinTypeName["Number"] = 4] = "Number";
  BuiltinTypeName[BuiltinTypeName["Function"] = 5] = "Function";
  BuiltinTypeName[BuiltinTypeName["Inferred"] = 6] = "Inferred";
  BuiltinTypeName[BuiltinTypeName["None"] = 7] = "None";
})(BuiltinTypeName || (BuiltinTypeName = {}));

var BuiltinType = /*#__PURE__*/function (_Type) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(BuiltinType, _Type);

  var _super2 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(BuiltinType);

  function BuiltinType(name, modifiers) {
    var _this6;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, BuiltinType);

    _this6 = _super2.call(this, modifiers);
    _this6.name = name;
    return _this6;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(BuiltinType, [{
    key: "visitType",
    value: function visitType(visitor, context) {
      return visitor.visitBuiltinType(this, context);
    }
  }]);

  return BuiltinType;
}(Type);

var ExpressionType = /*#__PURE__*/function (_Type2) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(ExpressionType, _Type2);

  var _super3 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(ExpressionType);

  function ExpressionType(value, modifiers) {
    var _this7;

    var typeParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, ExpressionType);

    _this7 = _super3.call(this, modifiers);
    _this7.value = value;
    _this7.typeParams = typeParams;
    return _this7;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(ExpressionType, [{
    key: "visitType",
    value: function visitType(visitor, context) {
      return visitor.visitExpressionType(this, context);
    }
  }]);

  return ExpressionType;
}(Type);

var ArrayType = /*#__PURE__*/function (_Type3) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(ArrayType, _Type3);

  var _super4 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(ArrayType);

  function ArrayType(of, modifiers) {
    var _this8;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, ArrayType);

    _this8 = _super4.call(this, modifiers);
    _this8.of = of;
    return _this8;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(ArrayType, [{
    key: "visitType",
    value: function visitType(visitor, context) {
      return visitor.visitArrayType(this, context);
    }
  }]);

  return ArrayType;
}(Type);

var MapType = /*#__PURE__*/function (_Type4) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(MapType, _Type4);

  var _super5 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(MapType);

  function MapType(valueType, modifiers) {
    var _this9;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, MapType);

    _this9 = _super5.call(this, modifiers);
    _this9.valueType = valueType || null;
    return _this9;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(MapType, [{
    key: "visitType",
    value: function visitType(visitor, context) {
      return visitor.visitMapType(this, context);
    }
  }]);

  return MapType;
}(Type);

var DYNAMIC_TYPE = new BuiltinType(BuiltinTypeName.Dynamic);
var INFERRED_TYPE = new BuiltinType(BuiltinTypeName.Inferred);
var BOOL_TYPE = new BuiltinType(BuiltinTypeName.Bool);
var INT_TYPE = new BuiltinType(BuiltinTypeName.Int);
var NUMBER_TYPE = new BuiltinType(BuiltinTypeName.Number);
var STRING_TYPE = new BuiltinType(BuiltinTypeName.String);
var FUNCTION_TYPE = new BuiltinType(BuiltinTypeName.Function);
var NONE_TYPE = new BuiltinType(BuiltinTypeName.None); ///// Expressions

var UnaryOperator;

(function (UnaryOperator) {
  UnaryOperator[UnaryOperator["Minus"] = 0] = "Minus";
  UnaryOperator[UnaryOperator["Plus"] = 1] = "Plus";
})(UnaryOperator || (UnaryOperator = {}));

var BinaryOperator;

(function (BinaryOperator) {
  BinaryOperator[BinaryOperator["Equals"] = 0] = "Equals";
  BinaryOperator[BinaryOperator["NotEquals"] = 1] = "NotEquals";
  BinaryOperator[BinaryOperator["Identical"] = 2] = "Identical";
  BinaryOperator[BinaryOperator["NotIdentical"] = 3] = "NotIdentical";
  BinaryOperator[BinaryOperator["Minus"] = 4] = "Minus";
  BinaryOperator[BinaryOperator["Plus"] = 5] = "Plus";
  BinaryOperator[BinaryOperator["Divide"] = 6] = "Divide";
  BinaryOperator[BinaryOperator["Multiply"] = 7] = "Multiply";
  BinaryOperator[BinaryOperator["Modulo"] = 8] = "Modulo";
  BinaryOperator[BinaryOperator["And"] = 9] = "And";
  BinaryOperator[BinaryOperator["Or"] = 10] = "Or";
  BinaryOperator[BinaryOperator["BitwiseAnd"] = 11] = "BitwiseAnd";
  BinaryOperator[BinaryOperator["Lower"] = 12] = "Lower";
  BinaryOperator[BinaryOperator["LowerEquals"] = 13] = "LowerEquals";
  BinaryOperator[BinaryOperator["Bigger"] = 14] = "Bigger";
  BinaryOperator[BinaryOperator["BiggerEquals"] = 15] = "BiggerEquals";
  BinaryOperator[BinaryOperator["NullishCoalesce"] = 16] = "NullishCoalesce";
})(BinaryOperator || (BinaryOperator = {}));

function nullSafeIsEquivalent(base, other) {
  if (base == null || other == null) {
    return base == other;
  }

  return base.isEquivalent(other);
}

function areAllEquivalentPredicate(base, other, equivalentPredicate) {
  var len = base.length;

  if (len !== other.length) {
    return false;
  }

  for (var i = 0; i < len; i++) {
    if (!equivalentPredicate(base[i], other[i])) {
      return false;
    }
  }

  return true;
}

function areAllEquivalent(base, other) {
  return areAllEquivalentPredicate(base, other, function (baseElement, otherElement) {
    return baseElement.isEquivalent(otherElement);
  });
}

var Expression = /*#__PURE__*/function () {
  function Expression(type, sourceSpan) {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, Expression);

    this.type = type || null;
    this.sourceSpan = sourceSpan || null;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(Expression, [{
    key: "prop",
    value: function prop(name, sourceSpan) {
      return new ReadPropExpr(this, name, null, sourceSpan);
    }
  }, {
    key: "key",
    value: function key(index, type, sourceSpan) {
      return new ReadKeyExpr(this, index, type, sourceSpan);
    }
  }, {
    key: "callFn",
    value: function callFn(params, sourceSpan, pure) {
      return new InvokeFunctionExpr(this, params, null, sourceSpan, pure);
    }
  }, {
    key: "instantiate",
    value: function instantiate(params, type, sourceSpan) {
      return new InstantiateExpr(this, params, type, sourceSpan);
    }
  }, {
    key: "conditional",
    value: function conditional(trueCase) {
      var falseCase = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var sourceSpan = arguments.length > 2 ? arguments[2] : undefined;
      return new ConditionalExpr(this, trueCase, falseCase, null, sourceSpan);
    }
  }, {
    key: "equals",
    value: function equals(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.Equals, this, rhs, null, sourceSpan);
    }
  }, {
    key: "notEquals",
    value: function notEquals(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.NotEquals, this, rhs, null, sourceSpan);
    }
  }, {
    key: "identical",
    value: function identical(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.Identical, this, rhs, null, sourceSpan);
    }
  }, {
    key: "notIdentical",
    value: function notIdentical(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.NotIdentical, this, rhs, null, sourceSpan);
    }
  }, {
    key: "minus",
    value: function minus(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.Minus, this, rhs, null, sourceSpan);
    }
  }, {
    key: "plus",
    value: function plus(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.Plus, this, rhs, null, sourceSpan);
    }
  }, {
    key: "divide",
    value: function divide(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.Divide, this, rhs, null, sourceSpan);
    }
  }, {
    key: "multiply",
    value: function multiply(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.Multiply, this, rhs, null, sourceSpan);
    }
  }, {
    key: "modulo",
    value: function modulo(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.Modulo, this, rhs, null, sourceSpan);
    }
  }, {
    key: "and",
    value: function and(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.And, this, rhs, null, sourceSpan);
    }
  }, {
    key: "bitwiseAnd",
    value: function bitwiseAnd(rhs, sourceSpan) {
      var parens = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      return new BinaryOperatorExpr(BinaryOperator.BitwiseAnd, this, rhs, null, sourceSpan, parens);
    }
  }, {
    key: "or",
    value: function or(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.Or, this, rhs, null, sourceSpan);
    }
  }, {
    key: "lower",
    value: function lower(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.Lower, this, rhs, null, sourceSpan);
    }
  }, {
    key: "lowerEquals",
    value: function lowerEquals(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.LowerEquals, this, rhs, null, sourceSpan);
    }
  }, {
    key: "bigger",
    value: function bigger(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.Bigger, this, rhs, null, sourceSpan);
    }
  }, {
    key: "biggerEquals",
    value: function biggerEquals(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.BiggerEquals, this, rhs, null, sourceSpan);
    }
  }, {
    key: "isBlank",
    value: function isBlank(sourceSpan) {
      // Note: We use equals by purpose here to compare to null and undefined in JS.
      // We use the typed null to allow strictNullChecks to narrow types.
      return this.equals(TYPED_NULL_EXPR, sourceSpan);
    }
  }, {
    key: "nullishCoalesce",
    value: function nullishCoalesce(rhs, sourceSpan) {
      return new BinaryOperatorExpr(BinaryOperator.NullishCoalesce, this, rhs, null, sourceSpan);
    }
  }, {
    key: "toStmt",
    value: function toStmt() {
      return new ExpressionStatement(this, null);
    }
  }]);

  return Expression;
}();

var ReadVarExpr = /*#__PURE__*/function (_Expression) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(ReadVarExpr, _Expression);

  var _super6 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(ReadVarExpr);

  function ReadVarExpr(name, type, sourceSpan) {
    var _this10;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, ReadVarExpr);

    _this10 = _super6.call(this, type, sourceSpan);
    _this10.name = name;
    return _this10;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(ReadVarExpr, [{
    key: "isEquivalent",
    value: function isEquivalent(e) {
      return e instanceof ReadVarExpr && this.name === e.name;
    }
  }, {
    key: "isConstant",
    value: function isConstant() {
      return false;
    }
  }, {
    key: "visitExpression",
    value: function visitExpression(visitor, context) {
      return visitor.visitReadVarExpr(this, context);
    }
  }, {
    key: "set",
    value: function set(value) {
      return new WriteVarExpr(this.name, value, null, this.sourceSpan);
    }
  }]);

  return ReadVarExpr;
}(Expression);

var TypeofExpr = /*#__PURE__*/function (_Expression2) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(TypeofExpr, _Expression2);

  var _super7 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(TypeofExpr);

  function TypeofExpr(expr, type, sourceSpan) {
    var _this11;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, TypeofExpr);

    _this11 = _super7.call(this, type, sourceSpan);
    _this11.expr = expr;
    return _this11;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(TypeofExpr, [{
    key: "visitExpression",
    value: function visitExpression(visitor, context) {
      return visitor.visitTypeofExpr(this, context);
    }
  }, {
    key: "isEquivalent",
    value: function isEquivalent(e) {
      return e instanceof TypeofExpr && e.expr.isEquivalent(this.expr);
    }
  }, {
    key: "isConstant",
    value: function isConstant() {
      return this.expr.isConstant();
    }
  }]);

  return TypeofExpr;
}(Expression);

var WrappedNodeExpr = /*#__PURE__*/function (_Expression3) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(WrappedNodeExpr, _Expression3);

  var _super8 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(WrappedNodeExpr);

  function WrappedNodeExpr(node, type, sourceSpan) {
    var _this12;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, WrappedNodeExpr);

    _this12 = _super8.call(this, type, sourceSpan);
    _this12.node = node;
    return _this12;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(WrappedNodeExpr, [{
    key: "isEquivalent",
    value: function isEquivalent(e) {
      return e instanceof WrappedNodeExpr && this.node === e.node;
    }
  }, {
    key: "isConstant",
    value: function isConstant() {
      return false;
    }
  }, {
    key: "visitExpression",
    value: function visitExpression(visitor, context) {
      return visitor.visitWrappedNodeExpr(this, context);
    }
  }]);

  return WrappedNodeExpr;
}(Expression);

var WriteVarExpr = /*#__PURE__*/function (_Expression4) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(WriteVarExpr, _Expression4);

  var _super9 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(WriteVarExpr);

  function WriteVarExpr(name, value, type, sourceSpan) {
    var _this13;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, WriteVarExpr);

    _this13 = _super9.call(this, type || value.type, sourceSpan);
    _this13.name = name;
    _this13.value = value;
    return _this13;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(WriteVarExpr, [{
    key: "isEquivalent",
    value: function isEquivalent(e) {
      return e instanceof WriteVarExpr && this.name === e.name && this.value.isEquivalent(e.value);
    }
  }, {
    key: "isConstant",
    value: function isConstant() {
      return false;
    }
  }, {
    key: "visitExpression",
    value: function visitExpression(visitor, context) {
      return visitor.visitWriteVarExpr(this, context);
    }
  }, {
    key: "toDeclStmt",
    value: function toDeclStmt(type, modifiers) {
      return new DeclareVarStmt(this.name, this.value, type, modifiers, this.sourceSpan);
    }
  }, {
    key: "toConstDecl",
    value: function toConstDecl() {
      return this.toDeclStmt(INFERRED_TYPE, StmtModifier.Final);
    }
  }]);

  return WriteVarExpr;
}(Expression);

var WriteKeyExpr = /*#__PURE__*/function (_Expression5) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(WriteKeyExpr, _Expression5);

  var _super10 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(WriteKeyExpr);

  function WriteKeyExpr(receiver, index, value, type, sourceSpan) {
    var _this14;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, WriteKeyExpr);

    _this14 = _super10.call(this, type || value.type, sourceSpan);
    _this14.receiver = receiver;
    _this14.index = index;
    _this14.value = value;
    return _this14;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(WriteKeyExpr, [{
    key: "isEquivalent",
    value: function isEquivalent(e) {
      return e instanceof WriteKeyExpr && this.receiver.isEquivalent(e.receiver) && this.index.isEquivalent(e.index) && this.value.isEquivalent(e.value);
    }
  }, {
    key: "isConstant",
    value: function isConstant() {
      return false;
    }
  }, {
    key: "visitExpression",
    value: function visitExpression(visitor, context) {
      return visitor.visitWriteKeyExpr(this, context);
    }
  }]);

  return WriteKeyExpr;
}(Expression);

var WritePropExpr = /*#__PURE__*/function (_Expression6) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(WritePropExpr, _Expression6);

  var _super11 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(WritePropExpr);

  function WritePropExpr(receiver, name, value, type, sourceSpan) {
    var _this15;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, WritePropExpr);

    _this15 = _super11.call(this, type || value.type, sourceSpan);
    _this15.receiver = receiver;
    _this15.name = name;
    _this15.value = value;
    return _this15;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(WritePropExpr, [{
    key: "isEquivalent",
    value: function isEquivalent(e) {
      return e instanceof WritePropExpr && this.receiver.isEquivalent(e.receiver) && this.name === e.name && this.value.isEquivalent(e.value);
    }
  }, {
    key: "isConstant",
    value: function isConstant() {
      return false;
    }
  }, {
    key: "visitExpression",
    value: function visitExpression(visitor, context) {
      return visitor.visitWritePropExpr(this, context);
    }
  }]);

  return WritePropExpr;
}(Expression);

var InvokeFunctionExpr = /*#__PURE__*/function (_Expression7) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(InvokeFunctionExpr, _Expression7);

  var _super12 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(InvokeFunctionExpr);

  function InvokeFunctionExpr(fn, args, type, sourceSpan) {
    var _this16;

    var pure = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, InvokeFunctionExpr);

    _this16 = _super12.call(this, type, sourceSpan);
    _this16.fn = fn;
    _this16.args = args;
    _this16.pure = pure;
    return _this16;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(InvokeFunctionExpr, [{
    key: "isEquivalent",
    value: function isEquivalent(e) {
      return e instanceof InvokeFunctionExpr && this.fn.isEquivalent(e.fn) && areAllEquivalent(this.args, e.args) && this.pure === e.pure;
    }
  }, {
    key: "isConstant",
    value: function isConstant() {
      return false;
    }
  }, {
    key: "visitExpression",
    value: function visitExpression(visitor, context) {
      return visitor.visitInvokeFunctionExpr(this, context);
    }
  }]);

  return InvokeFunctionExpr;
}(Expression);

var TaggedTemplateExpr = /*#__PURE__*/function (_Expression8) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(TaggedTemplateExpr, _Expression8);

  var _super13 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(TaggedTemplateExpr);

  function TaggedTemplateExpr(tag, template, type, sourceSpan) {
    var _this17;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, TaggedTemplateExpr);

    _this17 = _super13.call(this, type, sourceSpan);
    _this17.tag = tag;
    _this17.template = template;
    return _this17;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(TaggedTemplateExpr, [{
    key: "isEquivalent",
    value: function isEquivalent(e) {
      return e instanceof TaggedTemplateExpr && this.tag.isEquivalent(e.tag) && areAllEquivalentPredicate(this.template.elements, e.template.elements, function (a, b) {
        return a.text === b.text;
      }) && areAllEquivalent(this.template.expressions, e.template.expressions);
    }
  }, {
    key: "isConstant",
    value: function isConstant() {
      return false;
    }
  }, {
    key: "visitExpression",
    value: function visitExpression(visitor, context) {
      return visitor.visitTaggedTemplateExpr(this, context);
    }
  }]);

  return TaggedTemplateExpr;
}(Expression);

var InstantiateExpr = /*#__PURE__*/function (_Expression9) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(InstantiateExpr, _Expression9);

  var _super14 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(InstantiateExpr);

  function InstantiateExpr(classExpr, args, type, sourceSpan) {
    var _this18;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, InstantiateExpr);

    _this18 = _super14.call(this, type, sourceSpan);
    _this18.classExpr = classExpr;
    _this18.args = args;
    return _this18;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(InstantiateExpr, [{
    key: "isEquivalent",
    value: function isEquivalent(e) {
      return e instanceof InstantiateExpr && this.classExpr.isEquivalent(e.classExpr) && areAllEquivalent(this.args, e.args);
    }
  }, {
    key: "isConstant",
    value: function isConstant() {
      return false;
    }
  }, {
    key: "visitExpression",
    value: function visitExpression(visitor, context) {
      return visitor.visitInstantiateExpr(this, context);
    }
  }]);

  return InstantiateExpr;
}(Expression);

var LiteralExpr = /*#__PURE__*/function (_Expression10) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(LiteralExpr, _Expression10);

  var _super15 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(LiteralExpr);

  function LiteralExpr(value, type, sourceSpan) {
    var _this19;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, LiteralExpr);

    _this19 = _super15.call(this, type, sourceSpan);
    _this19.value = value;
    return _this19;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(LiteralExpr, [{
    key: "isEquivalent",
    value: function isEquivalent(e) {
      return e instanceof LiteralExpr && this.value === e.value;
    }
  }, {
    key: "isConstant",
    value: function isConstant() {
      return true;
    }
  }, {
    key: "visitExpression",
    value: function visitExpression(visitor, context) {
      return visitor.visitLiteralExpr(this, context);
    }
  }]);

  return LiteralExpr;
}(Expression);

var TemplateLiteral = /*#__PURE__*/(0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(function TemplateLiteral(elements, expressions) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, TemplateLiteral);

  this.elements = elements;
  this.expressions = expressions;
});

var TemplateLiteralElement = /*#__PURE__*/(0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(function TemplateLiteralElement(text, sourceSpan, rawText) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, TemplateLiteralElement);

  var _a;

  this.text = text;
  this.sourceSpan = sourceSpan; // If `rawText` is not provided, try to extract the raw string from its
  // associated `sourceSpan`. If that is also not available, "fake" the raw
  // string instead by escaping the following control sequences:
  // - "\" would otherwise indicate that the next character is a control character.
  // - "`" and "${" are template string control sequences that would otherwise prematurely
  // indicate the end of the template literal element.

  this.rawText = (_a = rawText !== null && rawText !== void 0 ? rawText : sourceSpan === null || sourceSpan === void 0 ? void 0 : sourceSpan.toString()) !== null && _a !== void 0 ? _a : escapeForTemplateLiteral(escapeSlashes(text));
});

var LiteralPiece = /*#__PURE__*/(0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(function LiteralPiece(text, sourceSpan) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, LiteralPiece);

  this.text = text;
  this.sourceSpan = sourceSpan;
});

var PlaceholderPiece = /*#__PURE__*/(0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(
/**
 * Create a new instance of a `PlaceholderPiece`.
 *
 * @param text the name of this placeholder (e.g. `PH_1`).
 * @param sourceSpan the location of this placeholder in its localized message the source code.
 * @param associatedMessage reference to another message that this placeholder is associated with.
 * The `associatedMessage` is mainly used to provide a relationship to an ICU message that has
 * been extracted out from the message containing the placeholder.
 */
function PlaceholderPiece(text, sourceSpan, associatedMessage) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, PlaceholderPiece);

  this.text = text;
  this.sourceSpan = sourceSpan;
  this.associatedMessage = associatedMessage;
});

var MEANING_SEPARATOR$1 = '|';
var ID_SEPARATOR$1 = '@@';
var LEGACY_ID_INDICATOR = '␟';

var LocalizedString = /*#__PURE__*/function (_Expression11) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(LocalizedString, _Expression11);

  var _super16 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(LocalizedString);

  function LocalizedString(metaBlock, messageParts, placeHolderNames, expressions, sourceSpan) {
    var _this20;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, LocalizedString);

    _this20 = _super16.call(this, STRING_TYPE, sourceSpan);
    _this20.metaBlock = metaBlock;
    _this20.messageParts = messageParts;
    _this20.placeHolderNames = placeHolderNames;
    _this20.expressions = expressions;
    return _this20;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(LocalizedString, [{
    key: "isEquivalent",
    value: function isEquivalent(e) {
      // return e instanceof LocalizedString && this.message === e.message;
      return false;
    }
  }, {
    key: "isConstant",
    value: function isConstant() {
      return false;
    }
  }, {
    key: "visitExpression",
    value: function visitExpression(visitor, context) {
      return visitor.visitLocalizedString(this, context);
    }
    /**
     * Serialize the given `meta` and `messagePart` into "cooked" and "raw" strings that can be used
     * in a `$localize` tagged string. The format of the metadata is the same as that parsed by
     * `parseI18nMeta()`.
     *
     * @param meta The metadata to serialize
     * @param messagePart The first part of the tagged string
     */

  }, {
    key: "serializeI18nHead",
    value: function serializeI18nHead() {
      var metaBlock = this.metaBlock.description || '';

      if (this.metaBlock.meaning) {
        metaBlock = "".concat(this.metaBlock.meaning).concat(MEANING_SEPARATOR$1).concat(metaBlock);
      }

      if (this.metaBlock.customId) {
        metaBlock = "".concat(metaBlock).concat(ID_SEPARATOR$1).concat(this.metaBlock.customId);
      }

      if (this.metaBlock.legacyIds) {
        this.metaBlock.legacyIds.forEach(function (legacyId) {
          metaBlock = "".concat(metaBlock).concat(LEGACY_ID_INDICATOR).concat(legacyId);
        });
      }

      return createCookedRawString(metaBlock, this.messageParts[0].text, this.getMessagePartSourceSpan(0));
    }
  }, {
    key: "getMessagePartSourceSpan",
    value: function getMessagePartSourceSpan(i) {
      var _a, _b;

      return (_b = (_a = this.messageParts[i]) === null || _a === void 0 ? void 0 : _a.sourceSpan) !== null && _b !== void 0 ? _b : this.sourceSpan;
    }
  }, {
    key: "getPlaceholderSourceSpan",
    value: function getPlaceholderSourceSpan(i) {
      var _a, _b, _c, _d;

      return (_d = (_b = (_a = this.placeHolderNames[i]) === null || _a === void 0 ? void 0 : _a.sourceSpan) !== null && _b !== void 0 ? _b : (_c = this.expressions[i]) === null || _c === void 0 ? void 0 : _c.sourceSpan) !== null && _d !== void 0 ? _d : this.sourceSpan;
    }
    /**
     * Serialize the given `placeholderName` and `messagePart` into "cooked" and "raw" strings that
     * can be used in a `$localize` tagged string.
     *
     * The format is `:<placeholder-name>[@@<associated-id>]:`.
     *
     * The `associated-id` is the message id of the (usually an ICU) message to which this placeholder
     * refers.
     *
     * @param partIndex The index of the message part to serialize.
     */

  }, {
    key: "serializeI18nTemplatePart",
    value: function serializeI18nTemplatePart(partIndex) {
      var _a;

      var placeholder = this.placeHolderNames[partIndex - 1];
      var messagePart = this.messageParts[partIndex];
      var metaBlock = placeholder.text;

      if (((_a = placeholder.associatedMessage) === null || _a === void 0 ? void 0 : _a.legacyIds.length) === 0) {
        metaBlock += "".concat(ID_SEPARATOR$1).concat(computeMsgId(placeholder.associatedMessage.messageString, placeholder.associatedMessage.meaning));
      }

      return createCookedRawString(metaBlock, messagePart.text, this.getMessagePartSourceSpan(partIndex));
    }
  }]);

  return LocalizedString;
}(Expression);

var escapeSlashes = function escapeSlashes(str) {
  return str.replace(/\\/g, '\\\\');
};

var escapeStartingColon = function escapeStartingColon(str) {
  return str.replace(/^:/, '\\:');
};

var escapeColons = function escapeColons(str) {
  return str.replace(/:/g, '\\:');
};

var escapeForTemplateLiteral = function escapeForTemplateLiteral(str) {
  return str.replace(/`/g, '\\`').replace(/\${/g, '$\\{');
};
/**
 * Creates a `{cooked, raw}` object from the `metaBlock` and `messagePart`.
 *
 * The `raw` text must have various character sequences escaped:
 * * "\" would otherwise indicate that the next character is a control character.
 * * "`" and "${" are template string control sequences that would otherwise prematurely indicate
 *   the end of a message part.
 * * ":" inside a metablock would prematurely indicate the end of the metablock.
 * * ":" at the start of a messagePart with no metablock would erroneously indicate the start of a
 *   metablock.
 *
 * @param metaBlock Any metadata that should be prepended to the string
 * @param messagePart The message part of the string
 */


function createCookedRawString(metaBlock, messagePart, range) {
  if (metaBlock === '') {
    return {
      cooked: messagePart,
      raw: escapeForTemplateLiteral(escapeStartingColon(escapeSlashes(messagePart))),
      range: range
    };
  } else {
    return {
      cooked: ":".concat(metaBlock, ":").concat(messagePart),
      raw: escapeForTemplateLiteral(":".concat(escapeColons(escapeSlashes(metaBlock)), ":").concat(escapeSlashes(messagePart))),
      range: range
    };
  }
}

var ExternalExpr = /*#__PURE__*/function (_Expression12) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(ExternalExpr, _Expression12);

  var _super17 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(ExternalExpr);

  function ExternalExpr(value, type) {
    var _this21;

    var typeParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var sourceSpan = arguments.length > 3 ? arguments[3] : undefined;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, ExternalExpr);

    _this21 = _super17.call(this, type, sourceSpan);
    _this21.value = value;
    _this21.typeParams = typeParams;
    return _this21;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(ExternalExpr, [{
    key: "isEquivalent",
    value: function isEquivalent(e) {
      return e instanceof ExternalExpr && this.value.name === e.value.name && this.value.moduleName === e.value.moduleName && this.value.runtime === e.value.runtime;
    }
  }, {
    key: "isConstant",
    value: function isConstant() {
      return false;
    }
  }, {
    key: "visitExpression",
    value: function visitExpression(visitor, context) {
      return visitor.visitExternalExpr(this, context);
    }
  }]);

  return ExternalExpr;
}(Expression);

var ExternalReference = /*#__PURE__*/(0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(function ExternalReference(moduleName, name, runtime) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, ExternalReference);

  this.moduleName = moduleName;
  this.name = name;
  this.runtime = runtime;
});

var ConditionalExpr = /*#__PURE__*/function (_Expression13) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(ConditionalExpr, _Expression13);

  var _super18 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(ConditionalExpr);

  function ConditionalExpr(condition, trueCase) {
    var _this22;

    var falseCase = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var type = arguments.length > 3 ? arguments[3] : undefined;
    var sourceSpan = arguments.length > 4 ? arguments[4] : undefined;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, ConditionalExpr);

    _this22 = _super18.call(this, type || trueCase.type, sourceSpan);
    _this22.condition = condition;
    _this22.falseCase = falseCase;
    _this22.trueCase = trueCase;
    return _this22;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(ConditionalExpr, [{
    key: "isEquivalent",
    value: function isEquivalent(e) {
      return e instanceof ConditionalExpr && this.condition.isEquivalent(e.condition) && this.trueCase.isEquivalent(e.trueCase) && nullSafeIsEquivalent(this.falseCase, e.falseCase);
    }
  }, {
    key: "isConstant",
    value: function isConstant() {
      return false;
    }
  }, {
    key: "visitExpression",
    value: function visitExpression(visitor, context) {
      return visitor.visitConditionalExpr(this, context);
    }
  }]);

  return ConditionalExpr;
}(Expression);

var NotExpr = /*#__PURE__*/function (_Expression14) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(NotExpr, _Expression14);

  var _super19 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(NotExpr);

  function NotExpr(condition, sourceSpan) {
    var _this23;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, NotExpr);

    _this23 = _super19.call(this, BOOL_TYPE, sourceSpan);
    _this23.condition = condition;
    return _this23;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(NotExpr, [{
    key: "isEquivalent",
    value: function isEquivalent(e) {
      return e instanceof NotExpr && this.condition.isEquivalent(e.condition);
    }
  }, {
    key: "isConstant",
    value: function isConstant() {
      return false;
    }
  }, {
    key: "visitExpression",
    value: function visitExpression(visitor, context) {
      return visitor.visitNotExpr(this, context);
    }
  }]);

  return NotExpr;
}(Expression);

var FnParam = /*#__PURE__*/function () {
  function FnParam(name) {
    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, FnParam);

    this.name = name;
    this.type = type;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(FnParam, [{
    key: "isEquivalent",
    value: function isEquivalent(param) {
      return this.name === param.name;
    }
  }]);

  return FnParam;
}();

var FunctionExpr = /*#__PURE__*/function (_Expression15) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(FunctionExpr, _Expression15);

  var _super20 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(FunctionExpr);

  function FunctionExpr(params, statements, type, sourceSpan, name) {
    var _this24;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, FunctionExpr);

    _this24 = _super20.call(this, type, sourceSpan);
    _this24.params = params;
    _this24.statements = statements;
    _this24.name = name;
    return _this24;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(FunctionExpr, [{
    key: "isEquivalent",
    value: function isEquivalent(e) {
      return e instanceof FunctionExpr && areAllEquivalent(this.params, e.params) && areAllEquivalent(this.statements, e.statements);
    }
  }, {
    key: "isConstant",
    value: function isConstant() {
      return false;
    }
  }, {
    key: "visitExpression",
    value: function visitExpression(visitor, context) {
      return visitor.visitFunctionExpr(this, context);
    }
  }, {
    key: "toDeclStmt",
    value: function toDeclStmt(name, modifiers) {
      return new DeclareFunctionStmt(name, this.params, this.statements, this.type, modifiers, this.sourceSpan);
    }
  }]);

  return FunctionExpr;
}(Expression);

var UnaryOperatorExpr = /*#__PURE__*/function (_Expression16) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(UnaryOperatorExpr, _Expression16);

  var _super21 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(UnaryOperatorExpr);

  function UnaryOperatorExpr(operator, expr, type, sourceSpan) {
    var _this25;

    var parens = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, UnaryOperatorExpr);

    _this25 = _super21.call(this, type || NUMBER_TYPE, sourceSpan);
    _this25.operator = operator;
    _this25.expr = expr;
    _this25.parens = parens;
    return _this25;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(UnaryOperatorExpr, [{
    key: "isEquivalent",
    value: function isEquivalent(e) {
      return e instanceof UnaryOperatorExpr && this.operator === e.operator && this.expr.isEquivalent(e.expr);
    }
  }, {
    key: "isConstant",
    value: function isConstant() {
      return false;
    }
  }, {
    key: "visitExpression",
    value: function visitExpression(visitor, context) {
      return visitor.visitUnaryOperatorExpr(this, context);
    }
  }]);

  return UnaryOperatorExpr;
}(Expression);

var BinaryOperatorExpr = /*#__PURE__*/function (_Expression17) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(BinaryOperatorExpr, _Expression17);

  var _super22 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(BinaryOperatorExpr);

  function BinaryOperatorExpr(operator, lhs, rhs, type, sourceSpan) {
    var _this26;

    var parens = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, BinaryOperatorExpr);

    _this26 = _super22.call(this, type || lhs.type, sourceSpan);
    _this26.operator = operator;
    _this26.rhs = rhs;
    _this26.parens = parens;
    _this26.lhs = lhs;
    return _this26;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(BinaryOperatorExpr, [{
    key: "isEquivalent",
    value: function isEquivalent(e) {
      return e instanceof BinaryOperatorExpr && this.operator === e.operator && this.lhs.isEquivalent(e.lhs) && this.rhs.isEquivalent(e.rhs);
    }
  }, {
    key: "isConstant",
    value: function isConstant() {
      return false;
    }
  }, {
    key: "visitExpression",
    value: function visitExpression(visitor, context) {
      return visitor.visitBinaryOperatorExpr(this, context);
    }
  }]);

  return BinaryOperatorExpr;
}(Expression);

var ReadPropExpr = /*#__PURE__*/function (_Expression18) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(ReadPropExpr, _Expression18);

  var _super23 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(ReadPropExpr);

  function ReadPropExpr(receiver, name, type, sourceSpan) {
    var _this27;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, ReadPropExpr);

    _this27 = _super23.call(this, type, sourceSpan);
    _this27.receiver = receiver;
    _this27.name = name;
    return _this27;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(ReadPropExpr, [{
    key: "isEquivalent",
    value: function isEquivalent(e) {
      return e instanceof ReadPropExpr && this.receiver.isEquivalent(e.receiver) && this.name === e.name;
    }
  }, {
    key: "isConstant",
    value: function isConstant() {
      return false;
    }
  }, {
    key: "visitExpression",
    value: function visitExpression(visitor, context) {
      return visitor.visitReadPropExpr(this, context);
    }
  }, {
    key: "set",
    value: function set(value) {
      return new WritePropExpr(this.receiver, this.name, value, null, this.sourceSpan);
    }
  }]);

  return ReadPropExpr;
}(Expression);

var ReadKeyExpr = /*#__PURE__*/function (_Expression19) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(ReadKeyExpr, _Expression19);

  var _super24 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(ReadKeyExpr);

  function ReadKeyExpr(receiver, index, type, sourceSpan) {
    var _this28;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, ReadKeyExpr);

    _this28 = _super24.call(this, type, sourceSpan);
    _this28.receiver = receiver;
    _this28.index = index;
    return _this28;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(ReadKeyExpr, [{
    key: "isEquivalent",
    value: function isEquivalent(e) {
      return e instanceof ReadKeyExpr && this.receiver.isEquivalent(e.receiver) && this.index.isEquivalent(e.index);
    }
  }, {
    key: "isConstant",
    value: function isConstant() {
      return false;
    }
  }, {
    key: "visitExpression",
    value: function visitExpression(visitor, context) {
      return visitor.visitReadKeyExpr(this, context);
    }
  }, {
    key: "set",
    value: function set(value) {
      return new WriteKeyExpr(this.receiver, this.index, value, null, this.sourceSpan);
    }
  }]);

  return ReadKeyExpr;
}(Expression);

var LiteralArrayExpr = /*#__PURE__*/function (_Expression20) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(LiteralArrayExpr, _Expression20);

  var _super25 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(LiteralArrayExpr);

  function LiteralArrayExpr(entries, type, sourceSpan) {
    var _this29;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, LiteralArrayExpr);

    _this29 = _super25.call(this, type, sourceSpan);
    _this29.entries = entries;
    return _this29;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(LiteralArrayExpr, [{
    key: "isConstant",
    value: function isConstant() {
      return this.entries.every(function (e) {
        return e.isConstant();
      });
    }
  }, {
    key: "isEquivalent",
    value: function isEquivalent(e) {
      return e instanceof LiteralArrayExpr && areAllEquivalent(this.entries, e.entries);
    }
  }, {
    key: "visitExpression",
    value: function visitExpression(visitor, context) {
      return visitor.visitLiteralArrayExpr(this, context);
    }
  }]);

  return LiteralArrayExpr;
}(Expression);

var LiteralMapEntry = /*#__PURE__*/function () {
  function LiteralMapEntry(key, value, quoted) {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, LiteralMapEntry);

    this.key = key;
    this.value = value;
    this.quoted = quoted;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(LiteralMapEntry, [{
    key: "isEquivalent",
    value: function isEquivalent(e) {
      return this.key === e.key && this.value.isEquivalent(e.value);
    }
  }]);

  return LiteralMapEntry;
}();

var LiteralMapExpr = /*#__PURE__*/function (_Expression21) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(LiteralMapExpr, _Expression21);

  var _super26 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(LiteralMapExpr);

  function LiteralMapExpr(entries, type, sourceSpan) {
    var _this30;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, LiteralMapExpr);

    _this30 = _super26.call(this, type, sourceSpan);
    _this30.entries = entries;
    _this30.valueType = null;

    if (type) {
      _this30.valueType = type.valueType;
    }

    return _this30;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(LiteralMapExpr, [{
    key: "isEquivalent",
    value: function isEquivalent(e) {
      return e instanceof LiteralMapExpr && areAllEquivalent(this.entries, e.entries);
    }
  }, {
    key: "isConstant",
    value: function isConstant() {
      return this.entries.every(function (e) {
        return e.value.isConstant();
      });
    }
  }, {
    key: "visitExpression",
    value: function visitExpression(visitor, context) {
      return visitor.visitLiteralMapExpr(this, context);
    }
  }]);

  return LiteralMapExpr;
}(Expression);

var CommaExpr = /*#__PURE__*/function (_Expression22) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(CommaExpr, _Expression22);

  var _super27 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(CommaExpr);

  function CommaExpr(parts, sourceSpan) {
    var _this31;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, CommaExpr);

    _this31 = _super27.call(this, parts[parts.length - 1].type, sourceSpan);
    _this31.parts = parts;
    return _this31;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(CommaExpr, [{
    key: "isEquivalent",
    value: function isEquivalent(e) {
      return e instanceof CommaExpr && areAllEquivalent(this.parts, e.parts);
    }
  }, {
    key: "isConstant",
    value: function isConstant() {
      return false;
    }
  }, {
    key: "visitExpression",
    value: function visitExpression(visitor, context) {
      return visitor.visitCommaExpr(this, context);
    }
  }]);

  return CommaExpr;
}(Expression);

var NULL_EXPR = new LiteralExpr(null, null, null);
var TYPED_NULL_EXPR = new LiteralExpr(null, INFERRED_TYPE, null); //// Statements

var StmtModifier;

(function (StmtModifier) {
  StmtModifier[StmtModifier["None"] = 0] = "None";
  StmtModifier[StmtModifier["Final"] = 1] = "Final";
  StmtModifier[StmtModifier["Private"] = 2] = "Private";
  StmtModifier[StmtModifier["Exported"] = 4] = "Exported";
  StmtModifier[StmtModifier["Static"] = 8] = "Static";
})(StmtModifier || (StmtModifier = {}));

var LeadingComment = /*#__PURE__*/function () {
  function LeadingComment(text, multiline, trailingNewline) {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, LeadingComment);

    this.text = text;
    this.multiline = multiline;
    this.trailingNewline = trailingNewline;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(LeadingComment, [{
    key: "toString",
    value: function toString() {
      return this.multiline ? " ".concat(this.text, " ") : this.text;
    }
  }]);

  return LeadingComment;
}();

var JSDocComment = /*#__PURE__*/function (_LeadingComment) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(JSDocComment, _LeadingComment);

  var _super28 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(JSDocComment);

  function JSDocComment(tags) {
    var _this32;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, JSDocComment);

    _this32 = _super28.call(this, '',
    /* multiline */
    true,
    /* trailingNewline */
    true);
    _this32.tags = tags;
    return _this32;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(JSDocComment, [{
    key: "toString",
    value: function toString() {
      return serializeTags(this.tags);
    }
  }]);

  return JSDocComment;
}(LeadingComment);

var Statement = /*#__PURE__*/function () {
  function Statement() {
    var modifiers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : StmtModifier.None;
    var sourceSpan = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var leadingComments = arguments.length > 2 ? arguments[2] : undefined;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, Statement);

    this.modifiers = modifiers;
    this.sourceSpan = sourceSpan;
    this.leadingComments = leadingComments;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(Statement, [{
    key: "hasModifier",
    value: function hasModifier(modifier) {
      return (this.modifiers & modifier) !== 0;
    }
  }, {
    key: "addLeadingComment",
    value: function addLeadingComment(leadingComment) {
      var _a;

      this.leadingComments = (_a = this.leadingComments) !== null && _a !== void 0 ? _a : [];
      this.leadingComments.push(leadingComment);
    }
  }]);

  return Statement;
}();

var DeclareVarStmt = /*#__PURE__*/function (_Statement) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(DeclareVarStmt, _Statement);

  var _super29 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(DeclareVarStmt);

  function DeclareVarStmt(name, value, type, modifiers, sourceSpan, leadingComments) {
    var _this33;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, DeclareVarStmt);

    _this33 = _super29.call(this, modifiers, sourceSpan, leadingComments);
    _this33.name = name;
    _this33.value = value;
    _this33.type = type || value && value.type || null;
    return _this33;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(DeclareVarStmt, [{
    key: "isEquivalent",
    value: function isEquivalent(stmt) {
      return stmt instanceof DeclareVarStmt && this.name === stmt.name && (this.value ? !!stmt.value && this.value.isEquivalent(stmt.value) : !stmt.value);
    }
  }, {
    key: "visitStatement",
    value: function visitStatement(visitor, context) {
      return visitor.visitDeclareVarStmt(this, context);
    }
  }]);

  return DeclareVarStmt;
}(Statement);

var DeclareFunctionStmt = /*#__PURE__*/function (_Statement2) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(DeclareFunctionStmt, _Statement2);

  var _super30 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(DeclareFunctionStmt);

  function DeclareFunctionStmt(name, params, statements, type, modifiers, sourceSpan, leadingComments) {
    var _this34;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, DeclareFunctionStmt);

    _this34 = _super30.call(this, modifiers, sourceSpan, leadingComments);
    _this34.name = name;
    _this34.params = params;
    _this34.statements = statements;
    _this34.type = type || null;
    return _this34;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(DeclareFunctionStmt, [{
    key: "isEquivalent",
    value: function isEquivalent(stmt) {
      return stmt instanceof DeclareFunctionStmt && areAllEquivalent(this.params, stmt.params) && areAllEquivalent(this.statements, stmt.statements);
    }
  }, {
    key: "visitStatement",
    value: function visitStatement(visitor, context) {
      return visitor.visitDeclareFunctionStmt(this, context);
    }
  }]);

  return DeclareFunctionStmt;
}(Statement);

var ExpressionStatement = /*#__PURE__*/function (_Statement3) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(ExpressionStatement, _Statement3);

  var _super31 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(ExpressionStatement);

  function ExpressionStatement(expr, sourceSpan, leadingComments) {
    var _this35;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, ExpressionStatement);

    _this35 = _super31.call(this, StmtModifier.None, sourceSpan, leadingComments);
    _this35.expr = expr;
    return _this35;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(ExpressionStatement, [{
    key: "isEquivalent",
    value: function isEquivalent(stmt) {
      return stmt instanceof ExpressionStatement && this.expr.isEquivalent(stmt.expr);
    }
  }, {
    key: "visitStatement",
    value: function visitStatement(visitor, context) {
      return visitor.visitExpressionStmt(this, context);
    }
  }]);

  return ExpressionStatement;
}(Statement);

var ReturnStatement = /*#__PURE__*/function (_Statement4) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(ReturnStatement, _Statement4);

  var _super32 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(ReturnStatement);

  function ReturnStatement(value) {
    var _this36;

    var sourceSpan = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var leadingComments = arguments.length > 2 ? arguments[2] : undefined;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, ReturnStatement);

    _this36 = _super32.call(this, StmtModifier.None, sourceSpan, leadingComments);
    _this36.value = value;
    return _this36;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(ReturnStatement, [{
    key: "isEquivalent",
    value: function isEquivalent(stmt) {
      return stmt instanceof ReturnStatement && this.value.isEquivalent(stmt.value);
    }
  }, {
    key: "visitStatement",
    value: function visitStatement(visitor, context) {
      return visitor.visitReturnStmt(this, context);
    }
  }]);

  return ReturnStatement;
}(Statement);

var IfStmt = /*#__PURE__*/function (_Statement5) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(IfStmt, _Statement5);

  var _super33 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(IfStmt);

  function IfStmt(condition, trueCase) {
    var _this37;

    var falseCase = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    var sourceSpan = arguments.length > 3 ? arguments[3] : undefined;
    var leadingComments = arguments.length > 4 ? arguments[4] : undefined;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, IfStmt);

    _this37 = _super33.call(this, StmtModifier.None, sourceSpan, leadingComments);
    _this37.condition = condition;
    _this37.trueCase = trueCase;
    _this37.falseCase = falseCase;
    return _this37;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(IfStmt, [{
    key: "isEquivalent",
    value: function isEquivalent(stmt) {
      return stmt instanceof IfStmt && this.condition.isEquivalent(stmt.condition) && areAllEquivalent(this.trueCase, stmt.trueCase) && areAllEquivalent(this.falseCase, stmt.falseCase);
    }
  }, {
    key: "visitStatement",
    value: function visitStatement(visitor, context) {
      return visitor.visitIfStmt(this, context);
    }
  }]);

  return IfStmt;
}(Statement);

var RecursiveAstVisitor$1 = /*#__PURE__*/function () {
  function RecursiveAstVisitor$1() {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, RecursiveAstVisitor$1);
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(RecursiveAstVisitor$1, [{
    key: "visitType",
    value: function visitType(ast, context) {
      return ast;
    }
  }, {
    key: "visitExpression",
    value: function visitExpression(ast, context) {
      if (ast.type) {
        ast.type.visitType(this, context);
      }

      return ast;
    }
  }, {
    key: "visitBuiltinType",
    value: function visitBuiltinType(type, context) {
      return this.visitType(type, context);
    }
  }, {
    key: "visitExpressionType",
    value: function visitExpressionType(type, context) {
      var _this38 = this;

      type.value.visitExpression(this, context);

      if (type.typeParams !== null) {
        type.typeParams.forEach(function (param) {
          return _this38.visitType(param, context);
        });
      }

      return this.visitType(type, context);
    }
  }, {
    key: "visitArrayType",
    value: function visitArrayType(type, context) {
      return this.visitType(type, context);
    }
  }, {
    key: "visitMapType",
    value: function visitMapType(type, context) {
      return this.visitType(type, context);
    }
  }, {
    key: "visitWrappedNodeExpr",
    value: function visitWrappedNodeExpr(ast, context) {
      return ast;
    }
  }, {
    key: "visitTypeofExpr",
    value: function visitTypeofExpr(ast, context) {
      return this.visitExpression(ast, context);
    }
  }, {
    key: "visitReadVarExpr",
    value: function visitReadVarExpr(ast, context) {
      return this.visitExpression(ast, context);
    }
  }, {
    key: "visitWriteVarExpr",
    value: function visitWriteVarExpr(ast, context) {
      ast.value.visitExpression(this, context);
      return this.visitExpression(ast, context);
    }
  }, {
    key: "visitWriteKeyExpr",
    value: function visitWriteKeyExpr(ast, context) {
      ast.receiver.visitExpression(this, context);
      ast.index.visitExpression(this, context);
      ast.value.visitExpression(this, context);
      return this.visitExpression(ast, context);
    }
  }, {
    key: "visitWritePropExpr",
    value: function visitWritePropExpr(ast, context) {
      ast.receiver.visitExpression(this, context);
      ast.value.visitExpression(this, context);
      return this.visitExpression(ast, context);
    }
  }, {
    key: "visitInvokeFunctionExpr",
    value: function visitInvokeFunctionExpr(ast, context) {
      ast.fn.visitExpression(this, context);
      this.visitAllExpressions(ast.args, context);
      return this.visitExpression(ast, context);
    }
  }, {
    key: "visitTaggedTemplateExpr",
    value: function visitTaggedTemplateExpr(ast, context) {
      ast.tag.visitExpression(this, context);
      this.visitAllExpressions(ast.template.expressions, context);
      return this.visitExpression(ast, context);
    }
  }, {
    key: "visitInstantiateExpr",
    value: function visitInstantiateExpr(ast, context) {
      ast.classExpr.visitExpression(this, context);
      this.visitAllExpressions(ast.args, context);
      return this.visitExpression(ast, context);
    }
  }, {
    key: "visitLiteralExpr",
    value: function visitLiteralExpr(ast, context) {
      return this.visitExpression(ast, context);
    }
  }, {
    key: "visitLocalizedString",
    value: function visitLocalizedString(ast, context) {
      return this.visitExpression(ast, context);
    }
  }, {
    key: "visitExternalExpr",
    value: function visitExternalExpr(ast, context) {
      var _this39 = this;

      if (ast.typeParams) {
        ast.typeParams.forEach(function (type) {
          return type.visitType(_this39, context);
        });
      }

      return this.visitExpression(ast, context);
    }
  }, {
    key: "visitConditionalExpr",
    value: function visitConditionalExpr(ast, context) {
      ast.condition.visitExpression(this, context);
      ast.trueCase.visitExpression(this, context);
      ast.falseCase.visitExpression(this, context);
      return this.visitExpression(ast, context);
    }
  }, {
    key: "visitNotExpr",
    value: function visitNotExpr(ast, context) {
      ast.condition.visitExpression(this, context);
      return this.visitExpression(ast, context);
    }
  }, {
    key: "visitFunctionExpr",
    value: function visitFunctionExpr(ast, context) {
      this.visitAllStatements(ast.statements, context);
      return this.visitExpression(ast, context);
    }
  }, {
    key: "visitUnaryOperatorExpr",
    value: function visitUnaryOperatorExpr(ast, context) {
      ast.expr.visitExpression(this, context);
      return this.visitExpression(ast, context);
    }
  }, {
    key: "visitBinaryOperatorExpr",
    value: function visitBinaryOperatorExpr(ast, context) {
      ast.lhs.visitExpression(this, context);
      ast.rhs.visitExpression(this, context);
      return this.visitExpression(ast, context);
    }
  }, {
    key: "visitReadPropExpr",
    value: function visitReadPropExpr(ast, context) {
      ast.receiver.visitExpression(this, context);
      return this.visitExpression(ast, context);
    }
  }, {
    key: "visitReadKeyExpr",
    value: function visitReadKeyExpr(ast, context) {
      ast.receiver.visitExpression(this, context);
      ast.index.visitExpression(this, context);
      return this.visitExpression(ast, context);
    }
  }, {
    key: "visitLiteralArrayExpr",
    value: function visitLiteralArrayExpr(ast, context) {
      this.visitAllExpressions(ast.entries, context);
      return this.visitExpression(ast, context);
    }
  }, {
    key: "visitLiteralMapExpr",
    value: function visitLiteralMapExpr(ast, context) {
      var _this40 = this;

      ast.entries.forEach(function (entry) {
        return entry.value.visitExpression(_this40, context);
      });
      return this.visitExpression(ast, context);
    }
  }, {
    key: "visitCommaExpr",
    value: function visitCommaExpr(ast, context) {
      this.visitAllExpressions(ast.parts, context);
      return this.visitExpression(ast, context);
    }
  }, {
    key: "visitAllExpressions",
    value: function visitAllExpressions(exprs, context) {
      var _this41 = this;

      exprs.forEach(function (expr) {
        return expr.visitExpression(_this41, context);
      });
    }
  }, {
    key: "visitDeclareVarStmt",
    value: function visitDeclareVarStmt(stmt, context) {
      if (stmt.value) {
        stmt.value.visitExpression(this, context);
      }

      if (stmt.type) {
        stmt.type.visitType(this, context);
      }

      return stmt;
    }
  }, {
    key: "visitDeclareFunctionStmt",
    value: function visitDeclareFunctionStmt(stmt, context) {
      this.visitAllStatements(stmt.statements, context);

      if (stmt.type) {
        stmt.type.visitType(this, context);
      }

      return stmt;
    }
  }, {
    key: "visitExpressionStmt",
    value: function visitExpressionStmt(stmt, context) {
      stmt.expr.visitExpression(this, context);
      return stmt;
    }
  }, {
    key: "visitReturnStmt",
    value: function visitReturnStmt(stmt, context) {
      stmt.value.visitExpression(this, context);
      return stmt;
    }
  }, {
    key: "visitIfStmt",
    value: function visitIfStmt(stmt, context) {
      stmt.condition.visitExpression(this, context);
      this.visitAllStatements(stmt.trueCase, context);
      this.visitAllStatements(stmt.falseCase, context);
      return stmt;
    }
  }, {
    key: "visitAllStatements",
    value: function visitAllStatements(stmts, context) {
      var _this42 = this;

      stmts.forEach(function (stmt) {
        return stmt.visitStatement(_this42, context);
      });
    }
  }]);

  return RecursiveAstVisitor$1;
}();

function leadingComment(text) {
  var multiline = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var trailingNewline = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  return new LeadingComment(text, multiline, trailingNewline);
}

function jsDocComment() {
  var tags = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return new JSDocComment(tags);
}

function variable(name, type, sourceSpan) {
  return new ReadVarExpr(name, type, sourceSpan);
}

function importExpr(id) {
  var typeParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var sourceSpan = arguments.length > 2 ? arguments[2] : undefined;
  return new ExternalExpr(id, null, typeParams, sourceSpan);
}

function importType(id, typeParams, typeModifiers) {
  return id != null ? expressionType(importExpr(id, typeParams, null), typeModifiers) : null;
}

function expressionType(expr, typeModifiers, typeParams) {
  return new ExpressionType(expr, typeModifiers, typeParams);
}

function typeofExpr(expr) {
  return new TypeofExpr(expr);
}

function literalArr(values, type, sourceSpan) {
  return new LiteralArrayExpr(values, type, sourceSpan);
}

function literalMap(values) {
  var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  return new LiteralMapExpr(values.map(function (e) {
    return new LiteralMapEntry(e.key, e.value, e.quoted);
  }), type, null);
}

function unary(operator, expr, type, sourceSpan) {
  return new UnaryOperatorExpr(operator, expr, type, sourceSpan);
}

function not(expr, sourceSpan) {
  return new NotExpr(expr, sourceSpan);
}

function fn(params, body, type, sourceSpan, name) {
  return new FunctionExpr(params, body, type, sourceSpan, name);
}

function ifStmt(condition, thenClause, elseClause, sourceSpan, leadingComments) {
  return new IfStmt(condition, thenClause, elseClause, sourceSpan, leadingComments);
}

function taggedTemplate(tag, template, type, sourceSpan) {
  return new TaggedTemplateExpr(tag, template, type, sourceSpan);
}

function literal(value, type, sourceSpan) {
  return new LiteralExpr(value, type, sourceSpan);
}

function localizedString(metaBlock, messageParts, placeholderNames, expressions, sourceSpan) {
  return new LocalizedString(metaBlock, messageParts, placeholderNames, expressions, sourceSpan);
}

function isNull(exp) {
  return exp instanceof LiteralExpr && exp.value === null;
}
/*
 * Serializes a `Tag` into a string.
 * Returns a string like " @foo {bar} baz" (note the leading whitespace before `@foo`).
 */


function tagToString(tag) {
  var out = '';

  if (tag.tagName) {
    out += " @".concat(tag.tagName);
  }

  if (tag.text) {
    if (tag.text.match(/\/\*|\*\//)) {
      throw new Error('JSDoc text cannot contain "/*" and "*/"');
    }

    out += ' ' + tag.text.replace(/@/g, '\\@');
  }

  return out;
}

function serializeTags(tags) {
  if (tags.length === 0) return '';

  if (tags.length === 1 && tags[0].tagName && !tags[0].text) {
    // The JSDOC comment is a single simple tag: e.g `/** @tagname */`.
    return "*".concat(tagToString(tags[0]), " ");
  }

  var out = '*\n';

  var _iterator2 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper_js__WEBPACK_IMPORTED_MODULE_9__["default"])(tags),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var tag = _step2.value;
      out += ' *'; // If the tagToString is multi-line, insert " * " prefixes on lines.

      out += tagToString(tag).replace(/\n/g, '\n * ');
      out += '\n';
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  out += ' ';
  return out;
}

var output_ast = /*#__PURE__*/Object.freeze({
  __proto__: null,

  get TypeModifier() {
    return TypeModifier;
  },

  Type: Type,

  get BuiltinTypeName() {
    return BuiltinTypeName;
  },

  BuiltinType: BuiltinType,
  ExpressionType: ExpressionType,
  ArrayType: ArrayType,
  MapType: MapType,
  DYNAMIC_TYPE: DYNAMIC_TYPE,
  INFERRED_TYPE: INFERRED_TYPE,
  BOOL_TYPE: BOOL_TYPE,
  INT_TYPE: INT_TYPE,
  NUMBER_TYPE: NUMBER_TYPE,
  STRING_TYPE: STRING_TYPE,
  FUNCTION_TYPE: FUNCTION_TYPE,
  NONE_TYPE: NONE_TYPE,

  get UnaryOperator() {
    return UnaryOperator;
  },

  get BinaryOperator() {
    return BinaryOperator;
  },

  nullSafeIsEquivalent: nullSafeIsEquivalent,
  areAllEquivalent: areAllEquivalent,
  Expression: Expression,
  ReadVarExpr: ReadVarExpr,
  TypeofExpr: TypeofExpr,
  WrappedNodeExpr: WrappedNodeExpr,
  WriteVarExpr: WriteVarExpr,
  WriteKeyExpr: WriteKeyExpr,
  WritePropExpr: WritePropExpr,
  InvokeFunctionExpr: InvokeFunctionExpr,
  TaggedTemplateExpr: TaggedTemplateExpr,
  InstantiateExpr: InstantiateExpr,
  LiteralExpr: LiteralExpr,
  TemplateLiteral: TemplateLiteral,
  TemplateLiteralElement: TemplateLiteralElement,
  LiteralPiece: LiteralPiece,
  PlaceholderPiece: PlaceholderPiece,
  LocalizedString: LocalizedString,
  ExternalExpr: ExternalExpr,
  ExternalReference: ExternalReference,
  ConditionalExpr: ConditionalExpr,
  NotExpr: NotExpr,
  FnParam: FnParam,
  FunctionExpr: FunctionExpr,
  UnaryOperatorExpr: UnaryOperatorExpr,
  BinaryOperatorExpr: BinaryOperatorExpr,
  ReadPropExpr: ReadPropExpr,
  ReadKeyExpr: ReadKeyExpr,
  LiteralArrayExpr: LiteralArrayExpr,
  LiteralMapEntry: LiteralMapEntry,
  LiteralMapExpr: LiteralMapExpr,
  CommaExpr: CommaExpr,
  NULL_EXPR: NULL_EXPR,
  TYPED_NULL_EXPR: TYPED_NULL_EXPR,

  get StmtModifier() {
    return StmtModifier;
  },

  LeadingComment: LeadingComment,
  JSDocComment: JSDocComment,
  Statement: Statement,
  DeclareVarStmt: DeclareVarStmt,
  DeclareFunctionStmt: DeclareFunctionStmt,
  ExpressionStatement: ExpressionStatement,
  ReturnStatement: ReturnStatement,
  IfStmt: IfStmt,
  RecursiveAstVisitor: RecursiveAstVisitor$1,
  leadingComment: leadingComment,
  jsDocComment: jsDocComment,
  variable: variable,
  importExpr: importExpr,
  importType: importType,
  expressionType: expressionType,
  typeofExpr: typeofExpr,
  literalArr: literalArr,
  literalMap: literalMap,
  unary: unary,
  not: not,
  fn: fn,
  ifStmt: ifStmt,
  taggedTemplate: taggedTemplate,
  literal: literal,
  localizedString: localizedString,
  isNull: isNull
});
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

var CONSTANT_PREFIX = '_c';
/**
 * `ConstantPool` tries to reuse literal factories when two or more literals are identical.
 * We determine whether literals are identical by creating a key out of their AST using the
 * `KeyVisitor`. This constant is used to replace dynamic expressions which can't be safely
 * converted into a key. E.g. given an expression `{foo: bar()}`, since we don't know what
 * the result of `bar` will be, we create a key that looks like `{foo: <unknown>}`. Note
 * that we use a variable, rather than something like `null` in order to avoid collisions.
 */

var UNKNOWN_VALUE_KEY = variable('<unknown>');
/**
 * Context to use when producing a key.
 *
 * This ensures we see the constant not the reference variable when producing
 * a key.
 */

var KEY_CONTEXT = {};
/**
 * Generally all primitive values are excluded from the `ConstantPool`, but there is an exclusion
 * for strings that reach a certain length threshold. This constant defines the length threshold for
 * strings.
 */

var POOL_INCLUSION_LENGTH_THRESHOLD_FOR_STRINGS = 50;
/**
 * A node that is a place-holder that allows the node to be replaced when the actual
 * node is known.
 *
 * This allows the constant pool to change an expression from a direct reference to
 * a constant to a shared constant. It returns a fix-up node that is later allowed to
 * change the referenced expression.
 */

var FixupExpression = /*#__PURE__*/function (_Expression23) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(FixupExpression, _Expression23);

  var _super34 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(FixupExpression);

  function FixupExpression(resolved) {
    var _this43;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, FixupExpression);

    _this43 = _super34.call(this, resolved.type);
    _this43.resolved = resolved;
    _this43.original = resolved;
    return _this43;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(FixupExpression, [{
    key: "visitExpression",
    value: function visitExpression(visitor, context) {
      if (context === KEY_CONTEXT) {
        // When producing a key we want to traverse the constant not the
        // variable used to refer to it.
        return this.original.visitExpression(visitor, context);
      } else {
        return this.resolved.visitExpression(visitor, context);
      }
    }
  }, {
    key: "isEquivalent",
    value: function isEquivalent(e) {
      return e instanceof FixupExpression && this.resolved.isEquivalent(e.resolved);
    }
  }, {
    key: "isConstant",
    value: function isConstant() {
      return true;
    }
  }, {
    key: "fixup",
    value: function fixup(expression) {
      this.resolved = expression;
      this.shared = true;
    }
  }]);

  return FixupExpression;
}(Expression);
/**
 * A constant pool allows a code emitter to share constant in an output context.
 *
 * The constant pool also supports sharing access to ivy definitions references.
 */


var ConstantPool = /*#__PURE__*/function () {
  function ConstantPool() {
    var isClosureCompilerEnabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, ConstantPool);

    this.isClosureCompilerEnabled = isClosureCompilerEnabled;
    this.statements = [];
    this.literals = new Map();
    this.literalFactories = new Map();
    this.nextNameIndex = 0;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(ConstantPool, [{
    key: "getConstLiteral",
    value: function getConstLiteral(literal, forceShared) {
      if (literal instanceof LiteralExpr && !isLongStringLiteral(literal) || literal instanceof FixupExpression) {
        // Do no put simple literals into the constant pool or try to produce a constant for a
        // reference to a constant.
        return literal;
      }

      var key = this.keyOf(literal);
      var fixup = this.literals.get(key);
      var newValue = false;

      if (!fixup) {
        fixup = new FixupExpression(literal);
        this.literals.set(key, fixup);
        newValue = true;
      }

      if (!newValue && !fixup.shared || newValue && forceShared) {
        // Replace the expression with a variable
        var name = this.freshName();
        var definition;
        var usage;

        if (this.isClosureCompilerEnabled && isLongStringLiteral(literal)) {
          // For string literals, Closure will **always** inline the string at
          // **all** usages, duplicating it each time. For large strings, this
          // unnecessarily bloats bundle size. To work around this restriction, we
          // wrap the string in a function, and call that function for each usage.
          // This tricks Closure into using inline logic for functions instead of
          // string literals. Function calls are only inlined if the body is small
          // enough to be worth it. By doing this, very large strings will be
          // shared across multiple usages, rather than duplicating the string at
          // each usage site.
          //
          // const myStr = function() { return "very very very long string"; };
          // const usage1 = myStr();
          // const usage2 = myStr();
          definition = variable(name).set(new FunctionExpr([], // Params.
          [// Statements.
          new ReturnStatement(literal)]));
          usage = variable(name).callFn([]);
        } else {
          // Just declare and use the variable directly, without a function call
          // indirection. This saves a few bytes and avoids an unncessary call.
          definition = variable(name).set(literal);
          usage = variable(name);
        }

        this.statements.push(definition.toDeclStmt(INFERRED_TYPE, StmtModifier.Final));
        fixup.fixup(usage);
      }

      return fixup;
    }
  }, {
    key: "getLiteralFactory",
    value: function getLiteralFactory(literal) {
      // Create a pure function that builds an array of a mix of constant and variable expressions
      if (literal instanceof LiteralArrayExpr) {
        var argumentsForKey = literal.entries.map(function (e) {
          return e.isConstant() ? e : UNKNOWN_VALUE_KEY;
        });
        var key = this.keyOf(literalArr(argumentsForKey));
        return this._getLiteralFactory(key, literal.entries, function (entries) {
          return literalArr(entries);
        });
      } else {
        var expressionForKey = literalMap(literal.entries.map(function (e) {
          return {
            key: e.key,
            value: e.value.isConstant() ? e.value : UNKNOWN_VALUE_KEY,
            quoted: e.quoted
          };
        }));

        var _key2 = this.keyOf(expressionForKey);

        return this._getLiteralFactory(_key2, literal.entries.map(function (e) {
          return e.value;
        }), function (entries) {
          return literalMap(entries.map(function (value, index) {
            return {
              key: literal.entries[index].key,
              value: value,
              quoted: literal.entries[index].quoted
            };
          }));
        });
      }
    }
  }, {
    key: "_getLiteralFactory",
    value: function _getLiteralFactory(key, values, resultMap) {
      var _this44 = this;

      var literalFactory = this.literalFactories.get(key);
      var literalFactoryArguments = values.filter(function (e) {
        return !e.isConstant();
      });

      if (!literalFactory) {
        var resultExpressions = values.map(function (e, index) {
          return e.isConstant() ? _this44.getConstLiteral(e, true) : variable("a".concat(index));
        });
        var parameters = resultExpressions.filter(isVariable).map(function (e) {
          return new FnParam(e.name, DYNAMIC_TYPE);
        });
        var pureFunctionDeclaration = fn(parameters, [new ReturnStatement(resultMap(resultExpressions))], INFERRED_TYPE);
        var name = this.freshName();
        this.statements.push(variable(name).set(pureFunctionDeclaration).toDeclStmt(INFERRED_TYPE, StmtModifier.Final));
        literalFactory = variable(name);
        this.literalFactories.set(key, literalFactory);
      }

      return {
        literalFactory: literalFactory,
        literalFactoryArguments: literalFactoryArguments
      };
    }
    /**
     * Produce a unique name.
     *
     * The name might be unique among different prefixes if any of the prefixes end in
     * a digit so the prefix should be a constant string (not based on user input) and
     * must not end in a digit.
     */

  }, {
    key: "uniqueName",
    value: function uniqueName(prefix) {
      return "".concat(prefix).concat(this.nextNameIndex++);
    }
  }, {
    key: "freshName",
    value: function freshName() {
      return this.uniqueName(CONSTANT_PREFIX);
    }
  }, {
    key: "keyOf",
    value: function keyOf(expression) {
      return expression.visitExpression(new KeyVisitor(), KEY_CONTEXT);
    }
  }]);

  return ConstantPool;
}();
/**
 * Visitor used to determine if 2 expressions are equivalent and can be shared in the
 * `ConstantPool`.
 *
 * When the id (string) generated by the visitor is equal, expressions are considered equivalent.
 */


var KeyVisitor = /*#__PURE__*/function () {
  function KeyVisitor() {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, KeyVisitor);

    this.visitWrappedNodeExpr = invalid$1;
    this.visitWriteVarExpr = invalid$1;
    this.visitWriteKeyExpr = invalid$1;
    this.visitWritePropExpr = invalid$1;
    this.visitInvokeFunctionExpr = invalid$1;
    this.visitTaggedTemplateExpr = invalid$1;
    this.visitInstantiateExpr = invalid$1;
    this.visitConditionalExpr = invalid$1;
    this.visitNotExpr = invalid$1;
    this.visitAssertNotNullExpr = invalid$1;
    this.visitCastExpr = invalid$1;
    this.visitFunctionExpr = invalid$1;
    this.visitUnaryOperatorExpr = invalid$1;
    this.visitBinaryOperatorExpr = invalid$1;
    this.visitReadPropExpr = invalid$1;
    this.visitReadKeyExpr = invalid$1;
    this.visitCommaExpr = invalid$1;
    this.visitLocalizedString = invalid$1;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(KeyVisitor, [{
    key: "visitLiteralExpr",
    value: function visitLiteralExpr(ast) {
      return "".concat(typeof ast.value === 'string' ? '"' + ast.value + '"' : ast.value);
    }
  }, {
    key: "visitLiteralArrayExpr",
    value: function visitLiteralArrayExpr(ast, context) {
      var _this45 = this;

      return "[".concat(ast.entries.map(function (entry) {
        return entry.visitExpression(_this45, context);
      }).join(','), "]");
    }
  }, {
    key: "visitLiteralMapExpr",
    value: function visitLiteralMapExpr(ast, context) {
      var _this46 = this;

      var mapKey = function mapKey(entry) {
        var quote = entry.quoted ? '"' : '';
        return "".concat(quote).concat(entry.key).concat(quote);
      };

      var mapEntry = function mapEntry(entry) {
        return "".concat(mapKey(entry), ":").concat(entry.value.visitExpression(_this46, context));
      };

      return "{".concat(ast.entries.map(mapEntry).join(','));
    }
  }, {
    key: "visitExternalExpr",
    value: function visitExternalExpr(ast) {
      return ast.value.moduleName ? "EX:".concat(ast.value.moduleName, ":").concat(ast.value.name) : "EX:".concat(ast.value.runtime.name);
    }
  }, {
    key: "visitReadVarExpr",
    value: function visitReadVarExpr(node) {
      return "VAR:".concat(node.name);
    }
  }, {
    key: "visitTypeofExpr",
    value: function visitTypeofExpr(node, context) {
      return "TYPEOF:".concat(node.expr.visitExpression(this, context));
    }
  }]);

  return KeyVisitor;
}();

function invalid$1(arg) {
  throw new Error("Invalid state: Visitor ".concat(this.constructor.name, " doesn't handle ").concat(arg.constructor.name));
}

function isVariable(e) {
  return e instanceof ReadVarExpr;
}

function isLongStringLiteral(expr) {
  return expr instanceof LiteralExpr && typeof expr.value === 'string' && expr.value.length >= POOL_INCLUSION_LENGTH_THRESHOLD_FOR_STRINGS;
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */


var CORE = '@angular/core';

var Identifiers = /*#__PURE__*/(0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(function Identifiers() {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, Identifiers);
});
/* Methods */


Identifiers.NEW_METHOD = 'factory';
Identifiers.TRANSFORM_METHOD = 'transform';
Identifiers.PATCH_DEPS = 'patchedDeps';
Identifiers.core = {
  name: null,
  moduleName: CORE
};
/* Instructions */

Identifiers.namespaceHTML = {
  name: 'ɵɵnamespaceHTML',
  moduleName: CORE
};
Identifiers.namespaceMathML = {
  name: 'ɵɵnamespaceMathML',
  moduleName: CORE
};
Identifiers.namespaceSVG = {
  name: 'ɵɵnamespaceSVG',
  moduleName: CORE
};
Identifiers.element = {
  name: 'ɵɵelement',
  moduleName: CORE
};
Identifiers.elementStart = {
  name: 'ɵɵelementStart',
  moduleName: CORE
};
Identifiers.elementEnd = {
  name: 'ɵɵelementEnd',
  moduleName: CORE
};
Identifiers.advance = {
  name: 'ɵɵadvance',
  moduleName: CORE
};
Identifiers.syntheticHostProperty = {
  name: 'ɵɵsyntheticHostProperty',
  moduleName: CORE
};
Identifiers.syntheticHostListener = {
  name: 'ɵɵsyntheticHostListener',
  moduleName: CORE
};
Identifiers.attribute = {
  name: 'ɵɵattribute',
  moduleName: CORE
};
Identifiers.attributeInterpolate1 = {
  name: 'ɵɵattributeInterpolate1',
  moduleName: CORE
};
Identifiers.attributeInterpolate2 = {
  name: 'ɵɵattributeInterpolate2',
  moduleName: CORE
};
Identifiers.attributeInterpolate3 = {
  name: 'ɵɵattributeInterpolate3',
  moduleName: CORE
};
Identifiers.attributeInterpolate4 = {
  name: 'ɵɵattributeInterpolate4',
  moduleName: CORE
};
Identifiers.attributeInterpolate5 = {
  name: 'ɵɵattributeInterpolate5',
  moduleName: CORE
};
Identifiers.attributeInterpolate6 = {
  name: 'ɵɵattributeInterpolate6',
  moduleName: CORE
};
Identifiers.attributeInterpolate7 = {
  name: 'ɵɵattributeInterpolate7',
  moduleName: CORE
};
Identifiers.attributeInterpolate8 = {
  name: 'ɵɵattributeInterpolate8',
  moduleName: CORE
};
Identifiers.attributeInterpolateV = {
  name: 'ɵɵattributeInterpolateV',
  moduleName: CORE
};
Identifiers.classProp = {
  name: 'ɵɵclassProp',
  moduleName: CORE
};
Identifiers.elementContainerStart = {
  name: 'ɵɵelementContainerStart',
  moduleName: CORE
};
Identifiers.elementContainerEnd = {
  name: 'ɵɵelementContainerEnd',
  moduleName: CORE
};
Identifiers.elementContainer = {
  name: 'ɵɵelementContainer',
  moduleName: CORE
};
Identifiers.styleMap = {
  name: 'ɵɵstyleMap',
  moduleName: CORE
};
Identifiers.styleMapInterpolate1 = {
  name: 'ɵɵstyleMapInterpolate1',
  moduleName: CORE
};
Identifiers.styleMapInterpolate2 = {
  name: 'ɵɵstyleMapInterpolate2',
  moduleName: CORE
};
Identifiers.styleMapInterpolate3 = {
  name: 'ɵɵstyleMapInterpolate3',
  moduleName: CORE
};
Identifiers.styleMapInterpolate4 = {
  name: 'ɵɵstyleMapInterpolate4',
  moduleName: CORE
};
Identifiers.styleMapInterpolate5 = {
  name: 'ɵɵstyleMapInterpolate5',
  moduleName: CORE
};
Identifiers.styleMapInterpolate6 = {
  name: 'ɵɵstyleMapInterpolate6',
  moduleName: CORE
};
Identifiers.styleMapInterpolate7 = {
  name: 'ɵɵstyleMapInterpolate7',
  moduleName: CORE
};
Identifiers.styleMapInterpolate8 = {
  name: 'ɵɵstyleMapInterpolate8',
  moduleName: CORE
};
Identifiers.styleMapInterpolateV = {
  name: 'ɵɵstyleMapInterpolateV',
  moduleName: CORE
};
Identifiers.classMap = {
  name: 'ɵɵclassMap',
  moduleName: CORE
};
Identifiers.classMapInterpolate1 = {
  name: 'ɵɵclassMapInterpolate1',
  moduleName: CORE
};
Identifiers.classMapInterpolate2 = {
  name: 'ɵɵclassMapInterpolate2',
  moduleName: CORE
};
Identifiers.classMapInterpolate3 = {
  name: 'ɵɵclassMapInterpolate3',
  moduleName: CORE
};
Identifiers.classMapInterpolate4 = {
  name: 'ɵɵclassMapInterpolate4',
  moduleName: CORE
};
Identifiers.classMapInterpolate5 = {
  name: 'ɵɵclassMapInterpolate5',
  moduleName: CORE
};
Identifiers.classMapInterpolate6 = {
  name: 'ɵɵclassMapInterpolate6',
  moduleName: CORE
};
Identifiers.classMapInterpolate7 = {
  name: 'ɵɵclassMapInterpolate7',
  moduleName: CORE
};
Identifiers.classMapInterpolate8 = {
  name: 'ɵɵclassMapInterpolate8',
  moduleName: CORE
};
Identifiers.classMapInterpolateV = {
  name: 'ɵɵclassMapInterpolateV',
  moduleName: CORE
};
Identifiers.styleProp = {
  name: 'ɵɵstyleProp',
  moduleName: CORE
};
Identifiers.stylePropInterpolate1 = {
  name: 'ɵɵstylePropInterpolate1',
  moduleName: CORE
};
Identifiers.stylePropInterpolate2 = {
  name: 'ɵɵstylePropInterpolate2',
  moduleName: CORE
};
Identifiers.stylePropInterpolate3 = {
  name: 'ɵɵstylePropInterpolate3',
  moduleName: CORE
};
Identifiers.stylePropInterpolate4 = {
  name: 'ɵɵstylePropInterpolate4',
  moduleName: CORE
};
Identifiers.stylePropInterpolate5 = {
  name: 'ɵɵstylePropInterpolate5',
  moduleName: CORE
};
Identifiers.stylePropInterpolate6 = {
  name: 'ɵɵstylePropInterpolate6',
  moduleName: CORE
};
Identifiers.stylePropInterpolate7 = {
  name: 'ɵɵstylePropInterpolate7',
  moduleName: CORE
};
Identifiers.stylePropInterpolate8 = {
  name: 'ɵɵstylePropInterpolate8',
  moduleName: CORE
};
Identifiers.stylePropInterpolateV = {
  name: 'ɵɵstylePropInterpolateV',
  moduleName: CORE
};
Identifiers.nextContext = {
  name: 'ɵɵnextContext',
  moduleName: CORE
};
Identifiers.resetView = {
  name: 'ɵɵresetView',
  moduleName: CORE
};
Identifiers.templateCreate = {
  name: 'ɵɵtemplate',
  moduleName: CORE
};
Identifiers.text = {
  name: 'ɵɵtext',
  moduleName: CORE
};
Identifiers.enableBindings = {
  name: 'ɵɵenableBindings',
  moduleName: CORE
};
Identifiers.disableBindings = {
  name: 'ɵɵdisableBindings',
  moduleName: CORE
};
Identifiers.getCurrentView = {
  name: 'ɵɵgetCurrentView',
  moduleName: CORE
};
Identifiers.textInterpolate = {
  name: 'ɵɵtextInterpolate',
  moduleName: CORE
};
Identifiers.textInterpolate1 = {
  name: 'ɵɵtextInterpolate1',
  moduleName: CORE
};
Identifiers.textInterpolate2 = {
  name: 'ɵɵtextInterpolate2',
  moduleName: CORE
};
Identifiers.textInterpolate3 = {
  name: 'ɵɵtextInterpolate3',
  moduleName: CORE
};
Identifiers.textInterpolate4 = {
  name: 'ɵɵtextInterpolate4',
  moduleName: CORE
};
Identifiers.textInterpolate5 = {
  name: 'ɵɵtextInterpolate5',
  moduleName: CORE
};
Identifiers.textInterpolate6 = {
  name: 'ɵɵtextInterpolate6',
  moduleName: CORE
};
Identifiers.textInterpolate7 = {
  name: 'ɵɵtextInterpolate7',
  moduleName: CORE
};
Identifiers.textInterpolate8 = {
  name: 'ɵɵtextInterpolate8',
  moduleName: CORE
};
Identifiers.textInterpolateV = {
  name: 'ɵɵtextInterpolateV',
  moduleName: CORE
};
Identifiers.restoreView = {
  name: 'ɵɵrestoreView',
  moduleName: CORE
};
Identifiers.pureFunction0 = {
  name: 'ɵɵpureFunction0',
  moduleName: CORE
};
Identifiers.pureFunction1 = {
  name: 'ɵɵpureFunction1',
  moduleName: CORE
};
Identifiers.pureFunction2 = {
  name: 'ɵɵpureFunction2',
  moduleName: CORE
};
Identifiers.pureFunction3 = {
  name: 'ɵɵpureFunction3',
  moduleName: CORE
};
Identifiers.pureFunction4 = {
  name: 'ɵɵpureFunction4',
  moduleName: CORE
};
Identifiers.pureFunction5 = {
  name: 'ɵɵpureFunction5',
  moduleName: CORE
};
Identifiers.pureFunction6 = {
  name: 'ɵɵpureFunction6',
  moduleName: CORE
};
Identifiers.pureFunction7 = {
  name: 'ɵɵpureFunction7',
  moduleName: CORE
};
Identifiers.pureFunction8 = {
  name: 'ɵɵpureFunction8',
  moduleName: CORE
};
Identifiers.pureFunctionV = {
  name: 'ɵɵpureFunctionV',
  moduleName: CORE
};
Identifiers.pipeBind1 = {
  name: 'ɵɵpipeBind1',
  moduleName: CORE
};
Identifiers.pipeBind2 = {
  name: 'ɵɵpipeBind2',
  moduleName: CORE
};
Identifiers.pipeBind3 = {
  name: 'ɵɵpipeBind3',
  moduleName: CORE
};
Identifiers.pipeBind4 = {
  name: 'ɵɵpipeBind4',
  moduleName: CORE
};
Identifiers.pipeBindV = {
  name: 'ɵɵpipeBindV',
  moduleName: CORE
};
Identifiers.hostProperty = {
  name: 'ɵɵhostProperty',
  moduleName: CORE
};
Identifiers.property = {
  name: 'ɵɵproperty',
  moduleName: CORE
};
Identifiers.propertyInterpolate = {
  name: 'ɵɵpropertyInterpolate',
  moduleName: CORE
};
Identifiers.propertyInterpolate1 = {
  name: 'ɵɵpropertyInterpolate1',
  moduleName: CORE
};
Identifiers.propertyInterpolate2 = {
  name: 'ɵɵpropertyInterpolate2',
  moduleName: CORE
};
Identifiers.propertyInterpolate3 = {
  name: 'ɵɵpropertyInterpolate3',
  moduleName: CORE
};
Identifiers.propertyInterpolate4 = {
  name: 'ɵɵpropertyInterpolate4',
  moduleName: CORE
};
Identifiers.propertyInterpolate5 = {
  name: 'ɵɵpropertyInterpolate5',
  moduleName: CORE
};
Identifiers.propertyInterpolate6 = {
  name: 'ɵɵpropertyInterpolate6',
  moduleName: CORE
};
Identifiers.propertyInterpolate7 = {
  name: 'ɵɵpropertyInterpolate7',
  moduleName: CORE
};
Identifiers.propertyInterpolate8 = {
  name: 'ɵɵpropertyInterpolate8',
  moduleName: CORE
};
Identifiers.propertyInterpolateV = {
  name: 'ɵɵpropertyInterpolateV',
  moduleName: CORE
};
Identifiers.i18n = {
  name: 'ɵɵi18n',
  moduleName: CORE
};
Identifiers.i18nAttributes = {
  name: 'ɵɵi18nAttributes',
  moduleName: CORE
};
Identifiers.i18nExp = {
  name: 'ɵɵi18nExp',
  moduleName: CORE
};
Identifiers.i18nStart = {
  name: 'ɵɵi18nStart',
  moduleName: CORE
};
Identifiers.i18nEnd = {
  name: 'ɵɵi18nEnd',
  moduleName: CORE
};
Identifiers.i18nApply = {
  name: 'ɵɵi18nApply',
  moduleName: CORE
};
Identifiers.i18nPostprocess = {
  name: 'ɵɵi18nPostprocess',
  moduleName: CORE
};
Identifiers.pipe = {
  name: 'ɵɵpipe',
  moduleName: CORE
};
Identifiers.projection = {
  name: 'ɵɵprojection',
  moduleName: CORE
};
Identifiers.projectionDef = {
  name: 'ɵɵprojectionDef',
  moduleName: CORE
};
Identifiers.reference = {
  name: 'ɵɵreference',
  moduleName: CORE
};
Identifiers.inject = {
  name: 'ɵɵinject',
  moduleName: CORE
};
Identifiers.injectAttribute = {
  name: 'ɵɵinjectAttribute',
  moduleName: CORE
};
Identifiers.directiveInject = {
  name: 'ɵɵdirectiveInject',
  moduleName: CORE
};
Identifiers.invalidFactory = {
  name: 'ɵɵinvalidFactory',
  moduleName: CORE
};
Identifiers.invalidFactoryDep = {
  name: 'ɵɵinvalidFactoryDep',
  moduleName: CORE
};
Identifiers.templateRefExtractor = {
  name: 'ɵɵtemplateRefExtractor',
  moduleName: CORE
};
Identifiers.forwardRef = {
  name: 'forwardRef',
  moduleName: CORE
};
Identifiers.resolveForwardRef = {
  name: 'resolveForwardRef',
  moduleName: CORE
};
Identifiers.ɵɵdefineInjectable = {
  name: 'ɵɵdefineInjectable',
  moduleName: CORE
};
Identifiers.declareInjectable = {
  name: 'ɵɵngDeclareInjectable',
  moduleName: CORE
};
Identifiers.InjectableDeclaration = {
  name: 'ɵɵInjectableDeclaration',
  moduleName: CORE
};
Identifiers.resolveWindow = {
  name: 'ɵɵresolveWindow',
  moduleName: CORE
};
Identifiers.resolveDocument = {
  name: 'ɵɵresolveDocument',
  moduleName: CORE
};
Identifiers.resolveBody = {
  name: 'ɵɵresolveBody',
  moduleName: CORE
};
Identifiers.defineComponent = {
  name: 'ɵɵdefineComponent',
  moduleName: CORE
};
Identifiers.declareComponent = {
  name: 'ɵɵngDeclareComponent',
  moduleName: CORE
};
Identifiers.setComponentScope = {
  name: 'ɵɵsetComponentScope',
  moduleName: CORE
};
Identifiers.ChangeDetectionStrategy = {
  name: 'ChangeDetectionStrategy',
  moduleName: CORE
};
Identifiers.ViewEncapsulation = {
  name: 'ViewEncapsulation',
  moduleName: CORE
};
Identifiers.ComponentDeclaration = {
  name: 'ɵɵComponentDeclaration',
  moduleName: CORE
};
Identifiers.FactoryDeclaration = {
  name: 'ɵɵFactoryDeclaration',
  moduleName: CORE
};
Identifiers.declareFactory = {
  name: 'ɵɵngDeclareFactory',
  moduleName: CORE
};
Identifiers.FactoryTarget = {
  name: 'ɵɵFactoryTarget',
  moduleName: CORE
};
Identifiers.defineDirective = {
  name: 'ɵɵdefineDirective',
  moduleName: CORE
};
Identifiers.declareDirective = {
  name: 'ɵɵngDeclareDirective',
  moduleName: CORE
};
Identifiers.DirectiveDeclaration = {
  name: 'ɵɵDirectiveDeclaration',
  moduleName: CORE
};
Identifiers.InjectorDef = {
  name: 'ɵɵInjectorDef',
  moduleName: CORE
};
Identifiers.InjectorDeclaration = {
  name: 'ɵɵInjectorDeclaration',
  moduleName: CORE
};
Identifiers.defineInjector = {
  name: 'ɵɵdefineInjector',
  moduleName: CORE
};
Identifiers.declareInjector = {
  name: 'ɵɵngDeclareInjector',
  moduleName: CORE
};
Identifiers.NgModuleDeclaration = {
  name: 'ɵɵNgModuleDeclaration',
  moduleName: CORE
};
Identifiers.ModuleWithProviders = {
  name: 'ModuleWithProviders',
  moduleName: CORE
};
Identifiers.defineNgModule = {
  name: 'ɵɵdefineNgModule',
  moduleName: CORE
};
Identifiers.declareNgModule = {
  name: 'ɵɵngDeclareNgModule',
  moduleName: CORE
};
Identifiers.setNgModuleScope = {
  name: 'ɵɵsetNgModuleScope',
  moduleName: CORE
};
Identifiers.registerNgModuleType = {
  name: 'ɵɵregisterNgModuleType',
  moduleName: CORE
};
Identifiers.PipeDeclaration = {
  name: 'ɵɵPipeDeclaration',
  moduleName: CORE
};
Identifiers.definePipe = {
  name: 'ɵɵdefinePipe',
  moduleName: CORE
};
Identifiers.declarePipe = {
  name: 'ɵɵngDeclarePipe',
  moduleName: CORE
};
Identifiers.declareClassMetadata = {
  name: 'ɵɵngDeclareClassMetadata',
  moduleName: CORE
};
Identifiers.setClassMetadata = {
  name: 'ɵsetClassMetadata',
  moduleName: CORE
};
Identifiers.queryRefresh = {
  name: 'ɵɵqueryRefresh',
  moduleName: CORE
};
Identifiers.viewQuery = {
  name: 'ɵɵviewQuery',
  moduleName: CORE
};
Identifiers.loadQuery = {
  name: 'ɵɵloadQuery',
  moduleName: CORE
};
Identifiers.contentQuery = {
  name: 'ɵɵcontentQuery',
  moduleName: CORE
};
Identifiers.NgOnChangesFeature = {
  name: 'ɵɵNgOnChangesFeature',
  moduleName: CORE
};
Identifiers.InheritDefinitionFeature = {
  name: 'ɵɵInheritDefinitionFeature',
  moduleName: CORE
};
Identifiers.CopyDefinitionFeature = {
  name: 'ɵɵCopyDefinitionFeature',
  moduleName: CORE
};
Identifiers.StandaloneFeature = {
  name: 'ɵɵStandaloneFeature',
  moduleName: CORE
};
Identifiers.ProvidersFeature = {
  name: 'ɵɵProvidersFeature',
  moduleName: CORE
};
Identifiers.listener = {
  name: 'ɵɵlistener',
  moduleName: CORE
};
Identifiers.getInheritedFactory = {
  name: 'ɵɵgetInheritedFactory',
  moduleName: CORE
}; // sanitization-related functions

Identifiers.sanitizeHtml = {
  name: 'ɵɵsanitizeHtml',
  moduleName: CORE
};
Identifiers.sanitizeStyle = {
  name: 'ɵɵsanitizeStyle',
  moduleName: CORE
};
Identifiers.sanitizeResourceUrl = {
  name: 'ɵɵsanitizeResourceUrl',
  moduleName: CORE
};
Identifiers.sanitizeScript = {
  name: 'ɵɵsanitizeScript',
  moduleName: CORE
};
Identifiers.sanitizeUrl = {
  name: 'ɵɵsanitizeUrl',
  moduleName: CORE
};
Identifiers.sanitizeUrlOrResourceUrl = {
  name: 'ɵɵsanitizeUrlOrResourceUrl',
  moduleName: CORE
};
Identifiers.trustConstantHtml = {
  name: 'ɵɵtrustConstantHtml',
  moduleName: CORE
};
Identifiers.trustConstantResourceUrl = {
  name: 'ɵɵtrustConstantResourceUrl',
  moduleName: CORE
};
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
// https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit

var VERSION$1 = 3;
var JS_B64_PREFIX = '# sourceMappingURL=data:application/json;base64,';

var SourceMapGenerator = /*#__PURE__*/function () {
  function SourceMapGenerator() {
    var file = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, SourceMapGenerator);

    this.file = file;
    this.sourcesContent = new Map();
    this.lines = [];
    this.lastCol0 = 0;
    this.hasMappings = false;
  } // The content is `null` when the content is expected to be loaded using the URL


  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(SourceMapGenerator, [{
    key: "addSource",
    value: function addSource(url) {
      var content = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (!this.sourcesContent.has(url)) {
        this.sourcesContent.set(url, content);
      }

      return this;
    }
  }, {
    key: "addLine",
    value: function addLine() {
      this.lines.push([]);
      this.lastCol0 = 0;
      return this;
    }
  }, {
    key: "addMapping",
    value: function addMapping(col0, sourceUrl, sourceLine0, sourceCol0) {
      if (!this.currentLine) {
        throw new Error("A line must be added before mappings can be added");
      }

      if (sourceUrl != null && !this.sourcesContent.has(sourceUrl)) {
        throw new Error("Unknown source file \"".concat(sourceUrl, "\""));
      }

      if (col0 == null) {
        throw new Error("The column in the generated code must be provided");
      }

      if (col0 < this.lastCol0) {
        throw new Error("Mapping should be added in output order");
      }

      if (sourceUrl && (sourceLine0 == null || sourceCol0 == null)) {
        throw new Error("The source location must be provided when a source url is provided");
      }

      this.hasMappings = true;
      this.lastCol0 = col0;
      this.currentLine.push({
        col0: col0,
        sourceUrl: sourceUrl,
        sourceLine0: sourceLine0,
        sourceCol0: sourceCol0
      });
      return this;
    }
    /**
     * @internal strip this from published d.ts files due to
     * https://github.com/microsoft/TypeScript/issues/36216
     */

  }, {
    key: "currentLine",
    get: function get() {
      return this.lines.slice(-1)[0];
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var _this47 = this;

      if (!this.hasMappings) {
        return null;
      }

      var sourcesIndex = new Map();
      var sources = [];
      var sourcesContent = [];
      Array.from(this.sourcesContent.keys()).forEach(function (url, i) {
        sourcesIndex.set(url, i);
        sources.push(url);
        sourcesContent.push(_this47.sourcesContent.get(url) || null);
      });
      var mappings = '';
      var lastCol0 = 0;
      var lastSourceIndex = 0;
      var lastSourceLine0 = 0;
      var lastSourceCol0 = 0;
      this.lines.forEach(function (segments) {
        lastCol0 = 0;
        mappings += segments.map(function (segment) {
          // zero-based starting column of the line in the generated code
          var segAsStr = toBase64VLQ(segment.col0 - lastCol0);
          lastCol0 = segment.col0;

          if (segment.sourceUrl != null) {
            // zero-based index into the “sources” list
            segAsStr += toBase64VLQ(sourcesIndex.get(segment.sourceUrl) - lastSourceIndex);
            lastSourceIndex = sourcesIndex.get(segment.sourceUrl); // the zero-based starting line in the original source

            segAsStr += toBase64VLQ(segment.sourceLine0 - lastSourceLine0);
            lastSourceLine0 = segment.sourceLine0; // the zero-based starting column in the original source

            segAsStr += toBase64VLQ(segment.sourceCol0 - lastSourceCol0);
            lastSourceCol0 = segment.sourceCol0;
          }

          return segAsStr;
        }).join(',');
        mappings += ';';
      });
      mappings = mappings.slice(0, -1);
      return {
        'file': this.file || '',
        'version': VERSION$1,
        'sourceRoot': '',
        'sources': sources,
        'sourcesContent': sourcesContent,
        'mappings': mappings
      };
    }
  }, {
    key: "toJsComment",
    value: function toJsComment() {
      return this.hasMappings ? '//' + JS_B64_PREFIX + toBase64String(JSON.stringify(this, null, 0)) : '';
    }
  }]);

  return SourceMapGenerator;
}();

function toBase64String(value) {
  var b64 = '';
  var encoded = utf8Encode(value);

  for (var i = 0; i < encoded.length;) {
    var i1 = encoded[i++];
    var i2 = i < encoded.length ? encoded[i++] : null;
    var i3 = i < encoded.length ? encoded[i++] : null;
    b64 += toBase64Digit(i1 >> 2);
    b64 += toBase64Digit((i1 & 3) << 4 | (i2 === null ? 0 : i2 >> 4));
    b64 += i2 === null ? '=' : toBase64Digit((i2 & 15) << 2 | (i3 === null ? 0 : i3 >> 6));
    b64 += i2 === null || i3 === null ? '=' : toBase64Digit(i3 & 63);
  }

  return b64;
}

function toBase64VLQ(value) {
  value = value < 0 ? (-value << 1) + 1 : value << 1;
  var out = '';

  do {
    var digit = value & 31;
    value = value >> 5;

    if (value > 0) {
      digit = digit | 32;
    }

    out += toBase64Digit(digit);
  } while (value > 0);

  return out;
}

var B64_DIGITS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

function toBase64Digit(value) {
  if (value < 0 || value >= 64) {
    throw new Error("Can only encode value in the range [0, 63]");
  }

  return B64_DIGITS[value];
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */


var _SINGLE_QUOTE_ESCAPE_STRING_RE = /'|\\|\n|\r|\$/g;
var _LEGAL_IDENTIFIER_RE = /^[$A-Z_][0-9A-Z_$]*$/i;
var _INDENT_WITH = '  ';

var _EmittedLine = /*#__PURE__*/(0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(function _EmittedLine(indent) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, _EmittedLine);

  this.indent = indent;
  this.partsLength = 0;
  this.parts = [];
  this.srcSpans = [];
});

var EmitterVisitorContext = /*#__PURE__*/function () {
  function EmitterVisitorContext(_indent) {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, EmitterVisitorContext);

    this._indent = _indent;
    this._lines = [new _EmittedLine(_indent)];
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(EmitterVisitorContext, [{
    key: "_currentLine",
    get:
    /**
     * @internal strip this from published d.ts files due to
     * https://github.com/microsoft/TypeScript/issues/36216
     */
    function get() {
      return this._lines[this._lines.length - 1];
    }
  }, {
    key: "println",
    value: function println(from) {
      var lastPart = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      this.print(from || null, lastPart, true);
    }
  }, {
    key: "lineIsEmpty",
    value: function lineIsEmpty() {
      return this._currentLine.parts.length === 0;
    }
  }, {
    key: "lineLength",
    value: function lineLength() {
      return this._currentLine.indent * _INDENT_WITH.length + this._currentLine.partsLength;
    }
  }, {
    key: "print",
    value: function print(from, part) {
      var newLine = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      if (part.length > 0) {
        this._currentLine.parts.push(part);

        this._currentLine.partsLength += part.length;

        this._currentLine.srcSpans.push(from && from.sourceSpan || null);
      }

      if (newLine) {
        this._lines.push(new _EmittedLine(this._indent));
      }
    }
  }, {
    key: "removeEmptyLastLine",
    value: function removeEmptyLastLine() {
      if (this.lineIsEmpty()) {
        this._lines.pop();
      }
    }
  }, {
    key: "incIndent",
    value: function incIndent() {
      this._indent++;

      if (this.lineIsEmpty()) {
        this._currentLine.indent = this._indent;
      }
    }
  }, {
    key: "decIndent",
    value: function decIndent() {
      this._indent--;

      if (this.lineIsEmpty()) {
        this._currentLine.indent = this._indent;
      }
    }
  }, {
    key: "toSource",
    value: function toSource() {
      return this.sourceLines.map(function (l) {
        return l.parts.length > 0 ? _createIndent(l.indent) + l.parts.join('') : '';
      }).join('\n');
    }
  }, {
    key: "toSourceMapGenerator",
    value: function toSourceMapGenerator(genFilePath) {
      var startsAtLine = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var map = new SourceMapGenerator(genFilePath);
      var firstOffsetMapped = false;

      var mapFirstOffsetIfNeeded = function mapFirstOffsetIfNeeded() {
        if (!firstOffsetMapped) {
          // Add a single space so that tools won't try to load the file from disk.
          // Note: We are using virtual urls like `ng:///`, so we have to
          // provide a content here.
          map.addSource(genFilePath, ' ').addMapping(0, genFilePath, 0, 0);
          firstOffsetMapped = true;
        }
      };

      for (var i = 0; i < startsAtLine; i++) {
        map.addLine();
        mapFirstOffsetIfNeeded();
      }

      this.sourceLines.forEach(function (line, lineIdx) {
        map.addLine();
        var spans = line.srcSpans;
        var parts = line.parts;
        var col0 = line.indent * _INDENT_WITH.length;
        var spanIdx = 0; // skip leading parts without source spans

        while (spanIdx < spans.length && !spans[spanIdx]) {
          col0 += parts[spanIdx].length;
          spanIdx++;
        }

        if (spanIdx < spans.length && lineIdx === 0 && col0 === 0) {
          firstOffsetMapped = true;
        } else {
          mapFirstOffsetIfNeeded();
        }

        while (spanIdx < spans.length) {
          var span = spans[spanIdx];
          var source = span.start.file;
          var sourceLine = span.start.line;
          var sourceCol = span.start.col;
          map.addSource(source.url, source.content).addMapping(col0, source.url, sourceLine, sourceCol);
          col0 += parts[spanIdx].length;
          spanIdx++; // assign parts without span or the same span to the previous segment

          while (spanIdx < spans.length && (span === spans[spanIdx] || !spans[spanIdx])) {
            col0 += parts[spanIdx].length;
            spanIdx++;
          }
        }
      });
      return map;
    }
  }, {
    key: "spanOf",
    value: function spanOf(line, column) {
      var emittedLine = this._lines[line];

      if (emittedLine) {
        var columnsLeft = column - _createIndent(emittedLine.indent).length;

        for (var partIndex = 0; partIndex < emittedLine.parts.length; partIndex++) {
          var part = emittedLine.parts[partIndex];

          if (part.length > columnsLeft) {
            return emittedLine.srcSpans[partIndex];
          }

          columnsLeft -= part.length;
        }
      }

      return null;
    }
    /**
     * @internal strip this from published d.ts files due to
     * https://github.com/microsoft/TypeScript/issues/36216
     */

  }, {
    key: "sourceLines",
    get: function get() {
      if (this._lines.length && this._lines[this._lines.length - 1].parts.length === 0) {
        return this._lines.slice(0, -1);
      }

      return this._lines;
    }
  }], [{
    key: "createRoot",
    value: function createRoot() {
      return new EmitterVisitorContext(0);
    }
  }]);

  return EmitterVisitorContext;
}();

var AbstractEmitterVisitor = /*#__PURE__*/function () {
  function AbstractEmitterVisitor(_escapeDollarInStrings) {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, AbstractEmitterVisitor);

    this._escapeDollarInStrings = _escapeDollarInStrings;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(AbstractEmitterVisitor, [{
    key: "printLeadingComments",
    value: function printLeadingComments(stmt, ctx) {
      if (stmt.leadingComments === undefined) {
        return;
      }

      var _iterator3 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper_js__WEBPACK_IMPORTED_MODULE_9__["default"])(stmt.leadingComments),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var comment = _step3.value;

          if (comment instanceof JSDocComment) {
            ctx.print(stmt, "/*".concat(comment.toString(), "*/"), comment.trailingNewline);
          } else {
            if (comment.multiline) {
              ctx.print(stmt, "/* ".concat(comment.text, " */"), comment.trailingNewline);
            } else {
              comment.text.split('\n').forEach(function (line) {
                ctx.println(stmt, "// ".concat(line));
              });
            }
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
    }
  }, {
    key: "visitExpressionStmt",
    value: function visitExpressionStmt(stmt, ctx) {
      this.printLeadingComments(stmt, ctx);
      stmt.expr.visitExpression(this, ctx);
      ctx.println(stmt, ';');
      return null;
    }
  }, {
    key: "visitReturnStmt",
    value: function visitReturnStmt(stmt, ctx) {
      this.printLeadingComments(stmt, ctx);
      ctx.print(stmt, "return ");
      stmt.value.visitExpression(this, ctx);
      ctx.println(stmt, ';');
      return null;
    }
  }, {
    key: "visitIfStmt",
    value: function visitIfStmt(stmt, ctx) {
      this.printLeadingComments(stmt, ctx);
      ctx.print(stmt, "if (");
      stmt.condition.visitExpression(this, ctx);
      ctx.print(stmt, ") {");
      var hasElseCase = stmt.falseCase != null && stmt.falseCase.length > 0;

      if (stmt.trueCase.length <= 1 && !hasElseCase) {
        ctx.print(stmt, " ");
        this.visitAllStatements(stmt.trueCase, ctx);
        ctx.removeEmptyLastLine();
        ctx.print(stmt, " ");
      } else {
        ctx.println();
        ctx.incIndent();
        this.visitAllStatements(stmt.trueCase, ctx);
        ctx.decIndent();

        if (hasElseCase) {
          ctx.println(stmt, "} else {");
          ctx.incIndent();
          this.visitAllStatements(stmt.falseCase, ctx);
          ctx.decIndent();
        }
      }

      ctx.println(stmt, "}");
      return null;
    }
  }, {
    key: "visitWriteVarExpr",
    value: function visitWriteVarExpr(expr, ctx) {
      var lineWasEmpty = ctx.lineIsEmpty();

      if (!lineWasEmpty) {
        ctx.print(expr, '(');
      }

      ctx.print(expr, "".concat(expr.name, " = "));
      expr.value.visitExpression(this, ctx);

      if (!lineWasEmpty) {
        ctx.print(expr, ')');
      }

      return null;
    }
  }, {
    key: "visitWriteKeyExpr",
    value: function visitWriteKeyExpr(expr, ctx) {
      var lineWasEmpty = ctx.lineIsEmpty();

      if (!lineWasEmpty) {
        ctx.print(expr, '(');
      }

      expr.receiver.visitExpression(this, ctx);
      ctx.print(expr, "[");
      expr.index.visitExpression(this, ctx);
      ctx.print(expr, "] = ");
      expr.value.visitExpression(this, ctx);

      if (!lineWasEmpty) {
        ctx.print(expr, ')');
      }

      return null;
    }
  }, {
    key: "visitWritePropExpr",
    value: function visitWritePropExpr(expr, ctx) {
      var lineWasEmpty = ctx.lineIsEmpty();

      if (!lineWasEmpty) {
        ctx.print(expr, '(');
      }

      expr.receiver.visitExpression(this, ctx);
      ctx.print(expr, ".".concat(expr.name, " = "));
      expr.value.visitExpression(this, ctx);

      if (!lineWasEmpty) {
        ctx.print(expr, ')');
      }

      return null;
    }
  }, {
    key: "visitInvokeFunctionExpr",
    value: function visitInvokeFunctionExpr(expr, ctx) {
      expr.fn.visitExpression(this, ctx);
      ctx.print(expr, "(");
      this.visitAllExpressions(expr.args, ctx, ',');
      ctx.print(expr, ")");
      return null;
    }
  }, {
    key: "visitTaggedTemplateExpr",
    value: function visitTaggedTemplateExpr(expr, ctx) {
      expr.tag.visitExpression(this, ctx);
      ctx.print(expr, '`' + expr.template.elements[0].rawText);

      for (var i = 1; i < expr.template.elements.length; i++) {
        ctx.print(expr, '${');
        expr.template.expressions[i - 1].visitExpression(this, ctx);
        ctx.print(expr, "}".concat(expr.template.elements[i].rawText));
      }

      ctx.print(expr, '`');
      return null;
    }
  }, {
    key: "visitWrappedNodeExpr",
    value: function visitWrappedNodeExpr(ast, ctx) {
      throw new Error('Abstract emitter cannot visit WrappedNodeExpr.');
    }
  }, {
    key: "visitTypeofExpr",
    value: function visitTypeofExpr(expr, ctx) {
      ctx.print(expr, 'typeof ');
      expr.expr.visitExpression(this, ctx);
    }
  }, {
    key: "visitReadVarExpr",
    value: function visitReadVarExpr(ast, ctx) {
      ctx.print(ast, ast.name);
      return null;
    }
  }, {
    key: "visitInstantiateExpr",
    value: function visitInstantiateExpr(ast, ctx) {
      ctx.print(ast, "new ");
      ast.classExpr.visitExpression(this, ctx);
      ctx.print(ast, "(");
      this.visitAllExpressions(ast.args, ctx, ',');
      ctx.print(ast, ")");
      return null;
    }
  }, {
    key: "visitLiteralExpr",
    value: function visitLiteralExpr(ast, ctx) {
      var value = ast.value;

      if (typeof value === 'string') {
        ctx.print(ast, escapeIdentifier(value, this._escapeDollarInStrings));
      } else {
        ctx.print(ast, "".concat(value));
      }

      return null;
    }
  }, {
    key: "visitLocalizedString",
    value: function visitLocalizedString(ast, ctx) {
      var head = ast.serializeI18nHead();
      ctx.print(ast, '$localize `' + head.raw);

      for (var i = 1; i < ast.messageParts.length; i++) {
        ctx.print(ast, '${');
        ast.expressions[i - 1].visitExpression(this, ctx);
        ctx.print(ast, "}".concat(ast.serializeI18nTemplatePart(i).raw));
      }

      ctx.print(ast, '`');
      return null;
    }
  }, {
    key: "visitConditionalExpr",
    value: function visitConditionalExpr(ast, ctx) {
      ctx.print(ast, "(");
      ast.condition.visitExpression(this, ctx);
      ctx.print(ast, '? ');
      ast.trueCase.visitExpression(this, ctx);
      ctx.print(ast, ': ');
      ast.falseCase.visitExpression(this, ctx);
      ctx.print(ast, ")");
      return null;
    }
  }, {
    key: "visitNotExpr",
    value: function visitNotExpr(ast, ctx) {
      ctx.print(ast, '!');
      ast.condition.visitExpression(this, ctx);
      return null;
    }
  }, {
    key: "visitUnaryOperatorExpr",
    value: function visitUnaryOperatorExpr(ast, ctx) {
      var opStr;

      switch (ast.operator) {
        case UnaryOperator.Plus:
          opStr = '+';
          break;

        case UnaryOperator.Minus:
          opStr = '-';
          break;

        default:
          throw new Error("Unknown operator ".concat(ast.operator));
      }

      if (ast.parens) ctx.print(ast, "(");
      ctx.print(ast, opStr);
      ast.expr.visitExpression(this, ctx);
      if (ast.parens) ctx.print(ast, ")");
      return null;
    }
  }, {
    key: "visitBinaryOperatorExpr",
    value: function visitBinaryOperatorExpr(ast, ctx) {
      var opStr;

      switch (ast.operator) {
        case BinaryOperator.Equals:
          opStr = '==';
          break;

        case BinaryOperator.Identical:
          opStr = '===';
          break;

        case BinaryOperator.NotEquals:
          opStr = '!=';
          break;

        case BinaryOperator.NotIdentical:
          opStr = '!==';
          break;

        case BinaryOperator.And:
          opStr = '&&';
          break;

        case BinaryOperator.BitwiseAnd:
          opStr = '&';
          break;

        case BinaryOperator.Or:
          opStr = '||';
          break;

        case BinaryOperator.Plus:
          opStr = '+';
          break;

        case BinaryOperator.Minus:
          opStr = '-';
          break;

        case BinaryOperator.Divide:
          opStr = '/';
          break;

        case BinaryOperator.Multiply:
          opStr = '*';
          break;

        case BinaryOperator.Modulo:
          opStr = '%';
          break;

        case BinaryOperator.Lower:
          opStr = '<';
          break;

        case BinaryOperator.LowerEquals:
          opStr = '<=';
          break;

        case BinaryOperator.Bigger:
          opStr = '>';
          break;

        case BinaryOperator.BiggerEquals:
          opStr = '>=';
          break;

        case BinaryOperator.NullishCoalesce:
          opStr = '??';
          break;

        default:
          throw new Error("Unknown operator ".concat(ast.operator));
      }

      if (ast.parens) ctx.print(ast, "(");
      ast.lhs.visitExpression(this, ctx);
      ctx.print(ast, " ".concat(opStr, " "));
      ast.rhs.visitExpression(this, ctx);
      if (ast.parens) ctx.print(ast, ")");
      return null;
    }
  }, {
    key: "visitReadPropExpr",
    value: function visitReadPropExpr(ast, ctx) {
      ast.receiver.visitExpression(this, ctx);
      ctx.print(ast, ".");
      ctx.print(ast, ast.name);
      return null;
    }
  }, {
    key: "visitReadKeyExpr",
    value: function visitReadKeyExpr(ast, ctx) {
      ast.receiver.visitExpression(this, ctx);
      ctx.print(ast, "[");
      ast.index.visitExpression(this, ctx);
      ctx.print(ast, "]");
      return null;
    }
  }, {
    key: "visitLiteralArrayExpr",
    value: function visitLiteralArrayExpr(ast, ctx) {
      ctx.print(ast, "[");
      this.visitAllExpressions(ast.entries, ctx, ',');
      ctx.print(ast, "]");
      return null;
    }
  }, {
    key: "visitLiteralMapExpr",
    value: function visitLiteralMapExpr(ast, ctx) {
      var _this48 = this;

      ctx.print(ast, "{");
      this.visitAllObjects(function (entry) {
        ctx.print(ast, "".concat(escapeIdentifier(entry.key, _this48._escapeDollarInStrings, entry.quoted), ":"));
        entry.value.visitExpression(_this48, ctx);
      }, ast.entries, ctx, ',');
      ctx.print(ast, "}");
      return null;
    }
  }, {
    key: "visitCommaExpr",
    value: function visitCommaExpr(ast, ctx) {
      ctx.print(ast, '(');
      this.visitAllExpressions(ast.parts, ctx, ',');
      ctx.print(ast, ')');
      return null;
    }
  }, {
    key: "visitAllExpressions",
    value: function visitAllExpressions(expressions, ctx, separator) {
      var _this49 = this;

      this.visitAllObjects(function (expr) {
        return expr.visitExpression(_this49, ctx);
      }, expressions, ctx, separator);
    }
  }, {
    key: "visitAllObjects",
    value: function visitAllObjects(handler, expressions, ctx, separator) {
      var incrementedIndent = false;

      for (var i = 0; i < expressions.length; i++) {
        if (i > 0) {
          if (ctx.lineLength() > 80) {
            ctx.print(null, separator, true);

            if (!incrementedIndent) {
              // continuation are marked with double indent.
              ctx.incIndent();
              ctx.incIndent();
              incrementedIndent = true;
            }
          } else {
            ctx.print(null, separator, false);
          }
        }

        handler(expressions[i]);
      }

      if (incrementedIndent) {
        // continuation are marked with double indent.
        ctx.decIndent();
        ctx.decIndent();
      }
    }
  }, {
    key: "visitAllStatements",
    value: function visitAllStatements(statements, ctx) {
      var _this50 = this;

      statements.forEach(function (stmt) {
        return stmt.visitStatement(_this50, ctx);
      });
    }
  }]);

  return AbstractEmitterVisitor;
}();

function escapeIdentifier(input, escapeDollar) {
  var alwaysQuote = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

  if (input == null) {
    return null;
  }

  var body = input.replace(_SINGLE_QUOTE_ESCAPE_STRING_RE, function () {
    if ((arguments.length <= 0 ? undefined : arguments[0]) == '$') {
      return escapeDollar ? '\\$' : '$';
    } else if ((arguments.length <= 0 ? undefined : arguments[0]) == '\n') {
      return '\\n';
    } else if ((arguments.length <= 0 ? undefined : arguments[0]) == '\r') {
      return '\\r';
    } else {
      return "\\".concat(arguments.length <= 0 ? undefined : arguments[0]);
    }
  });
  var requiresQuotes = alwaysQuote || !_LEGAL_IDENTIFIER_RE.test(body);
  return requiresQuotes ? "'".concat(body, "'") : body;
}

function _createIndent(count) {
  var res = '';

  for (var i = 0; i < count; i++) {
    res += _INDENT_WITH;
  }

  return res;
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */


function typeWithParameters(type, numParams) {
  if (numParams === 0) {
    return expressionType(type);
  }

  var params = [];

  for (var i = 0; i < numParams; i++) {
    params.push(DYNAMIC_TYPE);
  }

  return expressionType(type, undefined, params);
}

var ANIMATE_SYMBOL_PREFIX = '@';

function prepareSyntheticPropertyName(name) {
  return "".concat(ANIMATE_SYMBOL_PREFIX).concat(name);
}

function prepareSyntheticListenerName(name, phase) {
  return "".concat(ANIMATE_SYMBOL_PREFIX).concat(name, ".").concat(phase);
}

function getSafePropertyAccessString(accessor, name) {
  var escapedName = escapeIdentifier(name, false, false);
  return escapedName !== name ? "".concat(accessor, "[").concat(escapedName, "]") : "".concat(accessor, ".").concat(name);
}

function prepareSyntheticListenerFunctionName(name, phase) {
  return "animation_".concat(name, "_").concat(phase);
}

function jitOnlyGuardedExpression(expr) {
  return guardedExpression('ngJitMode', expr);
}

function devOnlyGuardedExpression(expr) {
  return guardedExpression('ngDevMode', expr);
}

function guardedExpression(guard, expr) {
  var guardExpr = new ExternalExpr({
    name: guard,
    moduleName: null
  });
  var guardNotDefined = new BinaryOperatorExpr(BinaryOperator.Identical, new TypeofExpr(guardExpr), literal('undefined'));
  var guardUndefinedOrTrue = new BinaryOperatorExpr(BinaryOperator.Or, guardNotDefined, guardExpr,
  /* type */
  undefined,
  /* sourceSpan */
  undefined, true);
  return new BinaryOperatorExpr(BinaryOperator.And, guardUndefinedOrTrue, expr);
}

function wrapReference(value) {
  var wrapped = new WrappedNodeExpr(value);
  return {
    value: wrapped,
    type: wrapped
  };
}

function refsToArray(refs, shouldForwardDeclare) {
  var values = literalArr(refs.map(function (ref) {
    return ref.value;
  }));
  return shouldForwardDeclare ? fn([], [new ReturnStatement(values)]) : values;
}

function createMayBeForwardRefExpression(expression, forwardRef) {
  return {
    expression: expression,
    forwardRef: forwardRef
  };
}
/**
 * Convert a `MaybeForwardRefExpression` to an `Expression`, possibly wrapping its expression in a
 * `forwardRef()` call.
 *
 * If `MaybeForwardRefExpression.forwardRef` is `ForwardRefHandling.Unwrapped` then the expression
 * was originally wrapped in a `forwardRef()` call to prevent the value from being eagerly evaluated
 * in the code.
 *
 * See `packages/compiler-cli/src/ngtsc/annotations/src/injectable.ts` and
 * `packages/compiler/src/jit_compiler_facade.ts` for more information.
 */


function convertFromMaybeForwardRefExpression(_ref3) {
  var expression = _ref3.expression,
      forwardRef = _ref3.forwardRef;

  switch (forwardRef) {
    case 0
    /* ForwardRefHandling.None */
    :
    case 1
    /* ForwardRefHandling.Wrapped */
    :
      return expression;

    case 2
    /* ForwardRefHandling.Unwrapped */
    :
      return generateForwardRef(expression);
  }
}
/**
 * Generate an expression that has the given `expr` wrapped in the following form:
 *
 * ```
 * forwardRef(() => expr)
 * ```
 */


function generateForwardRef(expr) {
  return importExpr(Identifiers.forwardRef).callFn([fn([], [new ReturnStatement(expr)])]);
}

var R3FactoryDelegateType;

(function (R3FactoryDelegateType) {
  R3FactoryDelegateType[R3FactoryDelegateType["Class"] = 0] = "Class";
  R3FactoryDelegateType[R3FactoryDelegateType["Function"] = 1] = "Function";
})(R3FactoryDelegateType || (R3FactoryDelegateType = {}));

var FactoryTarget$1;

(function (FactoryTarget) {
  FactoryTarget[FactoryTarget["Directive"] = 0] = "Directive";
  FactoryTarget[FactoryTarget["Component"] = 1] = "Component";
  FactoryTarget[FactoryTarget["Injectable"] = 2] = "Injectable";
  FactoryTarget[FactoryTarget["Pipe"] = 3] = "Pipe";
  FactoryTarget[FactoryTarget["NgModule"] = 4] = "NgModule";
})(FactoryTarget$1 || (FactoryTarget$1 = {}));
/**
 * Construct a factory function expression for the given `R3FactoryMetadata`.
 */


function compileFactoryFunction(meta) {
  var t = variable('t');
  var baseFactoryVar = null; // The type to instantiate via constructor invocation. If there is no delegated factory, meaning
  // this type is always created by constructor invocation, then this is the type-to-create
  // parameter provided by the user (t) if specified, or the current type if not. If there is a
  // delegated factory (which is used to create the current type) then this is only the type-to-
  // create parameter (t).

  var typeForCtor = !isDelegatedFactoryMetadata(meta) ? new BinaryOperatorExpr(BinaryOperator.Or, t, meta.internalType) : t;
  var ctorExpr = null;

  if (meta.deps !== null) {
    // There is a constructor (either explicitly or implicitly defined).
    if (meta.deps !== 'invalid') {
      ctorExpr = new InstantiateExpr(typeForCtor, injectDependencies(meta.deps, meta.target));
    }
  } else {
    // There is no constructor, use the base class' factory to construct typeForCtor.
    baseFactoryVar = variable("\u0275".concat(meta.name, "_BaseFactory"));
    ctorExpr = baseFactoryVar.callFn([typeForCtor]);
  }

  var body = [];
  var retExpr = null;

  function makeConditionalFactory(nonCtorExpr) {
    var r = variable('r');
    body.push(r.set(NULL_EXPR).toDeclStmt());
    var ctorStmt = ctorExpr !== null ? r.set(ctorExpr).toStmt() : importExpr(Identifiers.invalidFactory).callFn([]).toStmt();
    body.push(ifStmt(t, [ctorStmt], [r.set(nonCtorExpr).toStmt()]));
    return r;
  }

  if (isDelegatedFactoryMetadata(meta)) {
    // This type is created with a delegated factory. If a type parameter is not specified, call
    // the factory instead.
    var delegateArgs = injectDependencies(meta.delegateDeps, meta.target); // Either call `new delegate(...)` or `delegate(...)` depending on meta.delegateType.

    var factoryExpr = new (meta.delegateType === R3FactoryDelegateType.Class ? InstantiateExpr : InvokeFunctionExpr)(meta.delegate, delegateArgs);
    retExpr = makeConditionalFactory(factoryExpr);
  } else if (isExpressionFactoryMetadata(meta)) {
    // TODO(alxhub): decide whether to lower the value here or in the caller
    retExpr = makeConditionalFactory(meta.expression);
  } else {
    retExpr = ctorExpr;
  }

  if (retExpr === null) {
    // The expression cannot be formed so render an `ɵɵinvalidFactory()` call.
    body.push(importExpr(Identifiers.invalidFactory).callFn([]).toStmt());
  } else if (baseFactoryVar !== null) {
    // This factory uses a base factory, so call `ɵɵgetInheritedFactory()` to compute it.
    var getInheritedFactoryCall = importExpr(Identifiers.getInheritedFactory).callFn([meta.internalType]); // Memoize the base factoryFn: `baseFactory || (baseFactory = ɵɵgetInheritedFactory(...))`

    var baseFactory = new BinaryOperatorExpr(BinaryOperator.Or, baseFactoryVar, baseFactoryVar.set(getInheritedFactoryCall));
    body.push(new ReturnStatement(baseFactory.callFn([typeForCtor])));
  } else {
    // This is straightforward factory, just return it.
    body.push(new ReturnStatement(retExpr));
  }

  var factoryFn = fn([new FnParam('t', DYNAMIC_TYPE)], body, INFERRED_TYPE, undefined, "".concat(meta.name, "_Factory"));

  if (baseFactoryVar !== null) {
    // There is a base factory variable so wrap its declaration along with the factory function into
    // an IIFE.
    factoryFn = fn([], [new DeclareVarStmt(baseFactoryVar.name), new ReturnStatement(factoryFn)]).callFn([],
    /* sourceSpan */
    undefined,
    /* pure */
    true);
  }

  return {
    expression: factoryFn,
    statements: [],
    type: createFactoryType(meta)
  };
}

function createFactoryType(meta) {
  var ctorDepsType = meta.deps !== null && meta.deps !== 'invalid' ? createCtorDepsType(meta.deps) : NONE_TYPE;
  return expressionType(importExpr(Identifiers.FactoryDeclaration, [typeWithParameters(meta.type.type, meta.typeArgumentCount), ctorDepsType]));
}

function injectDependencies(deps, target) {
  return deps.map(function (dep, index) {
    return compileInjectDependency(dep, target, index);
  });
}

function compileInjectDependency(dep, target, index) {
  // Interpret the dependency according to its resolved type.
  if (dep.token === null) {
    return importExpr(Identifiers.invalidFactoryDep).callFn([literal(index)]);
  } else if (dep.attributeNameType === null) {
    // Build up the injection flags according to the metadata.
    var flags = 0
    /* InjectFlags.Default */
    | (dep.self ? 2
    /* InjectFlags.Self */
    : 0) | (dep.skipSelf ? 4
    /* InjectFlags.SkipSelf */
    : 0) | (dep.host ? 1
    /* InjectFlags.Host */
    : 0) | (dep.optional ? 8
    /* InjectFlags.Optional */
    : 0) | (target === FactoryTarget$1.Pipe ? 16
    /* InjectFlags.ForPipe */
    : 0); // If this dependency is optional or otherwise has non-default flags, then additional
    // parameters describing how to inject the dependency must be passed to the inject function
    // that's being used.

    var flagsParam = flags !== 0
    /* InjectFlags.Default */
    || dep.optional ? literal(flags) : null; // Build up the arguments to the injectFn call.

    var injectArgs = [dep.token];

    if (flagsParam) {
      injectArgs.push(flagsParam);
    }

    var injectFn = getInjectFn(target);
    return importExpr(injectFn).callFn(injectArgs);
  } else {
    // The `dep.attributeTypeName` value is defined, which indicates that this is an `@Attribute()`
    // type dependency. For the generated JS we still want to use the `dep.token` value in case the
    // name given for the attribute is not a string literal. For example given `@Attribute(foo())`,
    // we want to generate `ɵɵinjectAttribute(foo())`.
    //
    // The `dep.attributeTypeName` is only actually used (in `createCtorDepType()`) to generate
    // typings.
    return importExpr(Identifiers.injectAttribute).callFn([dep.token]);
  }
}

function createCtorDepsType(deps) {
  var hasTypes = false;
  var attributeTypes = deps.map(function (dep) {
    var type = createCtorDepType(dep);

    if (type !== null) {
      hasTypes = true;
      return type;
    } else {
      return literal(null);
    }
  });

  if (hasTypes) {
    return expressionType(literalArr(attributeTypes));
  } else {
    return NONE_TYPE;
  }
}

function createCtorDepType(dep) {
  var entries = [];

  if (dep.attributeNameType !== null) {
    entries.push({
      key: 'attribute',
      value: dep.attributeNameType,
      quoted: false
    });
  }

  if (dep.optional) {
    entries.push({
      key: 'optional',
      value: literal(true),
      quoted: false
    });
  }

  if (dep.host) {
    entries.push({
      key: 'host',
      value: literal(true),
      quoted: false
    });
  }

  if (dep.self) {
    entries.push({
      key: 'self',
      value: literal(true),
      quoted: false
    });
  }

  if (dep.skipSelf) {
    entries.push({
      key: 'skipSelf',
      value: literal(true),
      quoted: false
    });
  }

  return entries.length > 0 ? literalMap(entries) : null;
}

function isDelegatedFactoryMetadata(meta) {
  return meta.delegateType !== undefined;
}

function isExpressionFactoryMetadata(meta) {
  return meta.expression !== undefined;
}

function getInjectFn(target) {
  switch (target) {
    case FactoryTarget$1.Component:
    case FactoryTarget$1.Directive:
    case FactoryTarget$1.Pipe:
      return Identifiers.directiveInject;

    case FactoryTarget$1.NgModule:
    case FactoryTarget$1.Injectable:
    default:
      return Identifiers.inject;
  }
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * This is an R3 `Node`-like wrapper for a raw `html.Comment` node. We do not currently
 * require the implementation of a visitor for Comments as they are only collected at
 * the top-level of the R3 AST, and only if `Render3ParseOptions['collectCommentNodes']`
 * is true.
 */


var Comment$1 = /*#__PURE__*/function () {
  function Comment$1(value, sourceSpan) {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, Comment$1);

    this.value = value;
    this.sourceSpan = sourceSpan;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(Comment$1, [{
    key: "visit",
    value: function visit(_visitor) {
      throw new Error('visit() not implemented for Comment');
    }
  }]);

  return Comment$1;
}();

var Text$3 = /*#__PURE__*/function () {
  function Text$3(value, sourceSpan) {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, Text$3);

    this.value = value;
    this.sourceSpan = sourceSpan;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(Text$3, [{
    key: "visit",
    value: function visit(visitor) {
      return visitor.visitText(this);
    }
  }]);

  return Text$3;
}();

var BoundText = /*#__PURE__*/function () {
  function BoundText(value, sourceSpan, i18n) {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, BoundText);

    this.value = value;
    this.sourceSpan = sourceSpan;
    this.i18n = i18n;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(BoundText, [{
    key: "visit",
    value: function visit(visitor) {
      return visitor.visitBoundText(this);
    }
  }]);

  return BoundText;
}();
/**
 * Represents a text attribute in the template.
 *
 * `valueSpan` may not be present in cases where there is no value `<div a></div>`.
 * `keySpan` may also not be present for synthetic attributes from ICU expansions.
 */


var TextAttribute = /*#__PURE__*/function () {
  function TextAttribute(name, value, sourceSpan, keySpan, valueSpan, i18n) {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, TextAttribute);

    this.name = name;
    this.value = value;
    this.sourceSpan = sourceSpan;
    this.keySpan = keySpan;
    this.valueSpan = valueSpan;
    this.i18n = i18n;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(TextAttribute, [{
    key: "visit",
    value: function visit(visitor) {
      return visitor.visitTextAttribute(this);
    }
  }]);

  return TextAttribute;
}();

var BoundAttribute = /*#__PURE__*/function () {
  function BoundAttribute(name, type, securityContext, value, unit, sourceSpan, keySpan, valueSpan, i18n) {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, BoundAttribute);

    this.name = name;
    this.type = type;
    this.securityContext = securityContext;
    this.value = value;
    this.unit = unit;
    this.sourceSpan = sourceSpan;
    this.keySpan = keySpan;
    this.valueSpan = valueSpan;
    this.i18n = i18n;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(BoundAttribute, [{
    key: "visit",
    value: function visit(visitor) {
      return visitor.visitBoundAttribute(this);
    }
  }], [{
    key: "fromBoundElementProperty",
    value: function fromBoundElementProperty(prop, i18n) {
      if (prop.keySpan === undefined) {
        throw new Error("Unexpected state: keySpan must be defined for bound attributes but was not for ".concat(prop.name, ": ").concat(prop.sourceSpan));
      }

      return new BoundAttribute(prop.name, prop.type, prop.securityContext, prop.value, prop.unit, prop.sourceSpan, prop.keySpan, prop.valueSpan, i18n);
    }
  }]);

  return BoundAttribute;
}();

var BoundEvent = /*#__PURE__*/function () {
  function BoundEvent(name, type, handler, target, phase, sourceSpan, handlerSpan, keySpan) {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, BoundEvent);

    this.name = name;
    this.type = type;
    this.handler = handler;
    this.target = target;
    this.phase = phase;
    this.sourceSpan = sourceSpan;
    this.handlerSpan = handlerSpan;
    this.keySpan = keySpan;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(BoundEvent, [{
    key: "visit",
    value: function visit(visitor) {
      return visitor.visitBoundEvent(this);
    }
  }], [{
    key: "fromParsedEvent",
    value: function fromParsedEvent(event) {
      var target = event.type === 0
      /* ParsedEventType.Regular */
      ? event.targetOrPhase : null;
      var phase = event.type === 1
      /* ParsedEventType.Animation */
      ? event.targetOrPhase : null;

      if (event.keySpan === undefined) {
        throw new Error("Unexpected state: keySpan must be defined for bound event but was not for ".concat(event.name, ": ").concat(event.sourceSpan));
      }

      return new BoundEvent(event.name, event.type, event.handler, target, phase, event.sourceSpan, event.handlerSpan, event.keySpan);
    }
  }]);

  return BoundEvent;
}();

var Element$1 = /*#__PURE__*/function () {
  function Element$1(name, attributes, inputs, outputs, children, references, sourceSpan, startSourceSpan, endSourceSpan, i18n) {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, Element$1);

    this.name = name;
    this.attributes = attributes;
    this.inputs = inputs;
    this.outputs = outputs;
    this.children = children;
    this.references = references;
    this.sourceSpan = sourceSpan;
    this.startSourceSpan = startSourceSpan;
    this.endSourceSpan = endSourceSpan;
    this.i18n = i18n;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(Element$1, [{
    key: "visit",
    value: function visit(visitor) {
      return visitor.visitElement(this);
    }
  }]);

  return Element$1;
}();

var Template = /*#__PURE__*/function () {
  function Template( // tagName is the name of the container element, if applicable.
  // `null` is a special case for when there is a structural directive on an `ng-template` so
  // the renderer can differentiate between the synthetic template and the one written in the
  // file.
  tagName, attributes, inputs, outputs, templateAttrs, children, references, variables, sourceSpan, startSourceSpan, endSourceSpan, i18n) {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, Template);

    this.tagName = tagName;
    this.attributes = attributes;
    this.inputs = inputs;
    this.outputs = outputs;
    this.templateAttrs = templateAttrs;
    this.children = children;
    this.references = references;
    this.variables = variables;
    this.sourceSpan = sourceSpan;
    this.startSourceSpan = startSourceSpan;
    this.endSourceSpan = endSourceSpan;
    this.i18n = i18n;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(Template, [{
    key: "visit",
    value: function visit(visitor) {
      return visitor.visitTemplate(this);
    }
  }]);

  return Template;
}();

var Content = /*#__PURE__*/function () {
  function Content(selector, attributes, sourceSpan, i18n) {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, Content);

    this.selector = selector;
    this.attributes = attributes;
    this.sourceSpan = sourceSpan;
    this.i18n = i18n;
    this.name = 'ng-content';
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(Content, [{
    key: "visit",
    value: function visit(visitor) {
      return visitor.visitContent(this);
    }
  }]);

  return Content;
}();

var Variable = /*#__PURE__*/function () {
  function Variable(name, value, sourceSpan, keySpan, valueSpan) {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, Variable);

    this.name = name;
    this.value = value;
    this.sourceSpan = sourceSpan;
    this.keySpan = keySpan;
    this.valueSpan = valueSpan;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(Variable, [{
    key: "visit",
    value: function visit(visitor) {
      return visitor.visitVariable(this);
    }
  }]);

  return Variable;
}();

var Reference = /*#__PURE__*/function () {
  function Reference(name, value, sourceSpan, keySpan, valueSpan) {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, Reference);

    this.name = name;
    this.value = value;
    this.sourceSpan = sourceSpan;
    this.keySpan = keySpan;
    this.valueSpan = valueSpan;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(Reference, [{
    key: "visit",
    value: function visit(visitor) {
      return visitor.visitReference(this);
    }
  }]);

  return Reference;
}();

var Icu$1 = /*#__PURE__*/function () {
  function Icu$1(vars, placeholders, sourceSpan, i18n) {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, Icu$1);

    this.vars = vars;
    this.placeholders = placeholders;
    this.sourceSpan = sourceSpan;
    this.i18n = i18n;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(Icu$1, [{
    key: "visit",
    value: function visit(visitor) {
      return visitor.visitIcu(this);
    }
  }]);

  return Icu$1;
}();

var NullVisitor = /*#__PURE__*/function () {
  function NullVisitor() {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, NullVisitor);
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(NullVisitor, [{
    key: "visitElement",
    value: function visitElement(element) {}
  }, {
    key: "visitTemplate",
    value: function visitTemplate(template) {}
  }, {
    key: "visitContent",
    value: function visitContent(content) {}
  }, {
    key: "visitVariable",
    value: function visitVariable(variable) {}
  }, {
    key: "visitReference",
    value: function visitReference(reference) {}
  }, {
    key: "visitTextAttribute",
    value: function visitTextAttribute(attribute) {}
  }, {
    key: "visitBoundAttribute",
    value: function visitBoundAttribute(attribute) {}
  }, {
    key: "visitBoundEvent",
    value: function visitBoundEvent(attribute) {}
  }, {
    key: "visitText",
    value: function visitText(text) {}
  }, {
    key: "visitBoundText",
    value: function visitBoundText(text) {}
  }, {
    key: "visitIcu",
    value: function visitIcu(icu) {}
  }]);

  return NullVisitor;
}();

var RecursiveVisitor$1 = /*#__PURE__*/function () {
  function RecursiveVisitor$1() {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, RecursiveVisitor$1);
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(RecursiveVisitor$1, [{
    key: "visitElement",
    value: function visitElement(element) {
      visitAll$1(this, element.attributes);
      visitAll$1(this, element.inputs);
      visitAll$1(this, element.outputs);
      visitAll$1(this, element.children);
      visitAll$1(this, element.references);
    }
  }, {
    key: "visitTemplate",
    value: function visitTemplate(template) {
      visitAll$1(this, template.attributes);
      visitAll$1(this, template.inputs);
      visitAll$1(this, template.outputs);
      visitAll$1(this, template.children);
      visitAll$1(this, template.references);
      visitAll$1(this, template.variables);
    }
  }, {
    key: "visitContent",
    value: function visitContent(content) {}
  }, {
    key: "visitVariable",
    value: function visitVariable(variable) {}
  }, {
    key: "visitReference",
    value: function visitReference(reference) {}
  }, {
    key: "visitTextAttribute",
    value: function visitTextAttribute(attribute) {}
  }, {
    key: "visitBoundAttribute",
    value: function visitBoundAttribute(attribute) {}
  }, {
    key: "visitBoundEvent",
    value: function visitBoundEvent(attribute) {}
  }, {
    key: "visitText",
    value: function visitText(text) {}
  }, {
    key: "visitBoundText",
    value: function visitBoundText(text) {}
  }, {
    key: "visitIcu",
    value: function visitIcu(icu) {}
  }]);

  return RecursiveVisitor$1;
}();

var TransformVisitor = /*#__PURE__*/function () {
  function TransformVisitor() {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, TransformVisitor);
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(TransformVisitor, [{
    key: "visitElement",
    value: function visitElement(element) {
      var newAttributes = transformAll(this, element.attributes);
      var newInputs = transformAll(this, element.inputs);
      var newOutputs = transformAll(this, element.outputs);
      var newChildren = transformAll(this, element.children);
      var newReferences = transformAll(this, element.references);

      if (newAttributes != element.attributes || newInputs != element.inputs || newOutputs != element.outputs || newChildren != element.children || newReferences != element.references) {
        return new Element$1(element.name, newAttributes, newInputs, newOutputs, newChildren, newReferences, element.sourceSpan, element.startSourceSpan, element.endSourceSpan);
      }

      return element;
    }
  }, {
    key: "visitTemplate",
    value: function visitTemplate(template) {
      var newAttributes = transformAll(this, template.attributes);
      var newInputs = transformAll(this, template.inputs);
      var newOutputs = transformAll(this, template.outputs);
      var newTemplateAttrs = transformAll(this, template.templateAttrs);
      var newChildren = transformAll(this, template.children);
      var newReferences = transformAll(this, template.references);
      var newVariables = transformAll(this, template.variables);

      if (newAttributes != template.attributes || newInputs != template.inputs || newOutputs != template.outputs || newTemplateAttrs != template.templateAttrs || newChildren != template.children || newReferences != template.references || newVariables != template.variables) {
        return new Template(template.tagName, newAttributes, newInputs, newOutputs, newTemplateAttrs, newChildren, newReferences, newVariables, template.sourceSpan, template.startSourceSpan, template.endSourceSpan);
      }

      return template;
    }
  }, {
    key: "visitContent",
    value: function visitContent(content) {
      return content;
    }
  }, {
    key: "visitVariable",
    value: function visitVariable(variable) {
      return variable;
    }
  }, {
    key: "visitReference",
    value: function visitReference(reference) {
      return reference;
    }
  }, {
    key: "visitTextAttribute",
    value: function visitTextAttribute(attribute) {
      return attribute;
    }
  }, {
    key: "visitBoundAttribute",
    value: function visitBoundAttribute(attribute) {
      return attribute;
    }
  }, {
    key: "visitBoundEvent",
    value: function visitBoundEvent(attribute) {
      return attribute;
    }
  }, {
    key: "visitText",
    value: function visitText(text) {
      return text;
    }
  }, {
    key: "visitBoundText",
    value: function visitBoundText(text) {
      return text;
    }
  }, {
    key: "visitIcu",
    value: function visitIcu(icu) {
      return icu;
    }
  }]);

  return TransformVisitor;
}();

function visitAll$1(visitor, nodes) {
  var result = [];

  if (visitor.visit) {
    var _iterator4 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper_js__WEBPACK_IMPORTED_MODULE_9__["default"])(nodes),
        _step4;

    try {
      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
        var node = _step4.value;
        var newNode = visitor.visit(node) || node.visit(visitor);
      }
    } catch (err) {
      _iterator4.e(err);
    } finally {
      _iterator4.f();
    }
  } else {
    var _iterator5 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper_js__WEBPACK_IMPORTED_MODULE_9__["default"])(nodes),
        _step5;

    try {
      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
        var _node = _step5.value;

        var _newNode = _node.visit(visitor);

        if (_newNode) {
          result.push(_newNode);
        }
      }
    } catch (err) {
      _iterator5.e(err);
    } finally {
      _iterator5.f();
    }
  }

  return result;
}

function transformAll(visitor, nodes) {
  var result = [];
  var changed = false;

  var _iterator6 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper_js__WEBPACK_IMPORTED_MODULE_9__["default"])(nodes),
      _step6;

  try {
    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
      var node = _step6.value;
      var newNode = node.visit(visitor);

      if (newNode) {
        result.push(newNode);
      }

      changed = changed || newNode != node;
    }
  } catch (err) {
    _iterator6.e(err);
  } finally {
    _iterator6.f();
  }

  return changed ? result : nodes;
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */


var Message = /*#__PURE__*/(0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(
/**
 * @param nodes message AST
 * @param placeholders maps placeholder names to static content and their source spans
 * @param placeholderToMessage maps placeholder names to messages (used for nested ICU messages)
 * @param meaning
 * @param description
 * @param customId
 */
function Message(nodes, placeholders, placeholderToMessage, meaning, description, customId) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, Message);

  this.nodes = nodes;
  this.placeholders = placeholders;
  this.placeholderToMessage = placeholderToMessage;
  this.meaning = meaning;
  this.description = description;
  this.customId = customId;
  this.id = this.customId;
  /** The ids to use if there are no custom id and if `i18nLegacyMessageIdFormat` is not empty */

  this.legacyIds = [];
  this.messageString = serializeMessage(this.nodes);

  if (nodes.length) {
    this.sources = [{
      filePath: nodes[0].sourceSpan.start.file.url,
      startLine: nodes[0].sourceSpan.start.line + 1,
      startCol: nodes[0].sourceSpan.start.col + 1,
      endLine: nodes[nodes.length - 1].sourceSpan.end.line + 1,
      endCol: nodes[0].sourceSpan.start.col + 1
    }];
  } else {
    this.sources = [];
  }
});

var Text$2 = /*#__PURE__*/function () {
  function Text$2(value, sourceSpan) {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, Text$2);

    this.value = value;
    this.sourceSpan = sourceSpan;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(Text$2, [{
    key: "visit",
    value: function visit(visitor, context) {
      return visitor.visitText(this, context);
    }
  }]);

  return Text$2;
}(); // TODO(vicb): do we really need this node (vs an array) ?


var Container = /*#__PURE__*/function () {
  function Container(children, sourceSpan) {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, Container);

    this.children = children;
    this.sourceSpan = sourceSpan;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(Container, [{
    key: "visit",
    value: function visit(visitor, context) {
      return visitor.visitContainer(this, context);
    }
  }]);

  return Container;
}();

var Icu = /*#__PURE__*/function () {
  function Icu(expression, type, cases, sourceSpan) {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, Icu);

    this.expression = expression;
    this.type = type;
    this.cases = cases;
    this.sourceSpan = sourceSpan;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(Icu, [{
    key: "visit",
    value: function visit(visitor, context) {
      return visitor.visitIcu(this, context);
    }
  }]);

  return Icu;
}();

var TagPlaceholder = /*#__PURE__*/function () {
  function TagPlaceholder(tag, attrs, startName, closeName, children, isVoid, // TODO sourceSpan should cover all (we need a startSourceSpan and endSourceSpan)
  sourceSpan, startSourceSpan, endSourceSpan) {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, TagPlaceholder);

    this.tag = tag;
    this.attrs = attrs;
    this.startName = startName;
    this.closeName = closeName;
    this.children = children;
    this.isVoid = isVoid;
    this.sourceSpan = sourceSpan;
    this.startSourceSpan = startSourceSpan;
    this.endSourceSpan = endSourceSpan;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(TagPlaceholder, [{
    key: "visit",
    value: function visit(visitor, context) {
      return visitor.visitTagPlaceholder(this, context);
    }
  }]);

  return TagPlaceholder;
}();

var Placeholder = /*#__PURE__*/function () {
  function Placeholder(value, name, sourceSpan) {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, Placeholder);

    this.value = value;
    this.name = name;
    this.sourceSpan = sourceSpan;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(Placeholder, [{
    key: "visit",
    value: function visit(visitor, context) {
      return visitor.visitPlaceholder(this, context);
    }
  }]);

  return Placeholder;
}();

var IcuPlaceholder = /*#__PURE__*/function () {
  function IcuPlaceholder(value, name, sourceSpan) {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, IcuPlaceholder);

    this.value = value;
    this.name = name;
    this.sourceSpan = sourceSpan;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(IcuPlaceholder, [{
    key: "visit",
    value: function visit(visitor, context) {
      return visitor.visitIcuPlaceholder(this, context);
    }
  }]);

  return IcuPlaceholder;
}(); // Clone the AST


var CloneVisitor = /*#__PURE__*/function () {
  function CloneVisitor() {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, CloneVisitor);
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(CloneVisitor, [{
    key: "visitText",
    value: function visitText(text, context) {
      return new Text$2(text.value, text.sourceSpan);
    }
  }, {
    key: "visitContainer",
    value: function visitContainer(container, context) {
      var _this51 = this;

      var children = container.children.map(function (n) {
        return n.visit(_this51, context);
      });
      return new Container(children, container.sourceSpan);
    }
  }, {
    key: "visitIcu",
    value: function visitIcu(icu, context) {
      var _this52 = this;

      var cases = {};
      Object.keys(icu.cases).forEach(function (key) {
        return cases[key] = icu.cases[key].visit(_this52, context);
      });
      var msg = new Icu(icu.expression, icu.type, cases, icu.sourceSpan);
      msg.expressionPlaceholder = icu.expressionPlaceholder;
      return msg;
    }
  }, {
    key: "visitTagPlaceholder",
    value: function visitTagPlaceholder(ph, context) {
      var _this53 = this;

      var children = ph.children.map(function (n) {
        return n.visit(_this53, context);
      });
      return new TagPlaceholder(ph.tag, ph.attrs, ph.startName, ph.closeName, children, ph.isVoid, ph.sourceSpan, ph.startSourceSpan, ph.endSourceSpan);
    }
  }, {
    key: "visitPlaceholder",
    value: function visitPlaceholder(ph, context) {
      return new Placeholder(ph.value, ph.name, ph.sourceSpan);
    }
  }, {
    key: "visitIcuPlaceholder",
    value: function visitIcuPlaceholder(ph, context) {
      return new IcuPlaceholder(ph.value, ph.name, ph.sourceSpan);
    }
  }]);

  return CloneVisitor;
}(); // Visit all the nodes recursively


var RecurseVisitor = /*#__PURE__*/function () {
  function RecurseVisitor() {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, RecurseVisitor);
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(RecurseVisitor, [{
    key: "visitText",
    value: function visitText(text, context) {}
  }, {
    key: "visitContainer",
    value: function visitContainer(container, context) {
      var _this54 = this;

      container.children.forEach(function (child) {
        return child.visit(_this54);
      });
    }
  }, {
    key: "visitIcu",
    value: function visitIcu(icu, context) {
      var _this55 = this;

      Object.keys(icu.cases).forEach(function (k) {
        icu.cases[k].visit(_this55);
      });
    }
  }, {
    key: "visitTagPlaceholder",
    value: function visitTagPlaceholder(ph, context) {
      var _this56 = this;

      ph.children.forEach(function (child) {
        return child.visit(_this56);
      });
    }
  }, {
    key: "visitPlaceholder",
    value: function visitPlaceholder(ph, context) {}
  }, {
    key: "visitIcuPlaceholder",
    value: function visitIcuPlaceholder(ph, context) {}
  }]);

  return RecurseVisitor;
}();
/**
 * Serialize the message to the Localize backtick string format that would appear in compiled code.
 */


function serializeMessage(messageNodes) {
  var visitor = new LocalizeMessageStringVisitor();
  var str = messageNodes.map(function (n) {
    return n.visit(visitor);
  }).join('');
  return str;
}

var LocalizeMessageStringVisitor = /*#__PURE__*/function () {
  function LocalizeMessageStringVisitor() {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, LocalizeMessageStringVisitor);
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(LocalizeMessageStringVisitor, [{
    key: "visitText",
    value: function visitText(text) {
      return text.value;
    }
  }, {
    key: "visitContainer",
    value: function visitContainer(container) {
      var _this57 = this;

      return container.children.map(function (child) {
        return child.visit(_this57);
      }).join('');
    }
  }, {
    key: "visitIcu",
    value: function visitIcu(icu) {
      var _this58 = this;

      var strCases = Object.keys(icu.cases).map(function (k) {
        return "".concat(k, " {").concat(icu.cases[k].visit(_this58), "}");
      });
      return "{".concat(icu.expressionPlaceholder, ", ").concat(icu.type, ", ").concat(strCases.join(' '), "}");
    }
  }, {
    key: "visitTagPlaceholder",
    value: function visitTagPlaceholder(ph) {
      var _this59 = this;

      var children = ph.children.map(function (child) {
        return child.visit(_this59);
      }).join('');
      return "{$".concat(ph.startName, "}").concat(children, "{$").concat(ph.closeName, "}");
    }
  }, {
    key: "visitPlaceholder",
    value: function visitPlaceholder(ph) {
      return "{$".concat(ph.name, "}");
    }
  }, {
    key: "visitIcuPlaceholder",
    value: function visitIcuPlaceholder(ph) {
      return "{$".concat(ph.name, "}");
    }
  }]);

  return LocalizeMessageStringVisitor;
}();
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */


var Serializer = /*#__PURE__*/function () {
  function Serializer() {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, Serializer);
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(Serializer, [{
    key: "createNameMapper",
    value: // Creates a name mapper, see `PlaceholderMapper`
    // Returning `null` means that no name mapping is used.
    function createNameMapper(message) {
      return null;
    }
  }]);

  return Serializer;
}();
/**
 * A simple mapper that take a function to transform an internal name to a public name
 */


var SimplePlaceholderMapper = /*#__PURE__*/function (_RecurseVisitor) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(SimplePlaceholderMapper, _RecurseVisitor);

  var _super35 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(SimplePlaceholderMapper);

  // create a mapping from the message
  function SimplePlaceholderMapper(message, mapName) {
    var _this60;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, SimplePlaceholderMapper);

    _this60 = _super35.call(this);
    _this60.mapName = mapName;
    _this60.internalToPublic = {};
    _this60.publicToNextId = {};
    _this60.publicToInternal = {};
    message.nodes.forEach(function (node) {
      return node.visit((0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_assertThisInitialized_js__WEBPACK_IMPORTED_MODULE_4__["default"])(_this60));
    });
    return _this60;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(SimplePlaceholderMapper, [{
    key: "toPublicName",
    value: function toPublicName(internalName) {
      return this.internalToPublic.hasOwnProperty(internalName) ? this.internalToPublic[internalName] : null;
    }
  }, {
    key: "toInternalName",
    value: function toInternalName(publicName) {
      return this.publicToInternal.hasOwnProperty(publicName) ? this.publicToInternal[publicName] : null;
    }
  }, {
    key: "visitText",
    value: function visitText(text, context) {
      return null;
    }
  }, {
    key: "visitTagPlaceholder",
    value: function visitTagPlaceholder(ph, context) {
      this.visitPlaceholderName(ph.startName);

      (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_5__["default"])((0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_6__["default"])(SimplePlaceholderMapper.prototype), "visitTagPlaceholder", this).call(this, ph, context);

      this.visitPlaceholderName(ph.closeName);
    }
  }, {
    key: "visitPlaceholder",
    value: function visitPlaceholder(ph, context) {
      this.visitPlaceholderName(ph.name);
    }
  }, {
    key: "visitIcuPlaceholder",
    value: function visitIcuPlaceholder(ph, context) {
      this.visitPlaceholderName(ph.name);
    } // XMB placeholders could only contains A-Z, 0-9 and _

  }, {
    key: "visitPlaceholderName",
    value: function visitPlaceholderName(internalName) {
      if (!internalName || this.internalToPublic.hasOwnProperty(internalName)) {
        return;
      }

      var publicName = this.mapName(internalName);

      if (this.publicToInternal.hasOwnProperty(publicName)) {
        // Create a new XMB when it has already been used
        var nextId = this.publicToNextId[publicName];
        this.publicToNextId[publicName] = nextId + 1;
        publicName = "".concat(publicName, "_").concat(nextId);
      } else {
        this.publicToNextId[publicName] = 1;
      }

      this.internalToPublic[internalName] = publicName;
      this.publicToInternal[publicName] = internalName;
    }
  }]);

  return SimplePlaceholderMapper;
}(RecurseVisitor);
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */


var _Visitor$2 = /*#__PURE__*/function () {
  function _Visitor$2() {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, _Visitor$2);
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(_Visitor$2, [{
    key: "visitTag",
    value: function visitTag(tag) {
      var _this61 = this;

      var strAttrs = this._serializeAttributes(tag.attrs);

      if (tag.children.length == 0) {
        return "<".concat(tag.name).concat(strAttrs, "/>");
      }

      var strChildren = tag.children.map(function (node) {
        return node.visit(_this61);
      });
      return "<".concat(tag.name).concat(strAttrs, ">").concat(strChildren.join(''), "</").concat(tag.name, ">");
    }
  }, {
    key: "visitText",
    value: function visitText(text) {
      return text.value;
    }
  }, {
    key: "visitDeclaration",
    value: function visitDeclaration(decl) {
      return "<?xml".concat(this._serializeAttributes(decl.attrs), " ?>");
    }
  }, {
    key: "_serializeAttributes",
    value: function _serializeAttributes(attrs) {
      var strAttrs = Object.keys(attrs).map(function (name) {
        return "".concat(name, "=\"").concat(attrs[name], "\"");
      }).join(' ');
      return strAttrs.length > 0 ? ' ' + strAttrs : '';
    }
  }, {
    key: "visitDoctype",
    value: function visitDoctype(doctype) {
      return "<!DOCTYPE ".concat(doctype.rootTag, " [\n").concat(doctype.dtd, "\n]>");
    }
  }]);

  return _Visitor$2;
}();

var _visitor = new _Visitor$2();

function serialize(nodes) {
  return nodes.map(function (node) {
    return node.visit(_visitor);
  }).join('');
}

var Declaration = /*#__PURE__*/function () {
  function Declaration(unescapedAttrs) {
    var _this62 = this;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, Declaration);

    this.attrs = {};
    Object.keys(unescapedAttrs).forEach(function (k) {
      _this62.attrs[k] = escapeXml(unescapedAttrs[k]);
    });
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(Declaration, [{
    key: "visit",
    value: function visit(visitor) {
      return visitor.visitDeclaration(this);
    }
  }]);

  return Declaration;
}();

var Doctype = /*#__PURE__*/function () {
  function Doctype(rootTag, dtd) {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, Doctype);

    this.rootTag = rootTag;
    this.dtd = dtd;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(Doctype, [{
    key: "visit",
    value: function visit(visitor) {
      return visitor.visitDoctype(this);
    }
  }]);

  return Doctype;
}();

var Tag = /*#__PURE__*/function () {
  function Tag(name) {
    var _this63 = this;

    var unescapedAttrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var children = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, Tag);

    this.name = name;
    this.children = children;
    this.attrs = {};
    Object.keys(unescapedAttrs).forEach(function (k) {
      _this63.attrs[k] = escapeXml(unescapedAttrs[k]);
    });
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(Tag, [{
    key: "visit",
    value: function visit(visitor) {
      return visitor.visitTag(this);
    }
  }]);

  return Tag;
}();

var Text$1 = /*#__PURE__*/function () {
  function Text$1(unescapedValue) {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, Text$1);

    this.value = escapeXml(unescapedValue);
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(Text$1, [{
    key: "visit",
    value: function visit(visitor) {
      return visitor.visitText(this);
    }
  }]);

  return Text$1;
}();

var CR = /*#__PURE__*/function (_Text$) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(CR, _Text$);

  var _super36 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(CR);

  function CR() {
    var ws = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, CR);

    return _super36.call(this, "\n".concat(new Array(ws + 1).join(' ')));
  }

  return (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(CR);
}(Text$1);

var _ESCAPED_CHARS = [[/&/g, '&amp;'], [/"/g, '&quot;'], [/'/g, '&apos;'], [/</g, '&lt;'], [/>/g, '&gt;']]; // Escape `_ESCAPED_CHARS` characters in the given text with encoded entities

function escapeXml(text) {
  return _ESCAPED_CHARS.reduce(function (text, entry) {
    return text.replace(entry[0], entry[1]);
  }, text);
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */


var _MESSAGES_TAG = 'messagebundle';
var _MESSAGE_TAG = 'msg';
var _PLACEHOLDER_TAG$3 = 'ph';
var _EXAMPLE_TAG = 'ex';
var _SOURCE_TAG$2 = 'source';
var _DOCTYPE = "<!ELEMENT messagebundle (msg)*>\n<!ATTLIST messagebundle class CDATA #IMPLIED>\n\n<!ELEMENT msg (#PCDATA|ph|source)*>\n<!ATTLIST msg id CDATA #IMPLIED>\n<!ATTLIST msg seq CDATA #IMPLIED>\n<!ATTLIST msg name CDATA #IMPLIED>\n<!ATTLIST msg desc CDATA #IMPLIED>\n<!ATTLIST msg meaning CDATA #IMPLIED>\n<!ATTLIST msg obsolete (obsolete) #IMPLIED>\n<!ATTLIST msg xml:space (default|preserve) \"default\">\n<!ATTLIST msg is_hidden CDATA #IMPLIED>\n\n<!ELEMENT source (#PCDATA)>\n\n<!ELEMENT ph (#PCDATA|ex)*>\n<!ATTLIST ph name CDATA #REQUIRED>\n\n<!ELEMENT ex (#PCDATA)>";

var Xmb = /*#__PURE__*/function (_Serializer) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(Xmb, _Serializer);

  var _super37 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(Xmb);

  function Xmb() {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, Xmb);

    return _super37.apply(this, arguments);
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(Xmb, [{
    key: "write",
    value: function write(messages, locale) {
      var exampleVisitor = new ExampleVisitor();
      var visitor = new _Visitor$1();
      var rootNode = new Tag(_MESSAGES_TAG);
      messages.forEach(function (message) {
        var attrs = {
          id: message.id
        };

        if (message.description) {
          attrs['desc'] = message.description;
        }

        if (message.meaning) {
          attrs['meaning'] = message.meaning;
        }

        var sourceTags = [];
        message.sources.forEach(function (source) {
          sourceTags.push(new Tag(_SOURCE_TAG$2, {}, [new Text$1("".concat(source.filePath, ":").concat(source.startLine).concat(source.endLine !== source.startLine ? ',' + source.endLine : ''))]));
        });
        rootNode.children.push(new CR(2), new Tag(_MESSAGE_TAG, attrs, [].concat(sourceTags, (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(visitor.serialize(message.nodes)))));
      });
      rootNode.children.push(new CR());
      return serialize([new Declaration({
        version: '1.0',
        encoding: 'UTF-8'
      }), new CR(), new Doctype(_MESSAGES_TAG, _DOCTYPE), new CR(), exampleVisitor.addDefaultExamples(rootNode), new CR()]);
    }
  }, {
    key: "load",
    value: function load(content, url) {
      throw new Error('Unsupported');
    }
  }, {
    key: "digest",
    value: function digest(message) {
      return _digest2(message);
    }
  }, {
    key: "createNameMapper",
    value: function createNameMapper(message) {
      return new SimplePlaceholderMapper(message, toPublicName);
    }
  }]);

  return Xmb;
}(Serializer);

var _Visitor$1 = /*#__PURE__*/function () {
  function _Visitor$1() {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, _Visitor$1);
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(_Visitor$1, [{
    key: "visitText",
    value: function visitText(text, context) {
      return [new Text$1(text.value)];
    }
  }, {
    key: "visitContainer",
    value: function visitContainer(container, context) {
      var _this64 = this;

      var nodes = [];
      container.children.forEach(function (node) {
        return nodes.push.apply(nodes, (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(node.visit(_this64)));
      });
      return nodes;
    }
  }, {
    key: "visitIcu",
    value: function visitIcu(icu, context) {
      var _this65 = this;

      var nodes = [new Text$1("{".concat(icu.expressionPlaceholder, ", ").concat(icu.type, ", "))];
      Object.keys(icu.cases).forEach(function (c) {
        nodes.push.apply(nodes, [new Text$1("".concat(c, " {"))].concat((0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(icu.cases[c].visit(_this65)), [new Text$1("} ")]));
      });
      nodes.push(new Text$1("}"));
      return nodes;
    }
  }, {
    key: "visitTagPlaceholder",
    value: function visitTagPlaceholder(ph, context) {
      var startTagAsText = new Text$1("<".concat(ph.tag, ">"));
      var startEx = new Tag(_EXAMPLE_TAG, {}, [startTagAsText]); // TC requires PH to have a non empty EX, and uses the text node to show the "original" value.

      var startTagPh = new Tag(_PLACEHOLDER_TAG$3, {
        name: ph.startName
      }, [startEx, startTagAsText]);

      if (ph.isVoid) {
        // void tags have no children nor closing tags
        return [startTagPh];
      }

      var closeTagAsText = new Text$1("</".concat(ph.tag, ">"));
      var closeEx = new Tag(_EXAMPLE_TAG, {}, [closeTagAsText]); // TC requires PH to have a non empty EX, and uses the text node to show the "original" value.

      var closeTagPh = new Tag(_PLACEHOLDER_TAG$3, {
        name: ph.closeName
      }, [closeEx, closeTagAsText]);
      return [startTagPh].concat((0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(this.serialize(ph.children)), [closeTagPh]);
    }
  }, {
    key: "visitPlaceholder",
    value: function visitPlaceholder(ph, context) {
      var interpolationAsText = new Text$1("{{".concat(ph.value, "}}")); // Example tag needs to be not-empty for TC.

      var exTag = new Tag(_EXAMPLE_TAG, {}, [interpolationAsText]);
      return [// TC requires PH to have a non empty EX, and uses the text node to show the "original" value.
      new Tag(_PLACEHOLDER_TAG$3, {
        name: ph.name
      }, [exTag, interpolationAsText])];
    }
  }, {
    key: "visitIcuPlaceholder",
    value: function visitIcuPlaceholder(ph, context) {
      var icuExpression = ph.value.expression;
      var icuType = ph.value.type;
      var icuCases = Object.keys(ph.value.cases).map(function (value) {
        return value + ' {...}';
      }).join(' ');
      var icuAsText = new Text$1("{".concat(icuExpression, ", ").concat(icuType, ", ").concat(icuCases, "}"));
      var exTag = new Tag(_EXAMPLE_TAG, {}, [icuAsText]);
      return [// TC requires PH to have a non empty EX, and uses the text node to show the "original" value.
      new Tag(_PLACEHOLDER_TAG$3, {
        name: ph.name
      }, [exTag, icuAsText])];
    }
  }, {
    key: "serialize",
    value: function serialize(nodes) {
      var _ref4,
          _this66 = this;

      return (_ref4 = []).concat.apply(_ref4, (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(nodes.map(function (node) {
        return node.visit(_this66);
      })));
    }
  }]);

  return _Visitor$1;
}();

function _digest2(message) {
  return decimalDigest(message);
} // TC requires at least one non-empty example on placeholders


var ExampleVisitor = /*#__PURE__*/function () {
  function ExampleVisitor() {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, ExampleVisitor);
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(ExampleVisitor, [{
    key: "addDefaultExamples",
    value: function addDefaultExamples(node) {
      node.visit(this);
      return node;
    }
  }, {
    key: "visitTag",
    value: function visitTag(tag) {
      var _this67 = this;

      if (tag.name === _PLACEHOLDER_TAG$3) {
        if (!tag.children || tag.children.length == 0) {
          var exText = new Text$1(tag.attrs['name'] || '...');
          tag.children = [new Tag(_EXAMPLE_TAG, {}, [exText])];
        }
      } else if (tag.children) {
        tag.children.forEach(function (node) {
          return node.visit(_this67);
        });
      }
    }
  }, {
    key: "visitText",
    value: function visitText(text) {}
  }, {
    key: "visitDeclaration",
    value: function visitDeclaration(decl) {}
  }, {
    key: "visitDoctype",
    value: function visitDoctype(doctype) {}
  }]);

  return ExampleVisitor;
}(); // XMB/XTB placeholders can only contain A-Z, 0-9 and _


function toPublicName(internalName) {
  return internalName.toUpperCase().replace(/[^A-Z0-9_]/g, '_');
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/* Closure variables holding messages must be named `MSG_[A-Z0-9]+` */


var CLOSURE_TRANSLATION_VAR_PREFIX = 'MSG_';
/**
 * Prefix for non-`goog.getMsg` i18n-related vars.
 * Note: the prefix uses lowercase characters intentionally due to a Closure behavior that
 * considers variables like `I18N_0` as constants and throws an error when their value changes.
 */

var TRANSLATION_VAR_PREFIX = 'i18n_';
/** Name of the i18n attributes **/

var I18N_ATTR = 'i18n';
var I18N_ATTR_PREFIX = 'i18n-';
/** Prefix of var expressions used in ICUs */

var I18N_ICU_VAR_PREFIX = 'VAR_';
/** Prefix of ICU expressions for post processing */

var I18N_ICU_MAPPING_PREFIX = 'I18N_EXP_';
/** Placeholder wrapper for i18n expressions **/

var I18N_PLACEHOLDER_SYMBOL = '�';

function isI18nAttribute(name) {
  return name === I18N_ATTR || name.startsWith(I18N_ATTR_PREFIX);
}

function isI18nRootNode(meta) {
  return meta instanceof Message;
}

function isSingleI18nIcu(meta) {
  return isI18nRootNode(meta) && meta.nodes.length === 1 && meta.nodes[0] instanceof Icu;
}

function hasI18nMeta(node) {
  return !!node.i18n;
}

function hasI18nAttrs(element) {
  return element.attrs.some(function (attr) {
    return isI18nAttribute(attr.name);
  });
}

function icuFromI18nMessage(message) {
  return message.nodes[0];
}

function wrapI18nPlaceholder(content) {
  var contextId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var blockId = contextId > 0 ? ":".concat(contextId) : '';
  return "".concat(I18N_PLACEHOLDER_SYMBOL).concat(content).concat(blockId).concat(I18N_PLACEHOLDER_SYMBOL);
}

function assembleI18nBoundString(strings) {
  var bindingStartIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var contextId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  if (!strings.length) return '';
  var acc = '';
  var lastIdx = strings.length - 1;

  for (var i = 0; i < lastIdx; i++) {
    acc += "".concat(strings[i]).concat(wrapI18nPlaceholder(bindingStartIndex + i, contextId));
  }

  acc += strings[lastIdx];
  return acc;
}

function getSeqNumberGenerator() {
  var startsAt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var current = startsAt;
  return function () {
    return current++;
  };
}

function placeholdersToParams(placeholders) {
  var params = {};
  placeholders.forEach(function (values, key) {
    params[key] = literal(values.length > 1 ? "[".concat(values.join('|'), "]") : values[0]);
  });
  return params;
}

function updatePlaceholderMap(map, name) {
  var current = map.get(name) || [];

  for (var _len2 = arguments.length, values = new Array(_len2 > 2 ? _len2 - 2 : 0), _key3 = 2; _key3 < _len2; _key3++) {
    values[_key3 - 2] = arguments[_key3];
  }

  current.push.apply(current, values);
  map.set(name, current);
}

function assembleBoundTextPlaceholders(meta) {
  var bindingStartIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var contextId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var startIdx = bindingStartIndex;
  var placeholders = new Map();
  var node = meta instanceof Message ? meta.nodes.find(function (node) {
    return node instanceof Container;
  }) : meta;

  if (node) {
    node.children.filter(function (child) {
      return child instanceof Placeholder;
    }).forEach(function (child, idx) {
      var content = wrapI18nPlaceholder(startIdx + idx, contextId);
      updatePlaceholderMap(placeholders, child.name, content);
    });
  }

  return placeholders;
}
/**
 * Format the placeholder names in a map of placeholders to expressions.
 *
 * The placeholder names are converted from "internal" format (e.g. `START_TAG_DIV_1`) to "external"
 * format (e.g. `startTagDiv_1`).
 *
 * @param params A map of placeholder names to expressions.
 * @param useCamelCase whether to camelCase the placeholder name when formatting.
 * @returns A new map of formatted placeholder names to expressions.
 */


function formatI18nPlaceholderNamesInMap() {
  var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var useCamelCase = arguments.length > 1 ? arguments[1] : undefined;
  var _params = {};

  if (params && Object.keys(params).length) {
    Object.keys(params).forEach(function (key) {
      return _params[formatI18nPlaceholderName(key, useCamelCase)] = params[key];
    });
  }

  return _params;
}
/**
 * Converts internal placeholder names to public-facing format
 * (for example to use in goog.getMsg call).
 * Example: `START_TAG_DIV_1` is converted to `startTagDiv_1`.
 *
 * @param name The placeholder name that should be formatted
 * @returns Formatted placeholder name
 */


function formatI18nPlaceholderName(name) {
  var useCamelCase = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var publicName = toPublicName(name);

  if (!useCamelCase) {
    return publicName;
  }

  var chunks = publicName.split('_');

  if (chunks.length === 1) {
    // if no "_" found - just lowercase the value
    return name.toLowerCase();
  }

  var postfix; // eject last element if it's a number

  if (/^\d+$/.test(chunks[chunks.length - 1])) {
    postfix = chunks.pop();
  }

  var raw = chunks.shift().toLowerCase();

  if (chunks.length) {
    raw += chunks.map(function (c) {
      return c.charAt(0).toUpperCase() + c.slice(1).toLowerCase();
    }).join('');
  }

  return postfix ? "".concat(raw, "_").concat(postfix) : raw;
}
/**
 * Generates a prefix for translation const name.
 *
 * @param extra Additional local prefix that should be injected into translation var name
 * @returns Complete translation const prefix
 */


function getTranslationConstPrefix(extra) {
  return "".concat(CLOSURE_TRANSLATION_VAR_PREFIX).concat(extra).toUpperCase();
}
/**
 * Generate AST to declare a variable. E.g. `var I18N_1;`.
 * @param variable the name of the variable to declare.
 */


function declareI18nVariable(variable) {
  return new DeclareVarStmt(variable.name, undefined, INFERRED_TYPE, undefined, variable.sourceSpan);
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * Checks whether an object key contains potentially unsafe chars, thus the key should be wrapped in
 * quotes. Note: we do not wrap all keys into quotes, as it may have impact on minification and may
 * bot work in some cases when object keys are mangled by minifier.
 *
 * TODO(FW-1136): this is a temporary solution, we need to come up with a better way of working with
 * inputs that contain potentially unsafe chars.
 */


var UNSAFE_OBJECT_KEY_NAME_REGEXP = /[-.]/;
/** Name of the temporary to use during data binding */

var TEMPORARY_NAME = '_t';
/** Name of the context parameter passed into a template function */

var CONTEXT_NAME = 'ctx';
/** Name of the RenderFlag passed into a template function */

var RENDER_FLAGS = 'rf';
/** The prefix reference variables */

var REFERENCE_PREFIX = '_r';
/** The name of the implicit context reference */

var IMPLICIT_REFERENCE = '$implicit';
/** Non bindable attribute name **/

var NON_BINDABLE_ATTR = 'ngNonBindable';
/** Name for the variable keeping track of the context returned by `ɵɵrestoreView`. */

var RESTORED_VIEW_CONTEXT_NAME = 'restoredCtx';
/**
 * Maximum length of a single instruction chain. Because our output AST uses recursion, we're
 * limited in how many expressions we can nest before we reach the call stack limit. This
 * length is set very conservatively in order to reduce the chance of problems.
 */

var MAX_CHAIN_LENGTH = 500;
/** Instructions that support chaining. */

var CHAINABLE_INSTRUCTIONS = new Set([Identifiers.element, Identifiers.elementStart, Identifiers.elementEnd, Identifiers.elementContainer, Identifiers.elementContainerStart, Identifiers.elementContainerEnd, Identifiers.i18nExp, Identifiers.listener, Identifiers.classProp, Identifiers.syntheticHostListener, Identifiers.hostProperty, Identifiers.syntheticHostProperty, Identifiers.property, Identifiers.propertyInterpolate1, Identifiers.propertyInterpolate2, Identifiers.propertyInterpolate3, Identifiers.propertyInterpolate4, Identifiers.propertyInterpolate5, Identifiers.propertyInterpolate6, Identifiers.propertyInterpolate7, Identifiers.propertyInterpolate8, Identifiers.propertyInterpolateV, Identifiers.attribute, Identifiers.attributeInterpolate1, Identifiers.attributeInterpolate2, Identifiers.attributeInterpolate3, Identifiers.attributeInterpolate4, Identifiers.attributeInterpolate5, Identifiers.attributeInterpolate6, Identifiers.attributeInterpolate7, Identifiers.attributeInterpolate8, Identifiers.attributeInterpolateV, Identifiers.styleProp, Identifiers.stylePropInterpolate1, Identifiers.stylePropInterpolate2, Identifiers.stylePropInterpolate3, Identifiers.stylePropInterpolate4, Identifiers.stylePropInterpolate5, Identifiers.stylePropInterpolate6, Identifiers.stylePropInterpolate7, Identifiers.stylePropInterpolate8, Identifiers.stylePropInterpolateV, Identifiers.textInterpolate, Identifiers.textInterpolate1, Identifiers.textInterpolate2, Identifiers.textInterpolate3, Identifiers.textInterpolate4, Identifiers.textInterpolate5, Identifiers.textInterpolate6, Identifiers.textInterpolate7, Identifiers.textInterpolate8, Identifiers.textInterpolateV]);
/** Generates a call to a single instruction. */

function invokeInstruction(span, reference, params) {
  return importExpr(reference, null, span).callFn(params, span);
}
/**
 * Creates an allocator for a temporary variable.
 *
 * A variable declaration is added to the statements the first time the allocator is invoked.
 */


function temporaryAllocator(statements, name) {
  var temp = null;
  return function () {
    if (!temp) {
      statements.push(new DeclareVarStmt(TEMPORARY_NAME, undefined, DYNAMIC_TYPE));
      temp = variable(name);
    }

    return temp;
  };
}

function invalid(arg) {
  throw new Error("Invalid state: Visitor ".concat(this.constructor.name, " doesn't handle ").concat(arg.constructor.name));
}

function asLiteral(value) {
  if (Array.isArray(value)) {
    return literalArr(value.map(asLiteral));
  }

  return literal(value, INFERRED_TYPE);
}

function conditionallyCreateMapObjectLiteral(keys, keepDeclared) {
  if (Object.getOwnPropertyNames(keys).length > 0) {
    return mapToExpression(keys, keepDeclared);
  }

  return null;
}

function mapToExpression(map, keepDeclared) {
  return literalMap(Object.getOwnPropertyNames(map).map(function (key) {
    // canonical syntax: `dirProp: publicProp`
    // if there is no `:`, use dirProp = elProp
    var value = map[key];
    var declaredName;
    var publicName;
    var minifiedName;
    var needsDeclaredName;

    if (Array.isArray(value)) {
      var _value = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_slicedToArray_js__WEBPACK_IMPORTED_MODULE_3__["default"])(value, 2);

      publicName = _value[0];
      declaredName = _value[1];
      minifiedName = key;
      needsDeclaredName = publicName !== declaredName;
    } else {
      var _splitAtColon = splitAtColon(key, [key, value]);

      var _splitAtColon2 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_slicedToArray_js__WEBPACK_IMPORTED_MODULE_3__["default"])(_splitAtColon, 2);

      declaredName = _splitAtColon2[0];
      publicName = _splitAtColon2[1];
      minifiedName = declaredName; // Only include the declared name if extracted from the key, i.e. the key contains a colon.
      // Otherwise the declared name should be omitted even if it is different from the public name,
      // as it may have already been minified.

      needsDeclaredName = publicName !== declaredName && key.includes(':');
    }

    return {
      key: minifiedName,
      // put quotes around keys that contain potentially unsafe characters
      quoted: UNSAFE_OBJECT_KEY_NAME_REGEXP.test(minifiedName),
      value: keepDeclared && needsDeclaredName ? literalArr([asLiteral(publicName), asLiteral(declaredName)]) : asLiteral(publicName)
    };
  }));
}
/**
 *  Remove trailing null nodes as they are implied.
 */


function trimTrailingNulls(parameters) {
  while (isNull(parameters[parameters.length - 1])) {
    parameters.pop();
  }

  return parameters;
}

function getQueryPredicate(query, constantPool) {
  if (Array.isArray(query.predicate)) {
    var predicate = [];
    query.predicate.forEach(function (selector) {
      // Each item in predicates array may contain strings with comma-separated refs
      // (for ex. 'ref, ref1, ..., refN'), thus we extract individual refs and store them
      // as separate array entities
      var selectors = selector.split(',').map(function (token) {
        return literal(token.trim());
      });
      predicate.push.apply(predicate, (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(selectors));
    });
    return constantPool.getConstLiteral(literalArr(predicate), true);
  } else {
    // The original predicate may have been wrapped in a `forwardRef()` call.
    switch (query.predicate.forwardRef) {
      case 0
      /* ForwardRefHandling.None */
      :
      case 2
      /* ForwardRefHandling.Unwrapped */
      :
        return query.predicate.expression;

      case 1
      /* ForwardRefHandling.Wrapped */
      :
        return importExpr(Identifiers.resolveForwardRef).callFn([query.predicate.expression]);
    }
  }
}
/**
 * A representation for an object literal used during codegen of definition objects. The generic
 * type `T` allows to reference a documented type of the generated structure, such that the
 * property names that are set can be resolved to their documented declaration.
 */


var DefinitionMap = /*#__PURE__*/function () {
  function DefinitionMap() {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, DefinitionMap);

    this.values = [];
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(DefinitionMap, [{
    key: "set",
    value: function set(key, value) {
      if (value) {
        this.values.push({
          key: key,
          value: value,
          quoted: false
        });
      }
    }
  }, {
    key: "toLiteralMap",
    value: function toLiteralMap() {
      return literalMap(this.values);
    }
  }]);

  return DefinitionMap;
}();
/**
 * Extract a map of properties to values for a given element or template node, which can be used
 * by the directive matching machinery.
 *
 * @param elOrTpl the element or template in question
 * @return an object set up for directive matching. For attributes on the element/template, this
 * object maps a property name to its (static) value. For any bindings, this map simply maps the
 * property name to an empty string.
 */


function getAttrsForDirectiveMatching(elOrTpl) {
  var attributesMap = {};

  if (elOrTpl instanceof Template && elOrTpl.tagName !== 'ng-template') {
    elOrTpl.templateAttrs.forEach(function (a) {
      return attributesMap[a.name] = '';
    });
  } else {
    elOrTpl.attributes.forEach(function (a) {
      if (!isI18nAttribute(a.name)) {
        attributesMap[a.name] = a.value;
      }
    });
    elOrTpl.inputs.forEach(function (i) {
      attributesMap[i.name] = '';
    });
    elOrTpl.outputs.forEach(function (o) {
      attributesMap[o.name] = '';
    });
  }

  return attributesMap;
}
/**
 * Gets the number of arguments expected to be passed to a generated instruction in the case of
 * interpolation instructions.
 * @param interpolation An interpolation ast
 */


function getInterpolationArgsLength(interpolation) {
  var expressions = interpolation.expressions,
      strings = interpolation.strings;

  if (expressions.length === 1 && strings.length === 2 && strings[0] === '' && strings[1] === '') {
    // If the interpolation has one interpolated value, but the prefix and suffix are both empty
    // strings, we only pass one argument, to a special instruction like `propertyInterpolate` or
    // `textInterpolate`.
    return 1;
  } else {
    return expressions.length + strings.length;
  }
}
/**
 * Generates the final instruction call statements based on the passed in configuration.
 * Will try to chain instructions as much as possible, if chaining is supported.
 */


function getInstructionStatements(instructions) {
  var _a;

  var statements = [];
  var pendingExpression = null;
  var pendingExpressionType = null;
  var chainLength = 0;

  var _iterator7 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper_js__WEBPACK_IMPORTED_MODULE_9__["default"])(instructions),
      _step7;

  try {
    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
      var current = _step7.value;
      var resolvedParams = (_a = typeof current.paramsOrFn === 'function' ? current.paramsOrFn() : current.paramsOrFn) !== null && _a !== void 0 ? _a : [];
      var params = Array.isArray(resolvedParams) ? resolvedParams : [resolvedParams]; // If the current instruction is the same as the previous one
      // and it can be chained, add another call to the chain.

      if (chainLength < MAX_CHAIN_LENGTH && pendingExpressionType === current.reference && CHAINABLE_INSTRUCTIONS.has(pendingExpressionType)) {
        // We'll always have a pending expression when there's a pending expression type.
        pendingExpression = pendingExpression.callFn(params, pendingExpression.sourceSpan);
        chainLength++;
      } else {
        if (pendingExpression !== null) {
          statements.push(pendingExpression.toStmt());
        }

        pendingExpression = invokeInstruction(current.span, current.reference, params);
        pendingExpressionType = current.reference;
        chainLength = 0;
      }
    } // Since the current instruction adds the previous one to the statements,
    // we may be left with the final one at the end that is still pending.

  } catch (err) {
    _iterator7.e(err);
  } finally {
    _iterator7.f();
  }

  if (pendingExpression !== null) {
    statements.push(pendingExpression.toStmt());
  }

  return statements;
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */


function _compileInjectable(meta, resolveForwardRefs) {
  var result = null;
  var factoryMeta = {
    name: meta.name,
    type: meta.type,
    internalType: meta.internalType,
    typeArgumentCount: meta.typeArgumentCount,
    deps: [],
    target: FactoryTarget$1.Injectable
  };

  if (meta.useClass !== undefined) {
    // meta.useClass has two modes of operation. Either deps are specified, in which case `new` is
    // used to instantiate the class with dependencies injected, or deps are not specified and
    // the factory of the class is used to instantiate it.
    //
    // A special case exists for useClass: Type where Type is the injectable type itself and no
    // deps are specified, in which case 'useClass' is effectively ignored.
    var useClassOnSelf = meta.useClass.expression.isEquivalent(meta.internalType);
    var deps = undefined;

    if (meta.deps !== undefined) {
      deps = meta.deps;
    }

    if (deps !== undefined) {
      // factory: () => new meta.useClass(...deps)
      result = compileFactoryFunction(Object.assign(Object.assign({}, factoryMeta), {
        delegate: meta.useClass.expression,
        delegateDeps: deps,
        delegateType: R3FactoryDelegateType.Class
      }));
    } else if (useClassOnSelf) {
      result = compileFactoryFunction(factoryMeta);
    } else {
      result = {
        statements: [],
        expression: delegateToFactory(meta.type.value, meta.useClass.expression, resolveForwardRefs)
      };
    }
  } else if (meta.useFactory !== undefined) {
    if (meta.deps !== undefined) {
      result = compileFactoryFunction(Object.assign(Object.assign({}, factoryMeta), {
        delegate: meta.useFactory,
        delegateDeps: meta.deps || [],
        delegateType: R3FactoryDelegateType.Function
      }));
    } else {
      result = {
        statements: [],
        expression: fn([], [new ReturnStatement(meta.useFactory.callFn([]))])
      };
    }
  } else if (meta.useValue !== undefined) {
    // Note: it's safe to use `meta.useValue` instead of the `USE_VALUE in meta` check used for
    // client code because meta.useValue is an Expression which will be defined even if the actual
    // value is undefined.
    result = compileFactoryFunction(Object.assign(Object.assign({}, factoryMeta), {
      expression: meta.useValue.expression
    }));
  } else if (meta.useExisting !== undefined) {
    // useExisting is an `inject` call on the existing token.
    result = compileFactoryFunction(Object.assign(Object.assign({}, factoryMeta), {
      expression: importExpr(Identifiers.inject).callFn([meta.useExisting.expression])
    }));
  } else {
    result = {
      statements: [],
      expression: delegateToFactory(meta.type.value, meta.internalType, resolveForwardRefs)
    };
  }

  var token = meta.internalType;
  var injectableProps = new DefinitionMap();
  injectableProps.set('token', token);
  injectableProps.set('factory', result.expression); // Only generate providedIn property if it has a non-null value

  if (meta.providedIn.expression.value !== null) {
    injectableProps.set('providedIn', convertFromMaybeForwardRefExpression(meta.providedIn));
  }

  var expression = importExpr(Identifiers.ɵɵdefineInjectable).callFn([injectableProps.toLiteralMap()], undefined, true);
  return {
    expression: expression,
    type: createInjectableType(meta),
    statements: result.statements
  };
}

function createInjectableType(meta) {
  return new ExpressionType(importExpr(Identifiers.InjectableDeclaration, [typeWithParameters(meta.type.type, meta.typeArgumentCount)]));
}

function delegateToFactory(type, internalType, unwrapForwardRefs) {
  if (type.node === internalType.node) {
    // The types are the same, so we can simply delegate directly to the type's factory.
    // ```
    // factory: type.ɵfac
    // ```
    return internalType.prop('ɵfac');
  }

  if (!unwrapForwardRefs) {
    // The type is not wrapped in a `forwardRef()`, so we create a simple factory function that
    // accepts a sub-type as an argument.
    // ```
    // factory: function(t) { return internalType.ɵfac(t); }
    // ```
    return createFactoryFunction(internalType);
  } // The internalType is actually wrapped in a `forwardRef()` so we need to resolve that before
  // calling its factory.
  // ```
  // factory: function(t) { return core.resolveForwardRef(type).ɵfac(t); }
  // ```


  var unwrappedType = importExpr(Identifiers.resolveForwardRef).callFn([internalType]);
  return createFactoryFunction(unwrappedType);
}

function createFactoryFunction(type) {
  return fn([new FnParam('t', DYNAMIC_TYPE)], [new ReturnStatement(type.prop('ɵfac').callFn([variable('t')]))]);
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */


var UNUSABLE_INTERPOLATION_REGEXPS = [/^\s*$/, /[<>]/, /^[{}]$/, /&(#|[a-z])/i, /^\/\// // comment
];

function assertInterpolationSymbols(identifier, value) {
  if (value != null && !(Array.isArray(value) && value.length == 2)) {
    throw new Error("Expected '".concat(identifier, "' to be an array, [start, end]."));
  } else if (value != null) {
    var start = value[0];
    var end = value[1]; // Check for unusable interpolation symbols

    UNUSABLE_INTERPOLATION_REGEXPS.forEach(function (regexp) {
      if (regexp.test(start) || regexp.test(end)) {
        throw new Error("['".concat(start, "', '").concat(end, "'] contains unusable interpolation symbol."));
      }
    });
  }
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */


var InterpolationConfig = /*#__PURE__*/function () {
  function InterpolationConfig(start, end) {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, InterpolationConfig);

    this.start = start;
    this.end = end;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(InterpolationConfig, null, [{
    key: "fromArray",
    value: function fromArray(markers) {
      if (!markers) {
        return DEFAULT_INTERPOLATION_CONFIG;
      }

      assertInterpolationSymbols('interpolation', markers);
      return new InterpolationConfig(markers[0], markers[1]);
    }
  }]);

  return InterpolationConfig;
}();

var DEFAULT_INTERPOLATION_CONFIG = new InterpolationConfig('{{', '}}');
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

var $EOF = 0;
var $BSPACE = 8;
var $TAB = 9;
var $LF = 10;
var $VTAB = 11;
var $FF = 12;
var $CR = 13;
var $SPACE = 32;
var $BANG = 33;
var $DQ = 34;
var $HASH = 35;
var $$ = 36;
var $PERCENT = 37;
var $AMPERSAND = 38;
var $SQ = 39;
var $LPAREN = 40;
var $RPAREN = 41;
var $STAR = 42;
var $PLUS = 43;
var $COMMA = 44;
var $MINUS = 45;
var $PERIOD = 46;
var $SLASH = 47;
var $COLON = 58;
var $SEMICOLON = 59;
var $LT = 60;
var $EQ = 61;
var $GT = 62;
var $QUESTION = 63;
var $0 = 48;
var $7 = 55;
var $9 = 57;
var $A = 65;
var $E = 69;
var $F = 70;
var $X = 88;
var $Z = 90;
var $LBRACKET = 91;
var $BACKSLASH = 92;
var $RBRACKET = 93;
var $CARET = 94;
var $_ = 95;
var $a = 97;
var $b = 98;
var $e = 101;
var $f = 102;
var $n = 110;
var $r = 114;
var $t = 116;
var $u = 117;
var $v = 118;
var $x = 120;
var $z = 122;
var $LBRACE = 123;
var $BAR = 124;
var $RBRACE = 125;
var $NBSP = 160;
var $PIPE = 124;
var $TILDA = 126;
var $AT = 64;
var $BT = 96;

function isWhitespace(code) {
  return code >= $TAB && code <= $SPACE || code == $NBSP;
}

function isDigit(code) {
  return $0 <= code && code <= $9;
}

function isAsciiLetter(code) {
  return code >= $a && code <= $z || code >= $A && code <= $Z;
}

function isAsciiHexDigit(code) {
  return code >= $a && code <= $f || code >= $A && code <= $F || isDigit(code);
}

function isNewLine(code) {
  return code === $LF || code === $CR;
}

function isOctalDigit(code) {
  return $0 <= code && code <= $7;
}

function isQuote(code) {
  return code === $SQ || code === $DQ || code === $BT;
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */


var ParseLocation = /*#__PURE__*/function () {
  function ParseLocation(file, offset, line, col) {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, ParseLocation);

    this.file = file;
    this.offset = offset;
    this.line = line;
    this.col = col;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(ParseLocation, [{
    key: "toString",
    value: function toString() {
      return this.offset != null ? "".concat(this.file.url, "@").concat(this.line, ":").concat(this.col) : this.file.url;
    }
  }, {
    key: "moveBy",
    value: function moveBy(delta) {
      var source = this.file.content;
      var len = source.length;
      var offset = this.offset;
      var line = this.line;
      var col = this.col;

      while (offset > 0 && delta < 0) {
        offset--;
        delta++;
        var ch = source.charCodeAt(offset);

        if (ch == $LF) {
          line--;
          var priorLine = source.substring(0, offset - 1).lastIndexOf(String.fromCharCode($LF));
          col = priorLine > 0 ? offset - priorLine : offset;
        } else {
          col--;
        }
      }

      while (offset < len && delta > 0) {
        var _ch = source.charCodeAt(offset);

        offset++;
        delta--;

        if (_ch == $LF) {
          line++;
          col = 0;
        } else {
          col++;
        }
      }

      return new ParseLocation(this.file, offset, line, col);
    } // Return the source around the location
    // Up to `maxChars` or `maxLines` on each side of the location

  }, {
    key: "getContext",
    value: function getContext(maxChars, maxLines) {
      var content = this.file.content;
      var startOffset = this.offset;

      if (startOffset != null) {
        if (startOffset > content.length - 1) {
          startOffset = content.length - 1;
        }

        var endOffset = startOffset;
        var ctxChars = 0;
        var ctxLines = 0;

        while (ctxChars < maxChars && startOffset > 0) {
          startOffset--;
          ctxChars++;

          if (content[startOffset] == '\n') {
            if (++ctxLines == maxLines) {
              break;
            }
          }
        }

        ctxChars = 0;
        ctxLines = 0;

        while (ctxChars < maxChars && endOffset < content.length - 1) {
          endOffset++;
          ctxChars++;

          if (content[endOffset] == '\n') {
            if (++ctxLines == maxLines) {
              break;
            }
          }
        }

        return {
          before: content.substring(startOffset, this.offset),
          after: content.substring(this.offset, endOffset + 1)
        };
      }

      return null;
    }
  }]);

  return ParseLocation;
}();

var ParseSourceFile = /*#__PURE__*/(0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(function ParseSourceFile(content, url) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, ParseSourceFile);

  this.content = content;
  this.url = url;
});

var ParseSourceSpan = /*#__PURE__*/function () {
  /**
   * Create an object that holds information about spans of tokens/nodes captured during
   * lexing/parsing of text.
   *
   * @param start
   * The location of the start of the span (having skipped leading trivia).
   * Skipping leading trivia makes source-spans more "user friendly", since things like HTML
   * elements will appear to begin at the start of the opening tag, rather than at the start of any
   * leading trivia, which could include newlines.
   *
   * @param end
   * The location of the end of the span.
   *
   * @param fullStart
   * The start of the token without skipping the leading trivia.
   * This is used by tooling that splits tokens further, such as extracting Angular interpolations
   * from text tokens. Such tooling creates new source-spans relative to the original token's
   * source-span. If leading trivia characters have been skipped then the new source-spans may be
   * incorrectly offset.
   *
   * @param details
   * Additional information (such as identifier names) that should be associated with the span.
   */
  function ParseSourceSpan(start, end) {
    var fullStart = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : start;
    var details = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, ParseSourceSpan);

    this.start = start;
    this.end = end;
    this.fullStart = fullStart;
    this.details = details;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(ParseSourceSpan, [{
    key: "toString",
    value: function toString() {
      return this.start.file.content.substring(this.start.offset, this.end.offset);
    }
  }]);

  return ParseSourceSpan;
}();

var ParseErrorLevel;

(function (ParseErrorLevel) {
  ParseErrorLevel[ParseErrorLevel["WARNING"] = 0] = "WARNING";
  ParseErrorLevel[ParseErrorLevel["ERROR"] = 1] = "ERROR";
})(ParseErrorLevel || (ParseErrorLevel = {}));

var ParseError = /*#__PURE__*/function () {
  function ParseError(span, msg) {
    var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ParseErrorLevel.ERROR;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, ParseError);

    this.span = span;
    this.msg = msg;
    this.level = level;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(ParseError, [{
    key: "contextualMessage",
    value: function contextualMessage() {
      var ctx = this.span.start.getContext(100, 3);
      return ctx ? "".concat(this.msg, " (\"").concat(ctx.before, "[").concat(ParseErrorLevel[this.level], " ->]").concat(ctx.after, "\")") : this.msg;
    }
  }, {
    key: "toString",
    value: function toString() {
      var details = this.span.details ? ", ".concat(this.span.details) : '';
      return "".concat(this.contextualMessage(), ": ").concat(this.span.start).concat(details);
    }
  }]);

  return ParseError;
}();
/**
 * Generates Source Span object for a given R3 Type for JIT mode.
 *
 * @param kind Component or Directive.
 * @param typeName name of the Component or Directive.
 * @param sourceUrl reference to Component or Directive source.
 * @returns instance of ParseSourceSpan that represent a given Component or Directive.
 */


function r3JitTypeSourceSpan(kind, typeName, sourceUrl) {
  var sourceFileName = "in ".concat(kind, " ").concat(typeName, " in ").concat(sourceUrl);
  var sourceFile = new ParseSourceFile('', sourceFileName);
  return new ParseSourceSpan(new ParseLocation(sourceFile, -1, -1, -1), new ParseLocation(sourceFile, -1, -1, -1));
}

var _anonymousTypeIndex = 0;

function identifierName(compileIdentifier) {
  if (!compileIdentifier || !compileIdentifier.reference) {
    return null;
  }

  var ref = compileIdentifier.reference;

  if (ref['__anonymousType']) {
    return ref['__anonymousType'];
  }

  if (ref['__forward_ref__']) {
    // We do not want to try to stringify a `forwardRef()` function because that would cause the
    // inner function to be evaluated too early, defeating the whole point of the `forwardRef`.
    return '__forward_ref__';
  }

  var identifier = stringify(ref);

  if (identifier.indexOf('(') >= 0) {
    // case: anonymous functions!
    identifier = "anonymous_".concat(_anonymousTypeIndex++);
    ref['__anonymousType'] = identifier;
  } else {
    identifier = sanitizeIdentifier(identifier);
  }

  return identifier;
}

function sanitizeIdentifier(name) {
  return name.replace(/\W/g, '_');
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * In TypeScript, tagged template functions expect a "template object", which is an array of
 * "cooked" strings plus a `raw` property that contains an array of "raw" strings. This is
 * typically constructed with a function called `__makeTemplateObject(cooked, raw)`, but it may not
 * be available in all environments.
 *
 * This is a JavaScript polyfill that uses __makeTemplateObject when it's available, but otherwise
 * creates an inline helper with the same functionality.
 *
 * In the inline function, if `Object.defineProperty` is available we use that to attach the `raw`
 * array.
 */


var makeTemplateObjectPolyfill = '(this&&this.__makeTemplateObject||function(e,t){return Object.defineProperty?Object.defineProperty(e,"raw",{value:t}):e.raw=t,e})';

var AbstractJsEmitterVisitor = /*#__PURE__*/function (_AbstractEmitterVisit) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(AbstractJsEmitterVisitor, _AbstractEmitterVisit);

  var _super38 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(AbstractJsEmitterVisitor);

  function AbstractJsEmitterVisitor() {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, AbstractJsEmitterVisitor);

    return _super38.call(this, false);
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(AbstractJsEmitterVisitor, [{
    key: "visitWrappedNodeExpr",
    value: function visitWrappedNodeExpr(ast, ctx) {
      throw new Error('Cannot emit a WrappedNodeExpr in Javascript.');
    }
  }, {
    key: "visitDeclareVarStmt",
    value: function visitDeclareVarStmt(stmt, ctx) {
      ctx.print(stmt, "var ".concat(stmt.name));

      if (stmt.value) {
        ctx.print(stmt, ' = ');
        stmt.value.visitExpression(this, ctx);
      }

      ctx.println(stmt, ";");
      return null;
    }
  }, {
    key: "visitTaggedTemplateExpr",
    value: function visitTaggedTemplateExpr(ast, ctx) {
      var _this68 = this;

      // The following convoluted piece of code is effectively the downlevelled equivalent of
      // ```
      // tag`...`
      // ```
      // which is effectively like:
      // ```
      // tag(__makeTemplateObject(cooked, raw), expression1, expression2, ...);
      // ```
      var elements = ast.template.elements;
      ast.tag.visitExpression(this, ctx);
      ctx.print(ast, "(".concat(makeTemplateObjectPolyfill, "("));
      ctx.print(ast, "[".concat(elements.map(function (part) {
        return escapeIdentifier(part.text, false);
      }).join(', '), "], "));
      ctx.print(ast, "[".concat(elements.map(function (part) {
        return escapeIdentifier(part.rawText, false);
      }).join(', '), "])"));
      ast.template.expressions.forEach(function (expression) {
        ctx.print(ast, ', ');
        expression.visitExpression(_this68, ctx);
      });
      ctx.print(ast, ')');
      return null;
    }
  }, {
    key: "visitFunctionExpr",
    value: function visitFunctionExpr(ast, ctx) {
      ctx.print(ast, "function".concat(ast.name ? ' ' + ast.name : '', "("));

      this._visitParams(ast.params, ctx);

      ctx.println(ast, ") {");
      ctx.incIndent();
      this.visitAllStatements(ast.statements, ctx);
      ctx.decIndent();
      ctx.print(ast, "}");
      return null;
    }
  }, {
    key: "visitDeclareFunctionStmt",
    value: function visitDeclareFunctionStmt(stmt, ctx) {
      ctx.print(stmt, "function ".concat(stmt.name, "("));

      this._visitParams(stmt.params, ctx);

      ctx.println(stmt, ") {");
      ctx.incIndent();
      this.visitAllStatements(stmt.statements, ctx);
      ctx.decIndent();
      ctx.println(stmt, "}");
      return null;
    }
  }, {
    key: "visitLocalizedString",
    value: function visitLocalizedString(ast, ctx) {
      var _this69 = this;

      // The following convoluted piece of code is effectively the downlevelled equivalent of
      // ```
      // $localize `...`
      // ```
      // which is effectively like:
      // ```
      // $localize(__makeTemplateObject(cooked, raw), expression1, expression2, ...);
      // ```
      ctx.print(ast, "$localize(".concat(makeTemplateObjectPolyfill, "("));
      var parts = [ast.serializeI18nHead()];

      for (var i = 1; i < ast.messageParts.length; i++) {
        parts.push(ast.serializeI18nTemplatePart(i));
      }

      ctx.print(ast, "[".concat(parts.map(function (part) {
        return escapeIdentifier(part.cooked, false);
      }).join(', '), "], "));
      ctx.print(ast, "[".concat(parts.map(function (part) {
        return escapeIdentifier(part.raw, false);
      }).join(', '), "])"));
      ast.expressions.forEach(function (expression) {
        ctx.print(ast, ', ');
        expression.visitExpression(_this69, ctx);
      });
      ctx.print(ast, ')');
      return null;
    }
  }, {
    key: "_visitParams",
    value: function _visitParams(params, ctx) {
      this.visitAllObjects(function (param) {
        return ctx.print(null, param.name);
      }, params, ctx, ',');
    }
  }]);

  return AbstractJsEmitterVisitor;
}(AbstractEmitterVisitor);
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * The Trusted Types policy, or null if Trusted Types are not
 * enabled/supported, or undefined if the policy has not been created yet.
 */


var policy;
/**
 * Returns the Trusted Types policy, or null if Trusted Types are not
 * enabled/supported. The first call to this function will create the policy.
 */

function getPolicy() {
  if (policy === undefined) {
    policy = null;

    if (_global.trustedTypes) {
      try {
        policy = _global.trustedTypes.createPolicy('angular#unsafe-jit', {
          createScript: function createScript(s) {
            return s;
          }
        });
      } catch (_a) {// trustedTypes.createPolicy throws if called with a name that is
        // already registered, even in report-only mode. Until the API changes,
        // catch the error not to break the applications functionally. In such
        // cases, the code will fall back to using strings.
      }
    }
  }

  return policy;
}
/**
 * Unsafely promote a string to a TrustedScript, falling back to strings when
 * Trusted Types are not available.
 * @security In particular, it must be assured that the provided string will
 * never cause an XSS vulnerability if used in a context that will be
 * interpreted and executed as a script by a browser, e.g. when calling eval.
 */


function trustedScriptFromString(script) {
  var _a;

  return ((_a = getPolicy()) === null || _a === void 0 ? void 0 : _a.createScript(script)) || script;
}
/**
 * Unsafely call the Function constructor with the given string arguments.
 * @security This is a security-sensitive function; any use of this function
 * must go through security review. In particular, it must be assured that it
 * is only called from the JIT compiler, as use in other code can lead to XSS
 * vulnerabilities.
 */


function newTrustedFunctionForJIT() {
  for (var _len3 = arguments.length, args = new Array(_len3), _key4 = 0; _key4 < _len3; _key4++) {
    args[_key4] = arguments[_key4];
  }

  if (!_global.trustedTypes) {
    // In environments that don't support Trusted Types, fall back to the most
    // straightforward implementation:
    return (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_construct_js__WEBPACK_IMPORTED_MODULE_2__["default"])(Function, args);
  } // Chrome currently does not support passing TrustedScript to the Function
  // constructor. The following implements the workaround proposed on the page
  // below, where the Chromium bug is also referenced:
  // https://github.com/w3c/webappsec-trusted-types/wiki/Trusted-Types-for-function-constructor


  var fnArgs = args.slice(0, -1).join(',');
  var fnBody = args[args.length - 1];
  var body = "(function anonymous(".concat(fnArgs, "\n) { ").concat(fnBody, "\n})"); // Using eval directly confuses the compiler and prevents this module from
  // being stripped out of JS binaries even if not used. The global['eval']
  // indirection fixes that.

  var fn = _global['eval'](trustedScriptFromString(body));

  if (fn.bind === undefined) {
    // Workaround for a browser bug that only exists in Chrome 83, where passing
    // a TrustedScript to eval just returns the TrustedScript back without
    // evaluating it. In that case, fall back to the most straightforward
    // implementation:
    return (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_construct_js__WEBPACK_IMPORTED_MODULE_2__["default"])(Function, args);
  } // To completely mimic the behavior of calling "new Function", two more
  // things need to happen:
  // 1. Stringifying the resulting function should return its source code


  fn.toString = function () {
    return body;
  }; // 2. When calling the resulting function, `this` should refer to `global`


  return fn.bind(_global); // When Trusted Types support in Function constructors is widely available,
  // the implementation of this function can be simplified to:
  // return new Function(...args.map(a => trustedScriptFromString(a)));
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * A helper class to manage the evaluation of JIT generated code.
 */


var JitEvaluator = /*#__PURE__*/function () {
  function JitEvaluator() {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, JitEvaluator);
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(JitEvaluator, [{
    key: "evaluateStatements",
    value:
    /**
     *
     * @param sourceUrl The URL of the generated code.
     * @param statements An array of Angular statement AST nodes to be evaluated.
     * @param refResolver Resolves `o.ExternalReference`s into values.
     * @param createSourceMaps If true then create a source-map for the generated code and include it
     * inline as a source-map comment.
     * @returns A map of all the variables in the generated code.
     */
    function evaluateStatements(sourceUrl, statements, refResolver, createSourceMaps) {
      var converter = new JitEmitterVisitor(refResolver);
      var ctx = EmitterVisitorContext.createRoot(); // Ensure generated code is in strict mode

      if (statements.length > 0 && !isUseStrictStatement(statements[0])) {
        statements = [literal('use strict').toStmt()].concat((0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(statements));
      }

      converter.visitAllStatements(statements, ctx);
      converter.createReturnStmt(ctx);
      return this.evaluateCode(sourceUrl, ctx, converter.getArgs(), createSourceMaps);
    }
    /**
     * Evaluate a piece of JIT generated code.
     * @param sourceUrl The URL of this generated code.
     * @param ctx A context object that contains an AST of the code to be evaluated.
     * @param vars A map containing the names and values of variables that the evaluated code might
     * reference.
     * @param createSourceMap If true then create a source-map for the generated code and include it
     * inline as a source-map comment.
     * @returns The result of evaluating the code.
     */

  }, {
    key: "evaluateCode",
    value: function evaluateCode(sourceUrl, ctx, vars, createSourceMap) {
      var fnBody = "\"use strict\";".concat(ctx.toSource(), "\n//# sourceURL=").concat(sourceUrl);
      var fnArgNames = [];
      var fnArgValues = [];

      for (var argName in vars) {
        fnArgValues.push(vars[argName]);
        fnArgNames.push(argName);
      }

      if (createSourceMap) {
        // using `new Function(...)` generates a header, 1 line of no arguments, 2 lines otherwise
        // E.g. ```
        // function anonymous(a,b,c
        // /**/) { ... }```
        // We don't want to hard code this fact, so we auto detect it via an empty function first.
        var emptyFn = newTrustedFunctionForJIT.apply(void 0, (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(fnArgNames.concat('return null;'))).toString();
        var headerLines = emptyFn.slice(0, emptyFn.indexOf('return null;')).split('\n').length - 1;
        fnBody += "\n".concat(ctx.toSourceMapGenerator(sourceUrl, headerLines).toJsComment());
      }

      var fn = newTrustedFunctionForJIT.apply(void 0, (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(fnArgNames.concat(fnBody)));
      return this.executeFunction(fn, fnArgValues);
    }
    /**
     * Execute a JIT generated function by calling it.
     *
     * This method can be overridden in tests to capture the functions that are generated
     * by this `JitEvaluator` class.
     *
     * @param fn A function to execute.
     * @param args The arguments to pass to the function being executed.
     * @returns The return value of the executed function.
     */

  }, {
    key: "executeFunction",
    value: function executeFunction(fn, args) {
      return fn.apply(void 0, (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(args));
    }
  }]);

  return JitEvaluator;
}();
/**
 * An Angular AST visitor that converts AST nodes into executable JavaScript code.
 */


var JitEmitterVisitor = /*#__PURE__*/function (_AbstractJsEmitterVis) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(JitEmitterVisitor, _AbstractJsEmitterVis);

  var _super39 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(JitEmitterVisitor);

  function JitEmitterVisitor(refResolver) {
    var _this70;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, JitEmitterVisitor);

    _this70 = _super39.call(this);
    _this70.refResolver = refResolver;
    _this70._evalArgNames = [];
    _this70._evalArgValues = [];
    _this70._evalExportedVars = [];
    return _this70;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(JitEmitterVisitor, [{
    key: "createReturnStmt",
    value: function createReturnStmt(ctx) {
      var stmt = new ReturnStatement(new LiteralMapExpr(this._evalExportedVars.map(function (resultVar) {
        return new LiteralMapEntry(resultVar, variable(resultVar), false);
      })));
      stmt.visitStatement(this, ctx);
    }
  }, {
    key: "getArgs",
    value: function getArgs() {
      var result = {};

      for (var i = 0; i < this._evalArgNames.length; i++) {
        result[this._evalArgNames[i]] = this._evalArgValues[i];
      }

      return result;
    }
  }, {
    key: "visitExternalExpr",
    value: function visitExternalExpr(ast, ctx) {
      this._emitReferenceToExternal(ast, this.refResolver.resolveExternalReference(ast.value), ctx);

      return null;
    }
  }, {
    key: "visitWrappedNodeExpr",
    value: function visitWrappedNodeExpr(ast, ctx) {
      this._emitReferenceToExternal(ast, ast.node, ctx);

      return null;
    }
  }, {
    key: "visitDeclareVarStmt",
    value: function visitDeclareVarStmt(stmt, ctx) {
      if (stmt.hasModifier(StmtModifier.Exported)) {
        this._evalExportedVars.push(stmt.name);
      }

      return (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_5__["default"])((0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_6__["default"])(JitEmitterVisitor.prototype), "visitDeclareVarStmt", this).call(this, stmt, ctx);
    }
  }, {
    key: "visitDeclareFunctionStmt",
    value: function visitDeclareFunctionStmt(stmt, ctx) {
      if (stmt.hasModifier(StmtModifier.Exported)) {
        this._evalExportedVars.push(stmt.name);
      }

      return (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_5__["default"])((0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_6__["default"])(JitEmitterVisitor.prototype), "visitDeclareFunctionStmt", this).call(this, stmt, ctx);
    }
  }, {
    key: "_emitReferenceToExternal",
    value: function _emitReferenceToExternal(ast, value, ctx) {
      var id = this._evalArgValues.indexOf(value);

      if (id === -1) {
        id = this._evalArgValues.length;

        this._evalArgValues.push(value);

        var name = identifierName({
          reference: value
        }) || 'val';

        this._evalArgNames.push("jit_".concat(name, "_").concat(id));
      }

      ctx.print(ast, this._evalArgNames[id]);
    }
  }]);

  return JitEmitterVisitor;
}(AbstractJsEmitterVisitor);

function isUseStrictStatement(statement) {
  return statement.isEquivalent(literal('use strict').toStmt());
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */


function _compileInjector(meta) {
  var definitionMap = new DefinitionMap();

  if (meta.providers !== null) {
    definitionMap.set('providers', meta.providers);
  }

  if (meta.imports.length > 0) {
    definitionMap.set('imports', literalArr(meta.imports));
  }

  var expression = importExpr(Identifiers.defineInjector).callFn([definitionMap.toLiteralMap()], undefined, true);
  var type = createInjectorType(meta);
  return {
    expression: expression,
    type: type,
    statements: []
  };
}

function createInjectorType(meta) {
  return new ExpressionType(importExpr(Identifiers.InjectorDeclaration, [new ExpressionType(meta.type.type)]));
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * Implementation of `CompileReflector` which resolves references to @angular/core
 * symbols at runtime, according to a consumer-provided mapping.
 *
 * Only supports `resolveExternalReference`, all other methods throw.
 */


var R3JitReflector = /*#__PURE__*/function () {
  function R3JitReflector(context) {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, R3JitReflector);

    this.context = context;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(R3JitReflector, [{
    key: "resolveExternalReference",
    value: function resolveExternalReference(ref) {
      // This reflector only handles @angular/core imports.
      if (ref.moduleName !== '@angular/core') {
        throw new Error("Cannot resolve external reference to ".concat(ref.moduleName, ", only references to @angular/core are supported."));
      }

      if (!this.context.hasOwnProperty(ref.name)) {
        throw new Error("No value provided for @angular/core symbol '".concat(ref.name, "'."));
      }

      return this.context[ref.name];
    }
  }]);

  return R3JitReflector;
}();
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * How the selector scope of an NgModule (its declarations, imports, and exports) should be emitted
 * as a part of the NgModule definition.
 */


var R3SelectorScopeMode;

(function (R3SelectorScopeMode) {
  /**
   * Emit the declarations inline into the module definition.
   *
   * This option is useful in certain contexts where it's known that JIT support is required. The
   * tradeoff here is that this emit style prevents directives and pipes from being tree-shaken if
   * they are unused, but the NgModule is used.
   */
  R3SelectorScopeMode[R3SelectorScopeMode["Inline"] = 0] = "Inline";
  /**
   * Emit the declarations using a side effectful function call, `ɵɵsetNgModuleScope`, that is
   * guarded with the `ngJitMode` flag.
   *
   * This form of emit supports JIT and can be optimized away if the `ngJitMode` flag is set to
   * false, which allows unused directives and pipes to be tree-shaken.
   */

  R3SelectorScopeMode[R3SelectorScopeMode["SideEffect"] = 1] = "SideEffect";
  /**
   * Don't generate selector scopes at all.
   *
   * This is useful for contexts where JIT support is known to be unnecessary.
   */

  R3SelectorScopeMode[R3SelectorScopeMode["Omit"] = 2] = "Omit";
})(R3SelectorScopeMode || (R3SelectorScopeMode = {}));
/**
 * Construct an `R3NgModuleDef` for the given `R3NgModuleMetadata`.
 */


function _compileNgModule(meta) {
  var adjacentType = meta.adjacentType,
      internalType = meta.internalType,
      bootstrap = meta.bootstrap,
      declarations = meta.declarations,
      imports = meta.imports,
      exports = meta.exports,
      schemas = meta.schemas,
      containsForwardDecls = meta.containsForwardDecls,
      selectorScopeMode = meta.selectorScopeMode,
      id = meta.id;
  var statements = [];
  var definitionMap = new DefinitionMap();
  definitionMap.set('type', internalType);

  if (bootstrap.length > 0) {
    definitionMap.set('bootstrap', refsToArray(bootstrap, containsForwardDecls));
  }

  if (selectorScopeMode === R3SelectorScopeMode.Inline) {
    // If requested to emit scope information inline, pass the `declarations`, `imports` and
    // `exports` to the `ɵɵdefineNgModule()` call directly.
    if (declarations.length > 0) {
      definitionMap.set('declarations', refsToArray(declarations, containsForwardDecls));
    }

    if (imports.length > 0) {
      definitionMap.set('imports', refsToArray(imports, containsForwardDecls));
    }

    if (exports.length > 0) {
      definitionMap.set('exports', refsToArray(exports, containsForwardDecls));
    }
  } else if (selectorScopeMode === R3SelectorScopeMode.SideEffect) {
    // In this mode, scope information is not passed into `ɵɵdefineNgModule` as it
    // would prevent tree-shaking of the declarations, imports and exports references. Instead, it's
    // patched onto the NgModule definition with a `ɵɵsetNgModuleScope` call that's guarded by the
    // `ngJitMode` flag.
    var setNgModuleScopeCall = generateSetNgModuleScopeCall(meta);

    if (setNgModuleScopeCall !== null) {
      statements.push(setNgModuleScopeCall);
    }
  } else {// Selector scope emit was not requested, so skip it.
  }

  if (schemas !== null && schemas.length > 0) {
    definitionMap.set('schemas', literalArr(schemas.map(function (ref) {
      return ref.value;
    })));
  }

  if (id !== null) {
    definitionMap.set('id', id); // Generate a side-effectful call to register this NgModule by its id, as per the semantics of
    // NgModule ids.

    statements.push(importExpr(Identifiers.registerNgModuleType).callFn([adjacentType, id]).toStmt());
  }

  var expression = importExpr(Identifiers.defineNgModule).callFn([definitionMap.toLiteralMap()], undefined, true);
  var type = createNgModuleType(meta);
  return {
    expression: expression,
    type: type,
    statements: statements
  };
}
/**
 * This function is used in JIT mode to generate the call to `ɵɵdefineNgModule()` from a call to
 * `ɵɵngDeclareNgModule()`.
 */


function compileNgModuleDeclarationExpression(meta) {
  var definitionMap = new DefinitionMap();
  definitionMap.set('type', new WrappedNodeExpr(meta.type));

  if (meta.bootstrap !== undefined) {
    definitionMap.set('bootstrap', new WrappedNodeExpr(meta.bootstrap));
  }

  if (meta.declarations !== undefined) {
    definitionMap.set('declarations', new WrappedNodeExpr(meta.declarations));
  }

  if (meta.imports !== undefined) {
    definitionMap.set('imports', new WrappedNodeExpr(meta.imports));
  }

  if (meta.exports !== undefined) {
    definitionMap.set('exports', new WrappedNodeExpr(meta.exports));
  }

  if (meta.schemas !== undefined) {
    definitionMap.set('schemas', new WrappedNodeExpr(meta.schemas));
  }

  if (meta.id !== undefined) {
    definitionMap.set('id', new WrappedNodeExpr(meta.id));
  }

  return importExpr(Identifiers.defineNgModule).callFn([definitionMap.toLiteralMap()]);
}

function createNgModuleType(_ref5) {
  var moduleType = _ref5.type,
      declarations = _ref5.declarations,
      imports = _ref5.imports,
      exports = _ref5.exports;
  return new ExpressionType(importExpr(Identifiers.NgModuleDeclaration, [new ExpressionType(moduleType.type), tupleTypeOf(declarations), tupleTypeOf(imports), tupleTypeOf(exports)]));
}
/**
 * Generates a function call to `ɵɵsetNgModuleScope` with all necessary information so that the
 * transitive module scope can be computed during runtime in JIT mode. This call is marked pure
 * such that the references to declarations, imports and exports may be elided causing these
 * symbols to become tree-shakeable.
 */


function generateSetNgModuleScopeCall(meta) {
  var moduleType = meta.adjacentType,
      declarations = meta.declarations,
      imports = meta.imports,
      exports = meta.exports,
      containsForwardDecls = meta.containsForwardDecls;
  var scopeMap = new DefinitionMap();

  if (declarations.length > 0) {
    scopeMap.set('declarations', refsToArray(declarations, containsForwardDecls));
  }

  if (imports.length > 0) {
    scopeMap.set('imports', refsToArray(imports, containsForwardDecls));
  }

  if (exports.length > 0) {
    scopeMap.set('exports', refsToArray(exports, containsForwardDecls));
  }

  if (Object.keys(scopeMap.values).length === 0) {
    return null;
  } // setNgModuleScope(...)


  var fnCall = new InvokeFunctionExpr(
  /* fn */
  importExpr(Identifiers.setNgModuleScope),
  /* args */
  [moduleType, scopeMap.toLiteralMap()]); // (ngJitMode guard) && setNgModuleScope(...)

  var guardedCall = jitOnlyGuardedExpression(fnCall); // function() { (ngJitMode guard) && setNgModuleScope(...); }

  var iife = new FunctionExpr(
  /* params */
  [],
  /* statements */
  [guardedCall.toStmt()]); // (function() { (ngJitMode guard) && setNgModuleScope(...); })()

  var iifeCall = new InvokeFunctionExpr(
  /* fn */
  iife,
  /* args */
  []);
  return iifeCall.toStmt();
}

function tupleTypeOf(exp) {
  var types = exp.map(function (ref) {
    return typeofExpr(ref.type);
  });
  return exp.length > 0 ? expressionType(literalArr(types)) : NONE_TYPE;
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */


function compilePipeFromMetadata(metadata) {
  var definitionMapValues = []; // e.g. `name: 'myPipe'`

  definitionMapValues.push({
    key: 'name',
    value: literal(metadata.pipeName),
    quoted: false
  }); // e.g. `type: MyPipe`

  definitionMapValues.push({
    key: 'type',
    value: metadata.type.value,
    quoted: false
  }); // e.g. `pure: true`

  definitionMapValues.push({
    key: 'pure',
    value: literal(metadata.pure),
    quoted: false
  });

  if (metadata.isStandalone) {
    definitionMapValues.push({
      key: 'standalone',
      value: literal(true),
      quoted: false
    });
  }

  var expression = importExpr(Identifiers.definePipe).callFn([literalMap(definitionMapValues)], undefined, true);
  var type = createPipeType(metadata);
  return {
    expression: expression,
    type: type,
    statements: []
  };
}

function createPipeType(metadata) {
  return new ExpressionType(importExpr(Identifiers.PipeDeclaration, [typeWithParameters(metadata.type.type, metadata.typeArgumentCount), new ExpressionType(new LiteralExpr(metadata.pipeName)), new ExpressionType(new LiteralExpr(metadata.isStandalone))]));
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */


var R3TemplateDependencyKind;

(function (R3TemplateDependencyKind) {
  R3TemplateDependencyKind[R3TemplateDependencyKind["Directive"] = 0] = "Directive";
  R3TemplateDependencyKind[R3TemplateDependencyKind["Pipe"] = 1] = "Pipe";
  R3TemplateDependencyKind[R3TemplateDependencyKind["NgModule"] = 2] = "NgModule";
})(R3TemplateDependencyKind || (R3TemplateDependencyKind = {}));
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */


var ParserError = /*#__PURE__*/(0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(function ParserError(message, input, errLocation, ctxLocation) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, ParserError);

  this.input = input;
  this.errLocation = errLocation;
  this.ctxLocation = ctxLocation;
  this.message = "Parser Error: ".concat(message, " ").concat(errLocation, " [").concat(input, "] in ").concat(ctxLocation);
});

var ParseSpan = /*#__PURE__*/function () {
  function ParseSpan(start, end) {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, ParseSpan);

    this.start = start;
    this.end = end;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(ParseSpan, [{
    key: "toAbsolute",
    value: function toAbsolute(absoluteOffset) {
      return new AbsoluteSourceSpan(absoluteOffset + this.start, absoluteOffset + this.end);
    }
  }]);

  return ParseSpan;
}();

var AST = /*#__PURE__*/function () {
  function AST(span,
  /**
   * Absolute location of the expression AST in a source code file.
   */
  sourceSpan) {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, AST);

    this.span = span;
    this.sourceSpan = sourceSpan;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(AST, [{
    key: "toString",
    value: function toString() {
      return 'AST';
    }
  }]);

  return AST;
}();

var ASTWithName = /*#__PURE__*/function (_AST) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(ASTWithName, _AST);

  var _super40 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(ASTWithName);

  function ASTWithName(span, sourceSpan, nameSpan) {
    var _this71;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, ASTWithName);

    _this71 = _super40.call(this, span, sourceSpan);
    _this71.nameSpan = nameSpan;
    return _this71;
  }

  return (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(ASTWithName);
}(AST);

var EmptyExpr = /*#__PURE__*/function (_AST2) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(EmptyExpr, _AST2);

  var _super41 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(EmptyExpr);

  function EmptyExpr() {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, EmptyExpr);

    return _super41.apply(this, arguments);
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(EmptyExpr, [{
    key: "visit",
    value: function visit(visitor) {// do nothing

      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    }
  }]);

  return EmptyExpr;
}(AST);

var ImplicitReceiver = /*#__PURE__*/function (_AST3) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(ImplicitReceiver, _AST3);

  var _super42 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(ImplicitReceiver);

  function ImplicitReceiver() {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, ImplicitReceiver);

    return _super42.apply(this, arguments);
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(ImplicitReceiver, [{
    key: "visit",
    value: function visit(visitor) {
      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      return visitor.visitImplicitReceiver(this, context);
    }
  }]);

  return ImplicitReceiver;
}(AST);
/**
 * Receiver when something is accessed through `this` (e.g. `this.foo`). Note that this class
 * inherits from `ImplicitReceiver`, because accessing something through `this` is treated the
 * same as accessing it implicitly inside of an Angular template (e.g. `[attr.title]="this.title"`
 * is the same as `[attr.title]="title"`.). Inheriting allows for the `this` accesses to be treated
 * the same as implicit ones, except for a couple of exceptions like `$event` and `$any`.
 * TODO: we should find a way for this class not to extend from `ImplicitReceiver` in the future.
 */


var ThisReceiver = /*#__PURE__*/function (_ImplicitReceiver) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(ThisReceiver, _ImplicitReceiver);

  var _super43 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(ThisReceiver);

  function ThisReceiver() {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, ThisReceiver);

    return _super43.apply(this, arguments);
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(ThisReceiver, [{
    key: "visit",
    value: function visit(visitor) {
      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      var _a;

      return (_a = visitor.visitThisReceiver) === null || _a === void 0 ? void 0 : _a.call(visitor, this, context);
    }
  }]);

  return ThisReceiver;
}(ImplicitReceiver);
/**
 * Multiple expressions separated by a semicolon.
 */


var Chain = /*#__PURE__*/function (_AST4) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(Chain, _AST4);

  var _super44 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(Chain);

  function Chain(span, sourceSpan, expressions) {
    var _this72;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, Chain);

    _this72 = _super44.call(this, span, sourceSpan);
    _this72.expressions = expressions;
    return _this72;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(Chain, [{
    key: "visit",
    value: function visit(visitor) {
      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      return visitor.visitChain(this, context);
    }
  }]);

  return Chain;
}(AST);

var Conditional = /*#__PURE__*/function (_AST5) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(Conditional, _AST5);

  var _super45 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(Conditional);

  function Conditional(span, sourceSpan, condition, trueExp, falseExp) {
    var _this73;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, Conditional);

    _this73 = _super45.call(this, span, sourceSpan);
    _this73.condition = condition;
    _this73.trueExp = trueExp;
    _this73.falseExp = falseExp;
    return _this73;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(Conditional, [{
    key: "visit",
    value: function visit(visitor) {
      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      return visitor.visitConditional(this, context);
    }
  }]);

  return Conditional;
}(AST);

var PropertyRead = /*#__PURE__*/function (_ASTWithName) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(PropertyRead, _ASTWithName);

  var _super46 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(PropertyRead);

  function PropertyRead(span, sourceSpan, nameSpan, receiver, name) {
    var _this74;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, PropertyRead);

    _this74 = _super46.call(this, span, sourceSpan, nameSpan);
    _this74.receiver = receiver;
    _this74.name = name;
    return _this74;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(PropertyRead, [{
    key: "visit",
    value: function visit(visitor) {
      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      return visitor.visitPropertyRead(this, context);
    }
  }]);

  return PropertyRead;
}(ASTWithName);

var PropertyWrite = /*#__PURE__*/function (_ASTWithName2) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(PropertyWrite, _ASTWithName2);

  var _super47 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(PropertyWrite);

  function PropertyWrite(span, sourceSpan, nameSpan, receiver, name, value) {
    var _this75;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, PropertyWrite);

    _this75 = _super47.call(this, span, sourceSpan, nameSpan);
    _this75.receiver = receiver;
    _this75.name = name;
    _this75.value = value;
    return _this75;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(PropertyWrite, [{
    key: "visit",
    value: function visit(visitor) {
      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      return visitor.visitPropertyWrite(this, context);
    }
  }]);

  return PropertyWrite;
}(ASTWithName);

var SafePropertyRead = /*#__PURE__*/function (_ASTWithName3) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(SafePropertyRead, _ASTWithName3);

  var _super48 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(SafePropertyRead);

  function SafePropertyRead(span, sourceSpan, nameSpan, receiver, name) {
    var _this76;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, SafePropertyRead);

    _this76 = _super48.call(this, span, sourceSpan, nameSpan);
    _this76.receiver = receiver;
    _this76.name = name;
    return _this76;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(SafePropertyRead, [{
    key: "visit",
    value: function visit(visitor) {
      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      return visitor.visitSafePropertyRead(this, context);
    }
  }]);

  return SafePropertyRead;
}(ASTWithName);

var KeyedRead = /*#__PURE__*/function (_AST6) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(KeyedRead, _AST6);

  var _super49 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(KeyedRead);

  function KeyedRead(span, sourceSpan, receiver, key) {
    var _this77;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, KeyedRead);

    _this77 = _super49.call(this, span, sourceSpan);
    _this77.receiver = receiver;
    _this77.key = key;
    return _this77;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(KeyedRead, [{
    key: "visit",
    value: function visit(visitor) {
      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      return visitor.visitKeyedRead(this, context);
    }
  }]);

  return KeyedRead;
}(AST);

var SafeKeyedRead = /*#__PURE__*/function (_AST7) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(SafeKeyedRead, _AST7);

  var _super50 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(SafeKeyedRead);

  function SafeKeyedRead(span, sourceSpan, receiver, key) {
    var _this78;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, SafeKeyedRead);

    _this78 = _super50.call(this, span, sourceSpan);
    _this78.receiver = receiver;
    _this78.key = key;
    return _this78;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(SafeKeyedRead, [{
    key: "visit",
    value: function visit(visitor) {
      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      return visitor.visitSafeKeyedRead(this, context);
    }
  }]);

  return SafeKeyedRead;
}(AST);

var KeyedWrite = /*#__PURE__*/function (_AST8) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(KeyedWrite, _AST8);

  var _super51 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(KeyedWrite);

  function KeyedWrite(span, sourceSpan, receiver, key, value) {
    var _this79;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, KeyedWrite);

    _this79 = _super51.call(this, span, sourceSpan);
    _this79.receiver = receiver;
    _this79.key = key;
    _this79.value = value;
    return _this79;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(KeyedWrite, [{
    key: "visit",
    value: function visit(visitor) {
      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      return visitor.visitKeyedWrite(this, context);
    }
  }]);

  return KeyedWrite;
}(AST);

var BindingPipe = /*#__PURE__*/function (_ASTWithName4) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(BindingPipe, _ASTWithName4);

  var _super52 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(BindingPipe);

  function BindingPipe(span, sourceSpan, exp, name, args, nameSpan) {
    var _this80;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, BindingPipe);

    _this80 = _super52.call(this, span, sourceSpan, nameSpan);
    _this80.exp = exp;
    _this80.name = name;
    _this80.args = args;
    return _this80;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(BindingPipe, [{
    key: "visit",
    value: function visit(visitor) {
      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      return visitor.visitPipe(this, context);
    }
  }]);

  return BindingPipe;
}(ASTWithName);

var LiteralPrimitive = /*#__PURE__*/function (_AST9) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(LiteralPrimitive, _AST9);

  var _super53 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(LiteralPrimitive);

  function LiteralPrimitive(span, sourceSpan, value) {
    var _this81;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, LiteralPrimitive);

    _this81 = _super53.call(this, span, sourceSpan);
    _this81.value = value;
    return _this81;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(LiteralPrimitive, [{
    key: "visit",
    value: function visit(visitor) {
      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      return visitor.visitLiteralPrimitive(this, context);
    }
  }]);

  return LiteralPrimitive;
}(AST);

var LiteralArray = /*#__PURE__*/function (_AST10) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(LiteralArray, _AST10);

  var _super54 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(LiteralArray);

  function LiteralArray(span, sourceSpan, expressions) {
    var _this82;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, LiteralArray);

    _this82 = _super54.call(this, span, sourceSpan);
    _this82.expressions = expressions;
    return _this82;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(LiteralArray, [{
    key: "visit",
    value: function visit(visitor) {
      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      return visitor.visitLiteralArray(this, context);
    }
  }]);

  return LiteralArray;
}(AST);

var LiteralMap = /*#__PURE__*/function (_AST11) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(LiteralMap, _AST11);

  var _super55 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(LiteralMap);

  function LiteralMap(span, sourceSpan, keys, values) {
    var _this83;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, LiteralMap);

    _this83 = _super55.call(this, span, sourceSpan);
    _this83.keys = keys;
    _this83.values = values;
    return _this83;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(LiteralMap, [{
    key: "visit",
    value: function visit(visitor) {
      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      return visitor.visitLiteralMap(this, context);
    }
  }]);

  return LiteralMap;
}(AST);

var Interpolation = /*#__PURE__*/function (_AST12) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(Interpolation, _AST12);

  var _super56 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(Interpolation);

  function Interpolation(span, sourceSpan, strings, expressions) {
    var _this84;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, Interpolation);

    _this84 = _super56.call(this, span, sourceSpan);
    _this84.strings = strings;
    _this84.expressions = expressions;
    return _this84;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(Interpolation, [{
    key: "visit",
    value: function visit(visitor) {
      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      return visitor.visitInterpolation(this, context);
    }
  }]);

  return Interpolation;
}(AST);

var Binary = /*#__PURE__*/function (_AST13) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(Binary, _AST13);

  var _super57 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(Binary);

  function Binary(span, sourceSpan, operation, left, right) {
    var _this85;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, Binary);

    _this85 = _super57.call(this, span, sourceSpan);
    _this85.operation = operation;
    _this85.left = left;
    _this85.right = right;
    return _this85;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(Binary, [{
    key: "visit",
    value: function visit(visitor) {
      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      return visitor.visitBinary(this, context);
    }
  }]);

  return Binary;
}(AST);
/**
 * For backwards compatibility reasons, `Unary` inherits from `Binary` and mimics the binary AST
 * node that was originally used. This inheritance relation can be deleted in some future major,
 * after consumers have been given a chance to fully support Unary.
 */


var Unary = /*#__PURE__*/function (_Binary) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(Unary, _Binary);

  var _super58 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(Unary);

  /**
   * During the deprecation period this constructor is private, to avoid consumers from creating
   * a `Unary` with the fallback properties for `Binary`.
   */
  function Unary(span, sourceSpan, operator, expr, binaryOp, binaryLeft, binaryRight) {
    var _this86;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, Unary);

    _this86 = _super58.call(this, span, sourceSpan, binaryOp, binaryLeft, binaryRight);
    _this86.operator = operator;
    _this86.expr = expr; // Redeclare the properties that are inherited from `Binary` as `never`, as consumers should not
    // depend on these fields when operating on `Unary`.

    _this86.left = null;
    _this86.right = null;
    _this86.operation = null;
    return _this86;
  }
  /**
   * Creates a unary minus expression "-x", represented as `Binary` using "0 - x".
   */


  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(Unary, [{
    key: "visit",
    value: function visit(visitor) {
      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (visitor.visitUnary !== undefined) {
        return visitor.visitUnary(this, context);
      }

      return visitor.visitBinary(this, context);
    }
  }], [{
    key: "createMinus",
    value: function createMinus(span, sourceSpan, expr) {
      return new Unary(span, sourceSpan, '-', expr, '-', new LiteralPrimitive(span, sourceSpan, 0), expr);
    }
    /**
     * Creates a unary plus expression "+x", represented as `Binary` using "x - 0".
     */

  }, {
    key: "createPlus",
    value: function createPlus(span, sourceSpan, expr) {
      return new Unary(span, sourceSpan, '+', expr, '-', expr, new LiteralPrimitive(span, sourceSpan, 0));
    }
  }]);

  return Unary;
}(Binary);

var PrefixNot = /*#__PURE__*/function (_AST14) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(PrefixNot, _AST14);

  var _super59 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(PrefixNot);

  function PrefixNot(span, sourceSpan, expression) {
    var _this87;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, PrefixNot);

    _this87 = _super59.call(this, span, sourceSpan);
    _this87.expression = expression;
    return _this87;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(PrefixNot, [{
    key: "visit",
    value: function visit(visitor) {
      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      return visitor.visitPrefixNot(this, context);
    }
  }]);

  return PrefixNot;
}(AST);

var NonNullAssert = /*#__PURE__*/function (_AST15) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(NonNullAssert, _AST15);

  var _super60 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(NonNullAssert);

  function NonNullAssert(span, sourceSpan, expression) {
    var _this88;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, NonNullAssert);

    _this88 = _super60.call(this, span, sourceSpan);
    _this88.expression = expression;
    return _this88;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(NonNullAssert, [{
    key: "visit",
    value: function visit(visitor) {
      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      return visitor.visitNonNullAssert(this, context);
    }
  }]);

  return NonNullAssert;
}(AST);

var Call = /*#__PURE__*/function (_AST16) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(Call, _AST16);

  var _super61 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(Call);

  function Call(span, sourceSpan, receiver, args, argumentSpan) {
    var _this89;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, Call);

    _this89 = _super61.call(this, span, sourceSpan);
    _this89.receiver = receiver;
    _this89.args = args;
    _this89.argumentSpan = argumentSpan;
    return _this89;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(Call, [{
    key: "visit",
    value: function visit(visitor) {
      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      return visitor.visitCall(this, context);
    }
  }]);

  return Call;
}(AST);

var SafeCall = /*#__PURE__*/function (_AST17) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(SafeCall, _AST17);

  var _super62 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(SafeCall);

  function SafeCall(span, sourceSpan, receiver, args, argumentSpan) {
    var _this90;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, SafeCall);

    _this90 = _super62.call(this, span, sourceSpan);
    _this90.receiver = receiver;
    _this90.args = args;
    _this90.argumentSpan = argumentSpan;
    return _this90;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(SafeCall, [{
    key: "visit",
    value: function visit(visitor) {
      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      return visitor.visitSafeCall(this, context);
    }
  }]);

  return SafeCall;
}(AST);
/**
 * Records the absolute position of a text span in a source file, where `start` and `end` are the
 * starting and ending byte offsets, respectively, of the text span in a source file.
 */


var AbsoluteSourceSpan = /*#__PURE__*/(0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(function AbsoluteSourceSpan(start, end) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, AbsoluteSourceSpan);

  this.start = start;
  this.end = end;
});

var ASTWithSource = /*#__PURE__*/function (_AST18) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(ASTWithSource, _AST18);

  var _super63 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(ASTWithSource);

  function ASTWithSource(ast, source, location, absoluteOffset, errors) {
    var _this91;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, ASTWithSource);

    _this91 = _super63.call(this, new ParseSpan(0, source === null ? 0 : source.length), new AbsoluteSourceSpan(absoluteOffset, source === null ? absoluteOffset : absoluteOffset + source.length));
    _this91.ast = ast;
    _this91.source = source;
    _this91.location = location;
    _this91.errors = errors;
    return _this91;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(ASTWithSource, [{
    key: "visit",
    value: function visit(visitor) {
      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (visitor.visitASTWithSource) {
        return visitor.visitASTWithSource(this, context);
      }

      return this.ast.visit(visitor, context);
    }
  }, {
    key: "toString",
    value: function toString() {
      return "".concat(this.source, " in ").concat(this.location);
    }
  }]);

  return ASTWithSource;
}(AST);

var VariableBinding = /*#__PURE__*/(0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(
/**
 * @param sourceSpan entire span of the binding.
 * @param key name of the LHS along with its span.
 * @param value optional value for the RHS along with its span.
 */
function VariableBinding(sourceSpan, key, value) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, VariableBinding);

  this.sourceSpan = sourceSpan;
  this.key = key;
  this.value = value;
});

var ExpressionBinding = /*#__PURE__*/(0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(
/**
 * @param sourceSpan entire span of the binding.
 * @param key binding name, like ngForOf, ngForTrackBy, ngIf, along with its
 * span. Note that the length of the span may not be the same as
 * `key.source.length`. For example,
 * 1. key.source = ngFor, key.span is for "ngFor"
 * 2. key.source = ngForOf, key.span is for "of"
 * 3. key.source = ngForTrackBy, key.span is for "trackBy"
 * @param value optional expression for the RHS.
 */
function ExpressionBinding(sourceSpan, key, value) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, ExpressionBinding);

  this.sourceSpan = sourceSpan;
  this.key = key;
  this.value = value;
});

var RecursiveAstVisitor = /*#__PURE__*/function () {
  function RecursiveAstVisitor() {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, RecursiveAstVisitor);
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(RecursiveAstVisitor, [{
    key: "visit",
    value: function visit(ast, context) {
      // The default implementation just visits every node.
      // Classes that extend RecursiveAstVisitor should override this function
      // to selectively visit the specified node.
      ast.visit(this, context);
    }
  }, {
    key: "visitUnary",
    value: function visitUnary(ast, context) {
      this.visit(ast.expr, context);
    }
  }, {
    key: "visitBinary",
    value: function visitBinary(ast, context) {
      this.visit(ast.left, context);
      this.visit(ast.right, context);
    }
  }, {
    key: "visitChain",
    value: function visitChain(ast, context) {
      this.visitAll(ast.expressions, context);
    }
  }, {
    key: "visitConditional",
    value: function visitConditional(ast, context) {
      this.visit(ast.condition, context);
      this.visit(ast.trueExp, context);
      this.visit(ast.falseExp, context);
    }
  }, {
    key: "visitPipe",
    value: function visitPipe(ast, context) {
      this.visit(ast.exp, context);
      this.visitAll(ast.args, context);
    }
  }, {
    key: "visitImplicitReceiver",
    value: function visitImplicitReceiver(ast, context) {}
  }, {
    key: "visitThisReceiver",
    value: function visitThisReceiver(ast, context) {}
  }, {
    key: "visitInterpolation",
    value: function visitInterpolation(ast, context) {
      this.visitAll(ast.expressions, context);
    }
  }, {
    key: "visitKeyedRead",
    value: function visitKeyedRead(ast, context) {
      this.visit(ast.receiver, context);
      this.visit(ast.key, context);
    }
  }, {
    key: "visitKeyedWrite",
    value: function visitKeyedWrite(ast, context) {
      this.visit(ast.receiver, context);
      this.visit(ast.key, context);
      this.visit(ast.value, context);
    }
  }, {
    key: "visitLiteralArray",
    value: function visitLiteralArray(ast, context) {
      this.visitAll(ast.expressions, context);
    }
  }, {
    key: "visitLiteralMap",
    value: function visitLiteralMap(ast, context) {
      this.visitAll(ast.values, context);
    }
  }, {
    key: "visitLiteralPrimitive",
    value: function visitLiteralPrimitive(ast, context) {}
  }, {
    key: "visitPrefixNot",
    value: function visitPrefixNot(ast, context) {
      this.visit(ast.expression, context);
    }
  }, {
    key: "visitNonNullAssert",
    value: function visitNonNullAssert(ast, context) {
      this.visit(ast.expression, context);
    }
  }, {
    key: "visitPropertyRead",
    value: function visitPropertyRead(ast, context) {
      this.visit(ast.receiver, context);
    }
  }, {
    key: "visitPropertyWrite",
    value: function visitPropertyWrite(ast, context) {
      this.visit(ast.receiver, context);
      this.visit(ast.value, context);
    }
  }, {
    key: "visitSafePropertyRead",
    value: function visitSafePropertyRead(ast, context) {
      this.visit(ast.receiver, context);
    }
  }, {
    key: "visitSafeKeyedRead",
    value: function visitSafeKeyedRead(ast, context) {
      this.visit(ast.receiver, context);
      this.visit(ast.key, context);
    }
  }, {
    key: "visitCall",
    value: function visitCall(ast, context) {
      this.visit(ast.receiver, context);
      this.visitAll(ast.args, context);
    }
  }, {
    key: "visitSafeCall",
    value: function visitSafeCall(ast, context) {
      this.visit(ast.receiver, context);
      this.visitAll(ast.args, context);
    } // This is not part of the AstVisitor interface, just a helper method

  }, {
    key: "visitAll",
    value: function visitAll(asts, context) {
      var _iterator8 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper_js__WEBPACK_IMPORTED_MODULE_9__["default"])(asts),
          _step8;

      try {
        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
          var ast = _step8.value;
          this.visit(ast, context);
        }
      } catch (err) {
        _iterator8.e(err);
      } finally {
        _iterator8.f();
      }
    }
  }]);

  return RecursiveAstVisitor;
}();

var AstTransformer = /*#__PURE__*/function () {
  function AstTransformer() {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, AstTransformer);
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(AstTransformer, [{
    key: "visitImplicitReceiver",
    value: function visitImplicitReceiver(ast, context) {
      return ast;
    }
  }, {
    key: "visitThisReceiver",
    value: function visitThisReceiver(ast, context) {
      return ast;
    }
  }, {
    key: "visitInterpolation",
    value: function visitInterpolation(ast, context) {
      return new Interpolation(ast.span, ast.sourceSpan, ast.strings, this.visitAll(ast.expressions));
    }
  }, {
    key: "visitLiteralPrimitive",
    value: function visitLiteralPrimitive(ast, context) {
      return new LiteralPrimitive(ast.span, ast.sourceSpan, ast.value);
    }
  }, {
    key: "visitPropertyRead",
    value: function visitPropertyRead(ast, context) {
      return new PropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name);
    }
  }, {
    key: "visitPropertyWrite",
    value: function visitPropertyWrite(ast, context) {
      return new PropertyWrite(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name, ast.value.visit(this));
    }
  }, {
    key: "visitSafePropertyRead",
    value: function visitSafePropertyRead(ast, context) {
      return new SafePropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name);
    }
  }, {
    key: "visitLiteralArray",
    value: function visitLiteralArray(ast, context) {
      return new LiteralArray(ast.span, ast.sourceSpan, this.visitAll(ast.expressions));
    }
  }, {
    key: "visitLiteralMap",
    value: function visitLiteralMap(ast, context) {
      return new LiteralMap(ast.span, ast.sourceSpan, ast.keys, this.visitAll(ast.values));
    }
  }, {
    key: "visitUnary",
    value: function visitUnary(ast, context) {
      switch (ast.operator) {
        case '+':
          return Unary.createPlus(ast.span, ast.sourceSpan, ast.expr.visit(this));

        case '-':
          return Unary.createMinus(ast.span, ast.sourceSpan, ast.expr.visit(this));

        default:
          throw new Error("Unknown unary operator ".concat(ast.operator));
      }
    }
  }, {
    key: "visitBinary",
    value: function visitBinary(ast, context) {
      return new Binary(ast.span, ast.sourceSpan, ast.operation, ast.left.visit(this), ast.right.visit(this));
    }
  }, {
    key: "visitPrefixNot",
    value: function visitPrefixNot(ast, context) {
      return new PrefixNot(ast.span, ast.sourceSpan, ast.expression.visit(this));
    }
  }, {
    key: "visitNonNullAssert",
    value: function visitNonNullAssert(ast, context) {
      return new NonNullAssert(ast.span, ast.sourceSpan, ast.expression.visit(this));
    }
  }, {
    key: "visitConditional",
    value: function visitConditional(ast, context) {
      return new Conditional(ast.span, ast.sourceSpan, ast.condition.visit(this), ast.trueExp.visit(this), ast.falseExp.visit(this));
    }
  }, {
    key: "visitPipe",
    value: function visitPipe(ast, context) {
      return new BindingPipe(ast.span, ast.sourceSpan, ast.exp.visit(this), ast.name, this.visitAll(ast.args), ast.nameSpan);
    }
  }, {
    key: "visitKeyedRead",
    value: function visitKeyedRead(ast, context) {
      return new KeyedRead(ast.span, ast.sourceSpan, ast.receiver.visit(this), ast.key.visit(this));
    }
  }, {
    key: "visitKeyedWrite",
    value: function visitKeyedWrite(ast, context) {
      return new KeyedWrite(ast.span, ast.sourceSpan, ast.receiver.visit(this), ast.key.visit(this), ast.value.visit(this));
    }
  }, {
    key: "visitCall",
    value: function visitCall(ast, context) {
      return new Call(ast.span, ast.sourceSpan, ast.receiver.visit(this), this.visitAll(ast.args), ast.argumentSpan);
    }
  }, {
    key: "visitSafeCall",
    value: function visitSafeCall(ast, context) {
      return new SafeCall(ast.span, ast.sourceSpan, ast.receiver.visit(this), this.visitAll(ast.args), ast.argumentSpan);
    }
  }, {
    key: "visitAll",
    value: function visitAll(asts) {
      var res = [];

      for (var i = 0; i < asts.length; ++i) {
        res[i] = asts[i].visit(this);
      }

      return res;
    }
  }, {
    key: "visitChain",
    value: function visitChain(ast, context) {
      return new Chain(ast.span, ast.sourceSpan, this.visitAll(ast.expressions));
    }
  }, {
    key: "visitSafeKeyedRead",
    value: function visitSafeKeyedRead(ast, context) {
      return new SafeKeyedRead(ast.span, ast.sourceSpan, ast.receiver.visit(this), ast.key.visit(this));
    }
  }]);

  return AstTransformer;
}(); // A transformer that only creates new nodes if the transformer makes a change or
// a change is made a child node.


var AstMemoryEfficientTransformer = /*#__PURE__*/function () {
  function AstMemoryEfficientTransformer() {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, AstMemoryEfficientTransformer);
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(AstMemoryEfficientTransformer, [{
    key: "visitImplicitReceiver",
    value: function visitImplicitReceiver(ast, context) {
      return ast;
    }
  }, {
    key: "visitThisReceiver",
    value: function visitThisReceiver(ast, context) {
      return ast;
    }
  }, {
    key: "visitInterpolation",
    value: function visitInterpolation(ast, context) {
      var expressions = this.visitAll(ast.expressions);
      if (expressions !== ast.expressions) return new Interpolation(ast.span, ast.sourceSpan, ast.strings, expressions);
      return ast;
    }
  }, {
    key: "visitLiteralPrimitive",
    value: function visitLiteralPrimitive(ast, context) {
      return ast;
    }
  }, {
    key: "visitPropertyRead",
    value: function visitPropertyRead(ast, context) {
      var receiver = ast.receiver.visit(this);

      if (receiver !== ast.receiver) {
        return new PropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name);
      }

      return ast;
    }
  }, {
    key: "visitPropertyWrite",
    value: function visitPropertyWrite(ast, context) {
      var receiver = ast.receiver.visit(this);
      var value = ast.value.visit(this);

      if (receiver !== ast.receiver || value !== ast.value) {
        return new PropertyWrite(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name, value);
      }

      return ast;
    }
  }, {
    key: "visitSafePropertyRead",
    value: function visitSafePropertyRead(ast, context) {
      var receiver = ast.receiver.visit(this);

      if (receiver !== ast.receiver) {
        return new SafePropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name);
      }

      return ast;
    }
  }, {
    key: "visitLiteralArray",
    value: function visitLiteralArray(ast, context) {
      var expressions = this.visitAll(ast.expressions);

      if (expressions !== ast.expressions) {
        return new LiteralArray(ast.span, ast.sourceSpan, expressions);
      }

      return ast;
    }
  }, {
    key: "visitLiteralMap",
    value: function visitLiteralMap(ast, context) {
      var values = this.visitAll(ast.values);

      if (values !== ast.values) {
        return new LiteralMap(ast.span, ast.sourceSpan, ast.keys, values);
      }

      return ast;
    }
  }, {
    key: "visitUnary",
    value: function visitUnary(ast, context) {
      var expr = ast.expr.visit(this);

      if (expr !== ast.expr) {
        switch (ast.operator) {
          case '+':
            return Unary.createPlus(ast.span, ast.sourceSpan, expr);

          case '-':
            return Unary.createMinus(ast.span, ast.sourceSpan, expr);

          default:
            throw new Error("Unknown unary operator ".concat(ast.operator));
        }
      }

      return ast;
    }
  }, {
    key: "visitBinary",
    value: function visitBinary(ast, context) {
      var left = ast.left.visit(this);
      var right = ast.right.visit(this);

      if (left !== ast.left || right !== ast.right) {
        return new Binary(ast.span, ast.sourceSpan, ast.operation, left, right);
      }

      return ast;
    }
  }, {
    key: "visitPrefixNot",
    value: function visitPrefixNot(ast, context) {
      var expression = ast.expression.visit(this);

      if (expression !== ast.expression) {
        return new PrefixNot(ast.span, ast.sourceSpan, expression);
      }

      return ast;
    }
  }, {
    key: "visitNonNullAssert",
    value: function visitNonNullAssert(ast, context) {
      var expression = ast.expression.visit(this);

      if (expression !== ast.expression) {
        return new NonNullAssert(ast.span, ast.sourceSpan, expression);
      }

      return ast;
    }
  }, {
    key: "visitConditional",
    value: function visitConditional(ast, context) {
      var condition = ast.condition.visit(this);
      var trueExp = ast.trueExp.visit(this);
      var falseExp = ast.falseExp.visit(this);

      if (condition !== ast.condition || trueExp !== ast.trueExp || falseExp !== ast.falseExp) {
        return new Conditional(ast.span, ast.sourceSpan, condition, trueExp, falseExp);
      }

      return ast;
    }
  }, {
    key: "visitPipe",
    value: function visitPipe(ast, context) {
      var exp = ast.exp.visit(this);
      var args = this.visitAll(ast.args);

      if (exp !== ast.exp || args !== ast.args) {
        return new BindingPipe(ast.span, ast.sourceSpan, exp, ast.name, args, ast.nameSpan);
      }

      return ast;
    }
  }, {
    key: "visitKeyedRead",
    value: function visitKeyedRead(ast, context) {
      var obj = ast.receiver.visit(this);
      var key = ast.key.visit(this);

      if (obj !== ast.receiver || key !== ast.key) {
        return new KeyedRead(ast.span, ast.sourceSpan, obj, key);
      }

      return ast;
    }
  }, {
    key: "visitKeyedWrite",
    value: function visitKeyedWrite(ast, context) {
      var obj = ast.receiver.visit(this);
      var key = ast.key.visit(this);
      var value = ast.value.visit(this);

      if (obj !== ast.receiver || key !== ast.key || value !== ast.value) {
        return new KeyedWrite(ast.span, ast.sourceSpan, obj, key, value);
      }

      return ast;
    }
  }, {
    key: "visitAll",
    value: function visitAll(asts) {
      var res = [];
      var modified = false;

      for (var i = 0; i < asts.length; ++i) {
        var original = asts[i];
        var value = original.visit(this);
        res[i] = value;
        modified = modified || value !== original;
      }

      return modified ? res : asts;
    }
  }, {
    key: "visitChain",
    value: function visitChain(ast, context) {
      var expressions = this.visitAll(ast.expressions);

      if (expressions !== ast.expressions) {
        return new Chain(ast.span, ast.sourceSpan, expressions);
      }

      return ast;
    }
  }, {
    key: "visitCall",
    value: function visitCall(ast, context) {
      var receiver = ast.receiver.visit(this);
      var args = this.visitAll(ast.args);

      if (receiver !== ast.receiver || args !== ast.args) {
        return new Call(ast.span, ast.sourceSpan, receiver, args, ast.argumentSpan);
      }

      return ast;
    }
  }, {
    key: "visitSafeCall",
    value: function visitSafeCall(ast, context) {
      var receiver = ast.receiver.visit(this);
      var args = this.visitAll(ast.args);

      if (receiver !== ast.receiver || args !== ast.args) {
        return new SafeCall(ast.span, ast.sourceSpan, receiver, args, ast.argumentSpan);
      }

      return ast;
    }
  }, {
    key: "visitSafeKeyedRead",
    value: function visitSafeKeyedRead(ast, context) {
      var obj = ast.receiver.visit(this);
      var key = ast.key.visit(this);

      if (obj !== ast.receiver || key !== ast.key) {
        return new SafeKeyedRead(ast.span, ast.sourceSpan, obj, key);
      }

      return ast;
    }
  }]);

  return AstMemoryEfficientTransformer;
}(); // Bindings


var ParsedProperty = /*#__PURE__*/(0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(function ParsedProperty(name, expression, type, sourceSpan, keySpan, valueSpan) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, ParsedProperty);

  this.name = name;
  this.expression = expression;
  this.type = type;
  this.sourceSpan = sourceSpan;
  this.keySpan = keySpan;
  this.valueSpan = valueSpan;
  this.isLiteral = this.type === ParsedPropertyType.LITERAL_ATTR;
  this.isAnimation = this.type === ParsedPropertyType.ANIMATION;
});

var ParsedPropertyType;

(function (ParsedPropertyType) {
  ParsedPropertyType[ParsedPropertyType["DEFAULT"] = 0] = "DEFAULT";
  ParsedPropertyType[ParsedPropertyType["LITERAL_ATTR"] = 1] = "LITERAL_ATTR";
  ParsedPropertyType[ParsedPropertyType["ANIMATION"] = 2] = "ANIMATION";
})(ParsedPropertyType || (ParsedPropertyType = {}));

var ParsedEvent = /*#__PURE__*/(0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])( // Regular events have a target
// Animation events have a phase
function ParsedEvent(name, targetOrPhase, type, handler, sourceSpan, handlerSpan, keySpan) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, ParsedEvent);

  this.name = name;
  this.targetOrPhase = targetOrPhase;
  this.type = type;
  this.handler = handler;
  this.sourceSpan = sourceSpan;
  this.handlerSpan = handlerSpan;
  this.keySpan = keySpan;
});
/**
 * ParsedVariable represents a variable declaration in a microsyntax expression.
 */


var ParsedVariable = /*#__PURE__*/(0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(function ParsedVariable(name, value, sourceSpan, keySpan, valueSpan) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, ParsedVariable);

  this.name = name;
  this.value = value;
  this.sourceSpan = sourceSpan;
  this.keySpan = keySpan;
  this.valueSpan = valueSpan;
});

var BoundElementProperty = /*#__PURE__*/(0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(function BoundElementProperty(name, type, securityContext, value, unit, sourceSpan, keySpan, valueSpan) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, BoundElementProperty);

  this.name = name;
  this.type = type;
  this.securityContext = securityContext;
  this.value = value;
  this.unit = unit;
  this.sourceSpan = sourceSpan;
  this.keySpan = keySpan;
  this.valueSpan = valueSpan;
});
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */


var EventHandlerVars = /*#__PURE__*/(0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(function EventHandlerVars() {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, EventHandlerVars);
});

EventHandlerVars.event = variable('$event');
/**
 * Converts the given expression AST into an executable output AST, assuming the expression is
 * used in an action binding (e.g. an event handler).
 */

function convertActionBinding(localResolver, implicitReceiver, action, bindingId, baseSourceSpan, implicitReceiverAccesses, globals) {
  if (!localResolver) {
    localResolver = new DefaultLocalResolver(globals);
  }

  var actionWithoutBuiltins = convertPropertyBindingBuiltins({
    createLiteralArrayConverter: function createLiteralArrayConverter(argCount) {
      // Note: no caching for literal arrays in actions.
      return function (args) {
        return literalArr(args);
      };
    },
    createLiteralMapConverter: function createLiteralMapConverter(keys) {
      // Note: no caching for literal maps in actions.
      return function (values) {
        var entries = keys.map(function (k, i) {
          return {
            key: k.key,
            value: values[i],
            quoted: k.quoted
          };
        });
        return literalMap(entries);
      };
    },
    createPipeConverter: function createPipeConverter(name) {
      throw new Error("Illegal State: Actions are not allowed to contain pipes. Pipe: ".concat(name));
    }
  }, action);
  var visitor = new _AstToIrVisitor(localResolver, implicitReceiver, bindingId,
  /* supportsInterpolation */
  false, baseSourceSpan, implicitReceiverAccesses);
  var actionStmts = [];
  flattenStatements(actionWithoutBuiltins.visit(visitor, _Mode.Statement), actionStmts);
  prependTemporaryDecls(visitor.temporaryCount, bindingId, actionStmts);

  if (visitor.usesImplicitReceiver) {
    localResolver.notifyImplicitReceiverUse();
  }

  var lastIndex = actionStmts.length - 1;

  if (lastIndex >= 0) {
    var lastStatement = actionStmts[lastIndex]; // Ensure that the value of the last expression statement is returned

    if (lastStatement instanceof ExpressionStatement) {
      actionStmts[lastIndex] = new ReturnStatement(lastStatement.expr);
    }
  }

  return actionStmts;
}

function convertPropertyBindingBuiltins(converterFactory, ast) {
  return convertBuiltins(converterFactory, ast);
}

var ConvertPropertyBindingResult = /*#__PURE__*/(0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(function ConvertPropertyBindingResult(stmts, currValExpr) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, ConvertPropertyBindingResult);

  this.stmts = stmts;
  this.currValExpr = currValExpr;
});
/**
 * Converts the given expression AST into an executable output AST, assuming the expression
 * is used in property binding. The expression has to be preprocessed via
 * `convertPropertyBindingBuiltins`.
 */


function _convertPropertyBinding(localResolver, implicitReceiver, expressionWithoutBuiltins, bindingId) {
  if (!localResolver) {
    localResolver = new DefaultLocalResolver();
  }

  var visitor = new _AstToIrVisitor(localResolver, implicitReceiver, bindingId,
  /* supportsInterpolation */
  false);
  var outputExpr = expressionWithoutBuiltins.visit(visitor, _Mode.Expression);
  var stmts = getStatementsFromVisitor(visitor, bindingId);

  if (visitor.usesImplicitReceiver) {
    localResolver.notifyImplicitReceiverUse();
  }

  return new ConvertPropertyBindingResult(stmts, outputExpr);
}
/**
 * Given some expression, such as a binding or interpolation expression, and a context expression to
 * look values up on, visit each facet of the given expression resolving values from the context
 * expression such that a list of arguments can be derived from the found values that can be used as
 * arguments to an external update instruction.
 *
 * @param localResolver The resolver to use to look up expressions by name appropriately
 * @param contextVariableExpression The expression representing the context variable used to create
 * the final argument expressions
 * @param expressionWithArgumentsToExtract The expression to visit to figure out what values need to
 * be resolved and what arguments list to build.
 * @param bindingId A name prefix used to create temporary variable names if they're needed for the
 * arguments generated
 * @returns An array of expressions that can be passed as arguments to instruction expressions like
 * `o.importExpr(R3.propertyInterpolate).callFn(result)`
 */


function convertUpdateArguments(localResolver, contextVariableExpression, expressionWithArgumentsToExtract, bindingId) {
  var visitor = new _AstToIrVisitor(localResolver, contextVariableExpression, bindingId,
  /* supportsInterpolation */
  true);
  var outputExpr = visitor.visitInterpolation(expressionWithArgumentsToExtract, _Mode.Expression);

  if (visitor.usesImplicitReceiver) {
    localResolver.notifyImplicitReceiverUse();
  }

  var stmts = getStatementsFromVisitor(visitor, bindingId);
  var args = outputExpr.args;
  return {
    stmts: stmts,
    args: args
  };
}

function getStatementsFromVisitor(visitor, bindingId) {
  var stmts = [];

  for (var i = 0; i < visitor.temporaryCount; i++) {
    stmts.push(temporaryDeclaration(bindingId, i));
  }

  return stmts;
}

function convertBuiltins(converterFactory, ast) {
  var visitor = new _BuiltinAstConverter(converterFactory);
  return ast.visit(visitor);
}

function temporaryName(bindingId, temporaryNumber) {
  return "tmp_".concat(bindingId, "_").concat(temporaryNumber);
}

function temporaryDeclaration(bindingId, temporaryNumber) {
  return new DeclareVarStmt(temporaryName(bindingId, temporaryNumber));
}

function prependTemporaryDecls(temporaryCount, bindingId, statements) {
  for (var i = temporaryCount - 1; i >= 0; i--) {
    statements.unshift(temporaryDeclaration(bindingId, i));
  }
}

var _Mode;

(function (_Mode) {
  _Mode[_Mode["Statement"] = 0] = "Statement";
  _Mode[_Mode["Expression"] = 1] = "Expression";
})(_Mode || (_Mode = {}));

function ensureStatementMode(mode, ast) {
  if (mode !== _Mode.Statement) {
    throw new Error("Expected a statement, but saw ".concat(ast));
  }
}

function ensureExpressionMode(mode, ast) {
  if (mode !== _Mode.Expression) {
    throw new Error("Expected an expression, but saw ".concat(ast));
  }
}

function convertToStatementIfNeeded(mode, expr) {
  if (mode === _Mode.Statement) {
    return expr.toStmt();
  } else {
    return expr;
  }
}

var _BuiltinAstConverter = /*#__PURE__*/function (_AstTransformer) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(_BuiltinAstConverter, _AstTransformer);

  var _super64 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(_BuiltinAstConverter);

  function _BuiltinAstConverter(_converterFactory) {
    var _this92;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, _BuiltinAstConverter);

    _this92 = _super64.call(this);
    _this92._converterFactory = _converterFactory;
    return _this92;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(_BuiltinAstConverter, [{
    key: "visitPipe",
    value: function visitPipe(ast, context) {
      var _this93 = this;

      var args = [ast.exp].concat((0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(ast.args)).map(function (ast) {
        return ast.visit(_this93, context);
      });
      return new BuiltinFunctionCall(ast.span, ast.sourceSpan, args, this._converterFactory.createPipeConverter(ast.name, args.length));
    }
  }, {
    key: "visitLiteralArray",
    value: function visitLiteralArray(ast, context) {
      var _this94 = this;

      var args = ast.expressions.map(function (ast) {
        return ast.visit(_this94, context);
      });
      return new BuiltinFunctionCall(ast.span, ast.sourceSpan, args, this._converterFactory.createLiteralArrayConverter(ast.expressions.length));
    }
  }, {
    key: "visitLiteralMap",
    value: function visitLiteralMap(ast, context) {
      var _this95 = this;

      var args = ast.values.map(function (ast) {
        return ast.visit(_this95, context);
      });
      return new BuiltinFunctionCall(ast.span, ast.sourceSpan, args, this._converterFactory.createLiteralMapConverter(ast.keys));
    }
  }]);

  return _BuiltinAstConverter;
}(AstTransformer);

var _AstToIrVisitor = /*#__PURE__*/function () {
  function _AstToIrVisitor(_localResolver, _implicitReceiver, bindingId, supportsInterpolation, baseSourceSpan, implicitReceiverAccesses) {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, _AstToIrVisitor);

    this._localResolver = _localResolver;
    this._implicitReceiver = _implicitReceiver;
    this.bindingId = bindingId;
    this.supportsInterpolation = supportsInterpolation;
    this.baseSourceSpan = baseSourceSpan;
    this.implicitReceiverAccesses = implicitReceiverAccesses;
    this._nodeMap = new Map();
    this._resultMap = new Map();
    this._currentTemporary = 0;
    this.temporaryCount = 0;
    this.usesImplicitReceiver = false;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(_AstToIrVisitor, [{
    key: "visitUnary",
    value: function visitUnary(ast, mode) {
      var op;

      switch (ast.operator) {
        case '+':
          op = UnaryOperator.Plus;
          break;

        case '-':
          op = UnaryOperator.Minus;
          break;

        default:
          throw new Error("Unsupported operator ".concat(ast.operator));
      }

      return convertToStatementIfNeeded(mode, new UnaryOperatorExpr(op, this._visit(ast.expr, _Mode.Expression), undefined, this.convertSourceSpan(ast.span)));
    }
  }, {
    key: "visitBinary",
    value: function visitBinary(ast, mode) {
      var op;

      switch (ast.operation) {
        case '+':
          op = BinaryOperator.Plus;
          break;

        case '-':
          op = BinaryOperator.Minus;
          break;

        case '*':
          op = BinaryOperator.Multiply;
          break;

        case '/':
          op = BinaryOperator.Divide;
          break;

        case '%':
          op = BinaryOperator.Modulo;
          break;

        case '&&':
          op = BinaryOperator.And;
          break;

        case '||':
          op = BinaryOperator.Or;
          break;

        case '==':
          op = BinaryOperator.Equals;
          break;

        case '!=':
          op = BinaryOperator.NotEquals;
          break;

        case '===':
          op = BinaryOperator.Identical;
          break;

        case '!==':
          op = BinaryOperator.NotIdentical;
          break;

        case '<':
          op = BinaryOperator.Lower;
          break;

        case '>':
          op = BinaryOperator.Bigger;
          break;

        case '<=':
          op = BinaryOperator.LowerEquals;
          break;

        case '>=':
          op = BinaryOperator.BiggerEquals;
          break;

        case '??':
          return this.convertNullishCoalesce(ast, mode);

        default:
          throw new Error("Unsupported operation ".concat(ast.operation));
      }

      return convertToStatementIfNeeded(mode, new BinaryOperatorExpr(op, this._visit(ast.left, _Mode.Expression), this._visit(ast.right, _Mode.Expression), undefined, this.convertSourceSpan(ast.span)));
    }
  }, {
    key: "visitChain",
    value: function visitChain(ast, mode) {
      ensureStatementMode(mode, ast);
      return this.visitAll(ast.expressions, mode);
    }
  }, {
    key: "visitConditional",
    value: function visitConditional(ast, mode) {
      var value = this._visit(ast.condition, _Mode.Expression);

      return convertToStatementIfNeeded(mode, value.conditional(this._visit(ast.trueExp, _Mode.Expression), this._visit(ast.falseExp, _Mode.Expression), this.convertSourceSpan(ast.span)));
    }
  }, {
    key: "visitPipe",
    value: function visitPipe(ast, mode) {
      throw new Error("Illegal state: Pipes should have been converted into functions. Pipe: ".concat(ast.name));
    }
  }, {
    key: "visitImplicitReceiver",
    value: function visitImplicitReceiver(ast, mode) {
      ensureExpressionMode(mode, ast);
      this.usesImplicitReceiver = true;
      return this._implicitReceiver;
    }
  }, {
    key: "visitThisReceiver",
    value: function visitThisReceiver(ast, mode) {
      return this.visitImplicitReceiver(ast, mode);
    }
  }, {
    key: "visitInterpolation",
    value: function visitInterpolation(ast, mode) {
      if (!this.supportsInterpolation) {
        throw new Error('Unexpected interpolation');
      }

      ensureExpressionMode(mode, ast);
      var args = [];

      for (var i = 0; i < ast.strings.length - 1; i++) {
        args.push(literal(ast.strings[i]));
        args.push(this._visit(ast.expressions[i], _Mode.Expression));
      }

      args.push(literal(ast.strings[ast.strings.length - 1])); // If we're dealing with an interpolation of 1 value with an empty prefix and suffix, reduce the
      // args returned to just the value, because we're going to pass it to a special instruction.

      var strings = ast.strings;

      if (strings.length === 2 && strings[0] === '' && strings[1] === '') {
        // Single argument interpolate instructions.
        args = [args[1]];
      } else if (ast.expressions.length >= 9) {
        // 9 or more arguments must be passed to the `interpolateV`-style instructions, which accept
        // an array of arguments
        args = [literalArr(args)];
      }

      return new InterpolationExpression(args);
    }
  }, {
    key: "visitKeyedRead",
    value: function visitKeyedRead(ast, mode) {
      var leftMostSafe = this.leftMostSafeNode(ast);

      if (leftMostSafe) {
        return this.convertSafeAccess(ast, leftMostSafe, mode);
      } else {
        return convertToStatementIfNeeded(mode, this._visit(ast.receiver, _Mode.Expression).key(this._visit(ast.key, _Mode.Expression)));
      }
    }
  }, {
    key: "visitKeyedWrite",
    value: function visitKeyedWrite(ast, mode) {
      var obj = this._visit(ast.receiver, _Mode.Expression);

      var key = this._visit(ast.key, _Mode.Expression);

      var value = this._visit(ast.value, _Mode.Expression);

      if (obj === this._implicitReceiver) {
        this._localResolver.maybeRestoreView();
      }

      return convertToStatementIfNeeded(mode, obj.key(key).set(value));
    }
  }, {
    key: "visitLiteralArray",
    value: function visitLiteralArray(ast, mode) {
      throw new Error("Illegal State: literal arrays should have been converted into functions");
    }
  }, {
    key: "visitLiteralMap",
    value: function visitLiteralMap(ast, mode) {
      throw new Error("Illegal State: literal maps should have been converted into functions");
    }
  }, {
    key: "visitLiteralPrimitive",
    value: function visitLiteralPrimitive(ast, mode) {
      // For literal values of null, undefined, true, or false allow type interference
      // to infer the type.
      var type = ast.value === null || ast.value === undefined || ast.value === true || ast.value === true ? INFERRED_TYPE : undefined;
      return convertToStatementIfNeeded(mode, literal(ast.value, type, this.convertSourceSpan(ast.span)));
    }
  }, {
    key: "_getLocal",
    value: function _getLocal(name, receiver) {
      var _a;

      if (((_a = this._localResolver.globals) === null || _a === void 0 ? void 0 : _a.has(name)) && receiver instanceof ThisReceiver) {
        return null;
      }

      return this._localResolver.getLocal(name);
    }
  }, {
    key: "visitPrefixNot",
    value: function visitPrefixNot(ast, mode) {
      return convertToStatementIfNeeded(mode, not(this._visit(ast.expression, _Mode.Expression)));
    }
  }, {
    key: "visitNonNullAssert",
    value: function visitNonNullAssert(ast, mode) {
      return convertToStatementIfNeeded(mode, this._visit(ast.expression, _Mode.Expression));
    }
  }, {
    key: "visitPropertyRead",
    value: function visitPropertyRead(ast, mode) {
      var leftMostSafe = this.leftMostSafeNode(ast);

      if (leftMostSafe) {
        return this.convertSafeAccess(ast, leftMostSafe, mode);
      } else {
        var result = null;
        var prevUsesImplicitReceiver = this.usesImplicitReceiver;

        var receiver = this._visit(ast.receiver, _Mode.Expression);

        if (receiver === this._implicitReceiver) {
          result = this._getLocal(ast.name, ast.receiver);

          if (result) {
            // Restore the previous "usesImplicitReceiver" state since the implicit
            // receiver has been replaced with a resolved local expression.
            this.usesImplicitReceiver = prevUsesImplicitReceiver;
            this.addImplicitReceiverAccess(ast.name);
          }
        }

        if (result == null) {
          result = receiver.prop(ast.name, this.convertSourceSpan(ast.span));
        }

        return convertToStatementIfNeeded(mode, result);
      }
    }
  }, {
    key: "visitPropertyWrite",
    value: function visitPropertyWrite(ast, mode) {
      var receiver = this._visit(ast.receiver, _Mode.Expression);

      var prevUsesImplicitReceiver = this.usesImplicitReceiver;
      var varExpr = null;

      if (receiver === this._implicitReceiver) {
        var localExpr = this._getLocal(ast.name, ast.receiver);

        if (localExpr) {
          if (localExpr instanceof ReadPropExpr) {
            // If the local variable is a property read expression, it's a reference
            // to a 'context.property' value and will be used as the target of the
            // write expression.
            varExpr = localExpr; // Restore the previous "usesImplicitReceiver" state since the implicit
            // receiver has been replaced with a resolved local expression.

            this.usesImplicitReceiver = prevUsesImplicitReceiver;
            this.addImplicitReceiverAccess(ast.name);
          } else {
            // Otherwise it's an error.
            var _receiver = ast.name;
            var value = ast.value instanceof PropertyRead ? ast.value.name : undefined;
            throw new Error("Cannot assign value \"".concat(value, "\" to template variable \"").concat(_receiver, "\". Template variables are read-only."));
          }
        }
      } // If no local expression could be produced, use the original receiver's
      // property as the target.


      if (varExpr === null) {
        varExpr = receiver.prop(ast.name, this.convertSourceSpan(ast.span));
      }

      return convertToStatementIfNeeded(mode, varExpr.set(this._visit(ast.value, _Mode.Expression)));
    }
  }, {
    key: "visitSafePropertyRead",
    value: function visitSafePropertyRead(ast, mode) {
      return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);
    }
  }, {
    key: "visitSafeKeyedRead",
    value: function visitSafeKeyedRead(ast, mode) {
      return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);
    }
  }, {
    key: "visitAll",
    value: function visitAll(asts, mode) {
      var _this96 = this;

      return asts.map(function (ast) {
        return _this96._visit(ast, mode);
      });
    }
  }, {
    key: "visitCall",
    value: function visitCall(ast, mode) {
      var leftMostSafe = this.leftMostSafeNode(ast);

      if (leftMostSafe) {
        return this.convertSafeAccess(ast, leftMostSafe, mode);
      }

      var convertedArgs = this.visitAll(ast.args, _Mode.Expression);

      if (ast instanceof BuiltinFunctionCall) {
        return convertToStatementIfNeeded(mode, ast.converter(convertedArgs));
      }

      var receiver = ast.receiver;

      if (receiver instanceof PropertyRead && receiver.receiver instanceof ImplicitReceiver && !(receiver.receiver instanceof ThisReceiver) && receiver.name === '$any') {
        if (convertedArgs.length !== 1) {
          throw new Error("Invalid call to $any, expected 1 argument but received ".concat(convertedArgs.length || 'none'));
        }

        return convertToStatementIfNeeded(mode, convertedArgs[0]);
      }

      var call = this._visit(receiver, _Mode.Expression).callFn(convertedArgs, this.convertSourceSpan(ast.span));

      return convertToStatementIfNeeded(mode, call);
    }
  }, {
    key: "visitSafeCall",
    value: function visitSafeCall(ast, mode) {
      return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);
    }
  }, {
    key: "_visit",
    value: function _visit(ast, mode) {
      var result = this._resultMap.get(ast);

      if (result) return result;
      return (this._nodeMap.get(ast) || ast).visit(this, mode);
    }
  }, {
    key: "convertSafeAccess",
    value: function convertSafeAccess(ast, leftMostSafe, mode) {
      // If the expression contains a safe access node on the left it needs to be converted to
      // an expression that guards the access to the member by checking the receiver for blank. As
      // execution proceeds from left to right, the left most part of the expression must be guarded
      // first but, because member access is left associative, the right side of the expression is at
      // the top of the AST. The desired result requires lifting a copy of the left part of the
      // expression up to test it for blank before generating the unguarded version.
      // Consider, for example the following expression: a?.b.c?.d.e
      // This results in the ast:
      //         .
      //        / \
      //       ?.   e
      //      /  \
      //     .    d
      //    / \
      //   ?.  c
      //  /  \
      // a    b
      // The following tree should be generated:
      //
      //        /---- ? ----\
      //       /      |      \
      //     a   /--- ? ---\  null
      //        /     |     \
      //       .      .     null
      //      / \    / \
      //     .  c   .   e
      //    / \    / \
      //   a   b  .   d
      //         / \
      //        .   c
      //       / \
      //      a   b
      //
      // Notice that the first guard condition is the left hand of the left most safe access node
      // which comes in as leftMostSafe to this routine.
      var guardedExpression = this._visit(leftMostSafe.receiver, _Mode.Expression);

      var temporary = undefined;

      if (this.needsTemporaryInSafeAccess(leftMostSafe.receiver)) {
        // If the expression has method calls or pipes then we need to save the result into a
        // temporary variable to avoid calling stateful or impure code more than once.
        temporary = this.allocateTemporary(); // Preserve the result in the temporary variable

        guardedExpression = temporary.set(guardedExpression); // Ensure all further references to the guarded expression refer to the temporary instead.

        this._resultMap.set(leftMostSafe.receiver, temporary);
      }

      var condition = guardedExpression.isBlank(); // Convert the ast to an unguarded access to the receiver's member. The map will substitute
      // leftMostNode with its unguarded version in the call to `this.visit()`.

      if (leftMostSafe instanceof SafeCall) {
        this._nodeMap.set(leftMostSafe, new Call(leftMostSafe.span, leftMostSafe.sourceSpan, leftMostSafe.receiver, leftMostSafe.args, leftMostSafe.argumentSpan));
      } else if (leftMostSafe instanceof SafeKeyedRead) {
        this._nodeMap.set(leftMostSafe, new KeyedRead(leftMostSafe.span, leftMostSafe.sourceSpan, leftMostSafe.receiver, leftMostSafe.key));
      } else {
        this._nodeMap.set(leftMostSafe, new PropertyRead(leftMostSafe.span, leftMostSafe.sourceSpan, leftMostSafe.nameSpan, leftMostSafe.receiver, leftMostSafe.name));
      } // Recursively convert the node now without the guarded member access.


      var access = this._visit(ast, _Mode.Expression); // Remove the mapping. This is not strictly required as the converter only traverses each node
      // once but is safer if the conversion is changed to traverse the nodes more than once.


      this._nodeMap.delete(leftMostSafe); // If we allocated a temporary, release it.


      if (temporary) {
        this.releaseTemporary(temporary);
      } // Produce the conditional


      return convertToStatementIfNeeded(mode, condition.conditional(NULL_EXPR, access));
    }
  }, {
    key: "convertNullishCoalesce",
    value: function convertNullishCoalesce(ast, mode) {
      var left = this._visit(ast.left, _Mode.Expression);

      var right = this._visit(ast.right, _Mode.Expression);

      var temporary = this.allocateTemporary();
      this.releaseTemporary(temporary); // Generate the following expression. It is identical to how TS
      // transpiles binary expressions with a nullish coalescing operator.
      // let temp;
      // (temp = a) !== null && temp !== undefined ? temp : b;

      return convertToStatementIfNeeded(mode, temporary.set(left).notIdentical(NULL_EXPR).and(temporary.notIdentical(literal(undefined))).conditional(temporary, right));
    } // Given an expression of the form a?.b.c?.d.e then the left most safe node is
    // the (a?.b). The . and ?. are left associative thus can be rewritten as:
    // ((((a?.c).b).c)?.d).e. This returns the most deeply nested safe read or
    // safe method call as this needs to be transformed initially to:
    //   a == null ? null : a.c.b.c?.d.e
    // then to:
    //   a == null ? null : a.b.c == null ? null : a.b.c.d.e

  }, {
    key: "leftMostSafeNode",
    value: function leftMostSafeNode(ast) {
      var _this97 = this;

      var visit = function visit(visitor, ast) {
        return (_this97._nodeMap.get(ast) || ast).visit(visitor);
      };

      return ast.visit({
        visitUnary: function visitUnary(ast) {
          return null;
        },
        visitBinary: function visitBinary(ast) {
          return null;
        },
        visitChain: function visitChain(ast) {
          return null;
        },
        visitConditional: function visitConditional(ast) {
          return null;
        },
        visitCall: function visitCall(ast) {
          return visit(this, ast.receiver);
        },
        visitSafeCall: function visitSafeCall(ast) {
          return visit(this, ast.receiver) || ast;
        },
        visitImplicitReceiver: function visitImplicitReceiver(ast) {
          return null;
        },
        visitThisReceiver: function visitThisReceiver(ast) {
          return null;
        },
        visitInterpolation: function visitInterpolation(ast) {
          return null;
        },
        visitKeyedRead: function visitKeyedRead(ast) {
          return visit(this, ast.receiver);
        },
        visitKeyedWrite: function visitKeyedWrite(ast) {
          return null;
        },
        visitLiteralArray: function visitLiteralArray(ast) {
          return null;
        },
        visitLiteralMap: function visitLiteralMap(ast) {
          return null;
        },
        visitLiteralPrimitive: function visitLiteralPrimitive(ast) {
          return null;
        },
        visitPipe: function visitPipe(ast) {
          return null;
        },
        visitPrefixNot: function visitPrefixNot(ast) {
          return null;
        },
        visitNonNullAssert: function visitNonNullAssert(ast) {
          return null;
        },
        visitPropertyRead: function visitPropertyRead(ast) {
          return visit(this, ast.receiver);
        },
        visitPropertyWrite: function visitPropertyWrite(ast) {
          return null;
        },
        visitSafePropertyRead: function visitSafePropertyRead(ast) {
          return visit(this, ast.receiver) || ast;
        },
        visitSafeKeyedRead: function visitSafeKeyedRead(ast) {
          return visit(this, ast.receiver) || ast;
        }
      });
    } // Returns true of the AST includes a method or a pipe indicating that, if the
    // expression is used as the target of a safe property or method access then
    // the expression should be stored into a temporary variable.

  }, {
    key: "needsTemporaryInSafeAccess",
    value: function needsTemporaryInSafeAccess(ast) {
      var _this98 = this;

      var visit = function visit(visitor, ast) {
        return ast && (_this98._nodeMap.get(ast) || ast).visit(visitor);
      };

      var visitSome = function visitSome(visitor, ast) {
        return ast.some(function (ast) {
          return visit(visitor, ast);
        });
      };

      return ast.visit({
        visitUnary: function visitUnary(ast) {
          return visit(this, ast.expr);
        },
        visitBinary: function visitBinary(ast) {
          return visit(this, ast.left) || visit(this, ast.right);
        },
        visitChain: function visitChain(ast) {
          return false;
        },
        visitConditional: function visitConditional(ast) {
          return visit(this, ast.condition) || visit(this, ast.trueExp) || visit(this, ast.falseExp);
        },
        visitCall: function visitCall(ast) {
          return true;
        },
        visitSafeCall: function visitSafeCall(ast) {
          return true;
        },
        visitImplicitReceiver: function visitImplicitReceiver(ast) {
          return false;
        },
        visitThisReceiver: function visitThisReceiver(ast) {
          return false;
        },
        visitInterpolation: function visitInterpolation(ast) {
          return visitSome(this, ast.expressions);
        },
        visitKeyedRead: function visitKeyedRead(ast) {
          return false;
        },
        visitKeyedWrite: function visitKeyedWrite(ast) {
          return false;
        },
        visitLiteralArray: function visitLiteralArray(ast) {
          return true;
        },
        visitLiteralMap: function visitLiteralMap(ast) {
          return true;
        },
        visitLiteralPrimitive: function visitLiteralPrimitive(ast) {
          return false;
        },
        visitPipe: function visitPipe(ast) {
          return true;
        },
        visitPrefixNot: function visitPrefixNot(ast) {
          return visit(this, ast.expression);
        },
        visitNonNullAssert: function visitNonNullAssert(ast) {
          return visit(this, ast.expression);
        },
        visitPropertyRead: function visitPropertyRead(ast) {
          return false;
        },
        visitPropertyWrite: function visitPropertyWrite(ast) {
          return false;
        },
        visitSafePropertyRead: function visitSafePropertyRead(ast) {
          return false;
        },
        visitSafeKeyedRead: function visitSafeKeyedRead(ast) {
          return false;
        }
      });
    }
  }, {
    key: "allocateTemporary",
    value: function allocateTemporary() {
      var tempNumber = this._currentTemporary++;
      this.temporaryCount = Math.max(this._currentTemporary, this.temporaryCount);
      return new ReadVarExpr(temporaryName(this.bindingId, tempNumber));
    }
  }, {
    key: "releaseTemporary",
    value: function releaseTemporary(temporary) {
      this._currentTemporary--;

      if (temporary.name != temporaryName(this.bindingId, this._currentTemporary)) {
        throw new Error("Temporary ".concat(temporary.name, " released out of order"));
      }
    }
    /**
     * Creates an absolute `ParseSourceSpan` from the relative `ParseSpan`.
     *
     * `ParseSpan` objects are relative to the start of the expression.
     * This method converts these to full `ParseSourceSpan` objects that
     * show where the span is within the overall source file.
     *
     * @param span the relative span to convert.
     * @returns a `ParseSourceSpan` for the given span or null if no
     * `baseSourceSpan` was provided to this class.
     */

  }, {
    key: "convertSourceSpan",
    value: function convertSourceSpan(span) {
      if (this.baseSourceSpan) {
        var _start = this.baseSourceSpan.start.moveBy(span.start);

        var end = this.baseSourceSpan.start.moveBy(span.end);
        var fullStart = this.baseSourceSpan.fullStart.moveBy(span.start);
        return new ParseSourceSpan(_start, end, fullStart);
      } else {
        return null;
      }
    }
    /** Adds the name of an AST to the list of implicit receiver accesses. */

  }, {
    key: "addImplicitReceiverAccess",
    value: function addImplicitReceiverAccess(name) {
      if (this.implicitReceiverAccesses) {
        this.implicitReceiverAccesses.add(name);
      }
    }
  }]);

  return _AstToIrVisitor;
}();

function flattenStatements(arg, output) {
  if (Array.isArray(arg)) {
    arg.forEach(function (entry) {
      return flattenStatements(entry, output);
    });
  } else {
    output.push(arg);
  }
}

function unsupported() {
  throw new Error('Unsupported operation');
}

var InterpolationExpression = /*#__PURE__*/function (_Expression24) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(InterpolationExpression, _Expression24);

  var _super65 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(InterpolationExpression);

  function InterpolationExpression(args) {
    var _this99;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, InterpolationExpression);

    _this99 = _super65.call(this, null, null);
    _this99.args = args;
    _this99.isConstant = unsupported;
    _this99.isEquivalent = unsupported;
    _this99.visitExpression = unsupported;
    return _this99;
  }

  return (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(InterpolationExpression);
}(Expression);

var DefaultLocalResolver = /*#__PURE__*/function () {
  function DefaultLocalResolver(globals) {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, DefaultLocalResolver);

    this.globals = globals;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(DefaultLocalResolver, [{
    key: "notifyImplicitReceiverUse",
    value: function notifyImplicitReceiverUse() {}
  }, {
    key: "maybeRestoreView",
    value: function maybeRestoreView() {}
  }, {
    key: "getLocal",
    value: function getLocal(name) {
      if (name === EventHandlerVars.event.name) {
        return EventHandlerVars.event;
      }

      return null;
    }
  }]);

  return DefaultLocalResolver;
}();

var BuiltinFunctionCall = /*#__PURE__*/function (_Call) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(BuiltinFunctionCall, _Call);

  var _super66 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(BuiltinFunctionCall);

  function BuiltinFunctionCall(span, sourceSpan, args, converter) {
    var _this100;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, BuiltinFunctionCall);

    _this100 = _super66.call(this, span, sourceSpan, new EmptyExpr(span, sourceSpan), args, null);
    _this100.converter = converter;
    return _this100;
  }

  return (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(BuiltinFunctionCall);
}(Call);
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * This file is a port of shadowCSS from webcomponents.js to TypeScript.
 *
 * Please make sure to keep to edits in sync with the source file.
 *
 * Source:
 * https://github.com/webcomponents/webcomponentsjs/blob/4efecd7e0e/src/ShadowCSS/ShadowCSS.js
 *
 * The original file level comment is reproduced below
 */

/*
  This is a limited shim for ShadowDOM css styling.
  https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#styles

  The intention here is to support only the styling features which can be
  relatively simply implemented. The goal is to allow users to avoid the
  most obvious pitfalls and do so without compromising performance significantly.
  For ShadowDOM styling that's not covered here, a set of best practices
  can be provided that should allow users to accomplish more complex styling.

  The following is a list of specific ShadowDOM styling features and a brief
  discussion of the approach used to shim.

  Shimmed features:

  * :host, :host-context: ShadowDOM allows styling of the shadowRoot's host
  element using the :host rule. To shim this feature, the :host styles are
  reformatted and prefixed with a given scope name and promoted to a
  document level stylesheet.
  For example, given a scope name of .foo, a rule like this:

    :host {
        background: red;
      }
    }

  becomes:

    .foo {
      background: red;
    }

  * encapsulation: Styles defined within ShadowDOM, apply only to
  dom inside the ShadowDOM. Polymer uses one of two techniques to implement
  this feature.

  By default, rules are prefixed with the host element tag name
  as a descendant selector. This ensures styling does not leak out of the 'top'
  of the element's ShadowDOM. For example,

  div {
      font-weight: bold;
    }

  becomes:

  x-foo div {
      font-weight: bold;
    }

  becomes:


  Alternatively, if WebComponents.ShadowCSS.strictStyling is set to true then
  selectors are scoped by adding an attribute selector suffix to each
  simple selector that contains the host element tag name. Each element
  in the element's ShadowDOM template is also given the scope attribute.
  Thus, these rules match only elements that have the scope attribute.
  For example, given a scope name of x-foo, a rule like this:

    div {
      font-weight: bold;
    }

  becomes:

    div[x-foo] {
      font-weight: bold;
    }

  Note that elements that are dynamically added to a scope must have the scope
  selector added to them manually.

  * upper/lower bound encapsulation: Styles which are defined outside a
  shadowRoot should not cross the ShadowDOM boundary and should not apply
  inside a shadowRoot.

  This styling behavior is not emulated. Some possible ways to do this that
  were rejected due to complexity and/or performance concerns include: (1) reset
  every possible property for every possible selector for a given scope name;
  (2) re-implement css in javascript.

  As an alternative, users should make sure to use selectors
  specific to the scope in which they are working.

  * ::distributed: This behavior is not emulated. It's often not necessary
  to style the contents of a specific insertion point and instead, descendants
  of the host element can be styled selectively. Users can also create an
  extra node around an insertion point and style that node's contents
  via descendent selectors. For example, with a shadowRoot like this:

    <style>
      ::content(div) {
        background: red;
      }
    </style>
    <content></content>

  could become:

    <style>
      / *@polyfill .content-container div * /
      ::content(div) {
        background: red;
      }
    </style>
    <div class="content-container">
      <content></content>
    </div>

  Note the use of @polyfill in the comment above a ShadowDOM specific style
  declaration. This is a directive to the styling shim to use the selector
  in comments in lieu of the next selector when running under polyfill.
*/


var ShadowCss = /*#__PURE__*/function () {
  function ShadowCss() {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, ShadowCss);

    this.strictStyling = true;
  }
  /*
   * Shim some cssText with the given selector. Returns cssText that can
   * be included in the document via WebComponents.ShadowCSS.addCssToDocument(css).
   *
   * When strictStyling is true:
   * - selector is the attribute added to all elements inside the host,
   * - hostSelector is the attribute added to the host itself.
   */


  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(ShadowCss, [{
    key: "shimCssText",
    value: function shimCssText(cssText, selector) {
      var hostSelector = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
      var commentsWithHash = extractCommentsWithHash(cssText);
      cssText = stripComments(cssText);
      cssText = this._insertDirectives(cssText);

      var scopedCssText = this._scopeCssText(cssText, selector, hostSelector);

      return [scopedCssText].concat((0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(commentsWithHash)).join('\n');
    }
  }, {
    key: "_insertDirectives",
    value: function _insertDirectives(cssText) {
      cssText = this._insertPolyfillDirectivesInCssText(cssText);
      return this._insertPolyfillRulesInCssText(cssText);
    }
    /*
     * Process styles to convert native ShadowDOM rules that will trip
     * up the css parser; we rely on decorating the stylesheet with inert rules.
     *
     * For example, we convert this rule:
     *
     * polyfill-next-selector { content: ':host menu-item'; }
     * ::content menu-item {
     *
     * to this:
     *
     * scopeName menu-item {
     *
     **/

  }, {
    key: "_insertPolyfillDirectivesInCssText",
    value: function _insertPolyfillDirectivesInCssText(cssText) {
      // Difference with webcomponents.js: does not handle comments
      return cssText.replace(_cssContentNextSelectorRe, function () {
        return (arguments.length <= 2 ? undefined : arguments[2]) + '{';
      });
    }
    /*
     * Process styles to add rules which will only apply under the polyfill
     *
     * For example, we convert this rule:
     *
     * polyfill-rule {
     *   content: ':host menu-item';
     * ...
     * }
     *
     * to this:
     *
     * scopeName menu-item {...}
     *
     **/

  }, {
    key: "_insertPolyfillRulesInCssText",
    value: function _insertPolyfillRulesInCssText(cssText) {
      // Difference with webcomponents.js: does not handle comments
      return cssText.replace(_cssContentRuleRe, function () {
        for (var _len4 = arguments.length, m = new Array(_len4), _key5 = 0; _key5 < _len4; _key5++) {
          m[_key5] = arguments[_key5];
        }

        var rule = m[0].replace(m[1], '').replace(m[2], '');
        return m[4] + rule;
      });
    }
    /* Ensure styles are scoped. Pseudo-scoping takes a rule like:
     *
     *  .foo {... }
     *
     *  and converts this to
     *
     *  scopeName .foo { ... }
     */

  }, {
    key: "_scopeCssText",
    value: function _scopeCssText(cssText, scopeSelector, hostSelector) {
      var unscopedRules = this._extractUnscopedRulesFromCssText(cssText); // replace :host and :host-context -shadowcsshost and -shadowcsshost respectively


      cssText = this._insertPolyfillHostInCssText(cssText);
      cssText = this._convertColonHost(cssText);
      cssText = this._convertColonHostContext(cssText);
      cssText = this._convertShadowDOMSelectors(cssText);

      if (scopeSelector) {
        cssText = this._scopeSelectors(cssText, scopeSelector, hostSelector);
      }

      cssText = cssText + '\n' + unscopedRules;
      return cssText.trim();
    }
    /*
     * Process styles to add rules which will only apply under the polyfill
     * and do not process via CSSOM. (CSSOM is destructive to rules on rare
     * occasions, e.g. -webkit-calc on Safari.)
     * For example, we convert this rule:
     *
     * @polyfill-unscoped-rule {
     *   content: 'menu-item';
     * ... }
     *
     * to this:
     *
     * menu-item {...}
     *
     **/

  }, {
    key: "_extractUnscopedRulesFromCssText",
    value: function _extractUnscopedRulesFromCssText(cssText) {
      // Difference with webcomponents.js: does not handle comments
      var r = '';
      var m;
      _cssContentUnscopedRuleRe.lastIndex = 0;

      while ((m = _cssContentUnscopedRuleRe.exec(cssText)) !== null) {
        var rule = m[0].replace(m[2], '').replace(m[1], m[4]);
        r += rule + '\n\n';
      }

      return r;
    }
    /*
     * convert a rule like :host(.foo) > .bar { }
     *
     * to
     *
     * .foo<scopeName> > .bar
     */

  }, {
    key: "_convertColonHost",
    value: function _convertColonHost(cssText) {
      return cssText.replace(_cssColonHostRe, function (_, hostSelectors, otherSelectors) {
        if (hostSelectors) {
          var convertedSelectors = [];
          var hostSelectorArray = hostSelectors.split(',').map(function (p) {
            return p.trim();
          });

          var _iterator9 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper_js__WEBPACK_IMPORTED_MODULE_9__["default"])(hostSelectorArray),
              _step9;

          try {
            for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
              var hostSelector = _step9.value;
              if (!hostSelector) break;
              var convertedSelector = _polyfillHostNoCombinator + hostSelector.replace(_polyfillHost, '') + otherSelectors;
              convertedSelectors.push(convertedSelector);
            }
          } catch (err) {
            _iterator9.e(err);
          } finally {
            _iterator9.f();
          }

          return convertedSelectors.join(',');
        } else {
          return _polyfillHostNoCombinator + otherSelectors;
        }
      });
    }
    /*
     * convert a rule like :host-context(.foo) > .bar { }
     *
     * to
     *
     * .foo<scopeName> > .bar, .foo <scopeName> > .bar { }
     *
     * and
     *
     * :host-context(.foo:host) .bar { ... }
     *
     * to
     *
     * .foo<scopeName> .bar { ... }
     */

  }, {
    key: "_convertColonHostContext",
    value: function _convertColonHostContext(cssText) {
      return cssText.replace(_cssColonHostContextReGlobal, function (selectorText) {
        var _a; // We have captured a selector that contains a `:host-context` rule.
        // For backward compatibility `:host-context` may contain a comma separated list of selectors.
        // Each context selector group will contain a list of host-context selectors that must match
        // an ancestor of the host.
        // (Normally `contextSelectorGroups` will only contain a single array of context selectors.)


        var contextSelectorGroups = [[]]; // There may be more than `:host-context` in this selector so `selectorText` could look like:
        // `:host-context(.one):host-context(.two)`.
        // Execute `_cssColonHostContextRe` over and over until we have extracted all the
        // `:host-context` selectors from this selector.

        var match;

        while (match = _cssColonHostContextRe.exec(selectorText)) {
          // `match` = [':host-context(<selectors>)<rest>', <selectors>, <rest>]
          // The `<selectors>` could actually be a comma separated list: `:host-context(.one, .two)`.
          var newContextSelectors = ((_a = match[1]) !== null && _a !== void 0 ? _a : '').trim().split(',').map(function (m) {
            return m.trim();
          }).filter(function (m) {
            return m !== '';
          }); // We must duplicate the current selector group for each of these new selectors.
          // For example if the current groups are:
          // ```
          // [
          //   ['a', 'b', 'c'],
          //   ['x', 'y', 'z'],
          // ]
          // ```
          // And we have a new set of comma separated selectors: `:host-context(m,n)` then the new
          // groups are:
          // ```
          // [
          //   ['a', 'b', 'c', 'm'],
          //   ['x', 'y', 'z', 'm'],
          //   ['a', 'b', 'c', 'n'],
          //   ['x', 'y', 'z', 'n'],
          // ]
          // ```

          var contextSelectorGroupsLength = contextSelectorGroups.length;
          repeatGroups(contextSelectorGroups, newContextSelectors.length);

          for (var i = 0; i < newContextSelectors.length; i++) {
            for (var j = 0; j < contextSelectorGroupsLength; j++) {
              contextSelectorGroups[j + i * contextSelectorGroupsLength].push(newContextSelectors[i]);
            }
          } // Update the `selectorText` and see repeat to see if there are more `:host-context`s.


          selectorText = match[2];
        } // The context selectors now must be combined with each other to capture all the possible
        // selectors that `:host-context` can match. See `combineHostContextSelectors()` for more
        // info about how this is done.


        return contextSelectorGroups.map(function (contextSelectors) {
          return combineHostContextSelectors(contextSelectors, selectorText);
        }).join(', ');
      });
    }
    /*
     * Convert combinators like ::shadow and pseudo-elements like ::content
     * by replacing with space.
     */

  }, {
    key: "_convertShadowDOMSelectors",
    value: function _convertShadowDOMSelectors(cssText) {
      return _shadowDOMSelectorsRe.reduce(function (result, pattern) {
        return result.replace(pattern, ' ');
      }, cssText);
    } // change a selector like 'div' to 'name div'

  }, {
    key: "_scopeSelectors",
    value: function _scopeSelectors(cssText, scopeSelector, hostSelector) {
      var _this101 = this;

      return processRules(cssText, function (rule) {
        var selector = rule.selector;
        var content = rule.content;

        if (rule.selector[0] !== '@') {
          selector = _this101._scopeSelector(rule.selector, scopeSelector, hostSelector, _this101.strictStyling);
        } else if (rule.selector.startsWith('@media') || rule.selector.startsWith('@supports') || rule.selector.startsWith('@document') || rule.selector.startsWith('@layer')) {
          content = _this101._scopeSelectors(rule.content, scopeSelector, hostSelector);
        } else if (rule.selector.startsWith('@font-face') || rule.selector.startsWith('@page')) {
          content = _this101._stripScopingSelectors(rule.content);
        }

        return new CssRule(selector, content);
      });
    }
    /**
     * Handle a css text that is within a rule that should not contain scope selectors by simply
     * removing them! An example of such a rule is `@font-face`.
     *
     * `@font-face` rules cannot contain nested selectors. Nor can they be nested under a selector.
     * Normally this would be a syntax error by the author of the styles. But in some rare cases, such
     * as importing styles from a library, and applying `:host ::ng-deep` to the imported styles, we
     * can end up with broken css if the imported styles happen to contain @font-face rules.
     *
     * For example:
     *
     * ```
     * :host ::ng-deep {
     *   import 'some/lib/containing/font-face';
     * }
     *
     * Similar logic applies to `@page` rules which can contain a particular set of properties,
     * as well as some specific at-rules. Since they can't be encapsulated, we have to strip
     * any scoping selectors from them. For more information: https://www.w3.org/TR/css-page-3
     * ```
     */

  }, {
    key: "_stripScopingSelectors",
    value: function _stripScopingSelectors(cssText) {
      return processRules(cssText, function (rule) {
        var selector = rule.selector.replace(_shadowDeepSelectors, ' ').replace(_polyfillHostNoCombinatorRe, ' ');
        return new CssRule(selector, rule.content);
      });
    }
  }, {
    key: "_scopeSelector",
    value: function _scopeSelector(selector, scopeSelector, hostSelector, strict) {
      var _this102 = this;

      return selector.split(',').map(function (part) {
        return part.trim().split(_shadowDeepSelectors);
      }).map(function (deepParts) {
        var _deepParts = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toArray_js__WEBPACK_IMPORTED_MODULE_1__["default"])(deepParts),
            shallowPart = _deepParts[0],
            otherParts = _deepParts.slice(1);

        var applyScope = function applyScope(shallowPart) {
          if (_this102._selectorNeedsScoping(shallowPart, scopeSelector)) {
            return strict ? _this102._applyStrictSelectorScope(shallowPart, scopeSelector, hostSelector) : _this102._applySelectorScope(shallowPart, scopeSelector, hostSelector);
          } else {
            return shallowPart;
          }
        };

        return [applyScope(shallowPart)].concat((0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(otherParts)).join(' ');
      }).join(', ');
    }
  }, {
    key: "_selectorNeedsScoping",
    value: function _selectorNeedsScoping(selector, scopeSelector) {
      var re = this._makeScopeMatcher(scopeSelector);

      return !re.test(selector);
    }
  }, {
    key: "_makeScopeMatcher",
    value: function _makeScopeMatcher(scopeSelector) {
      var lre = /\[/g;
      var rre = /\]/g;
      scopeSelector = scopeSelector.replace(lre, '\\[').replace(rre, '\\]');
      return new RegExp('^(' + scopeSelector + ')' + _selectorReSuffix, 'm');
    }
  }, {
    key: "_applySelectorScope",
    value: function _applySelectorScope(selector, scopeSelector, hostSelector) {
      // Difference from webcomponents.js: scopeSelector could not be an array
      return this._applySimpleSelectorScope(selector, scopeSelector, hostSelector);
    } // scope via name and [is=name]

  }, {
    key: "_applySimpleSelectorScope",
    value: function _applySimpleSelectorScope(selector, scopeSelector, hostSelector) {
      // In Android browser, the lastIndex is not reset when the regex is used in String.replace()
      _polyfillHostRe.lastIndex = 0;

      if (_polyfillHostRe.test(selector)) {
        var replaceBy = this.strictStyling ? "[".concat(hostSelector, "]") : scopeSelector;
        return selector.replace(_polyfillHostNoCombinatorRe, function (hnc, selector) {
          return selector.replace(/([^:]*)(:*)(.*)/, function (_, before, colon, after) {
            return before + replaceBy + colon + after;
          });
        }).replace(_polyfillHostRe, replaceBy + ' ');
      }

      return scopeSelector + ' ' + selector;
    } // return a selector with [name] suffix on each simple selector
    // e.g. .foo.bar > .zot becomes .foo[name].bar[name] > .zot[name]  /** @internal */

  }, {
    key: "_applyStrictSelectorScope",
    value: function _applyStrictSelectorScope(selector, scopeSelector, hostSelector) {
      var _this103 = this;

      var isRe = /\[is=([^\]]*)\]/g;
      scopeSelector = scopeSelector.replace(isRe, function (_) {
        return arguments.length <= 1 ? undefined : arguments[1];
      });
      var attrName = '[' + scopeSelector + ']';

      var _scopeSelectorPart = function _scopeSelectorPart(p) {
        var scopedP = p.trim();

        if (!scopedP) {
          return '';
        }

        if (p.indexOf(_polyfillHostNoCombinator) > -1) {
          scopedP = _this103._applySimpleSelectorScope(p, scopeSelector, hostSelector);
        } else {
          // remove :host since it should be unnecessary
          var t = p.replace(_polyfillHostRe, '');

          if (t.length > 0) {
            var matches = t.match(/([^:]*)(:*)(.*)/);

            if (matches) {
              scopedP = matches[1] + attrName + matches[2] + matches[3];
            }
          }
        }

        return scopedP;
      };

      var safeContent = new SafeSelector(selector);
      selector = safeContent.content();
      var scopedSelector = '';
      var startIndex = 0;
      var res;
      var sep = /( |>|\+|~(?!=))\s*/g; // If a selector appears before :host it should not be shimmed as it
      // matches on ancestor elements and not on elements in the host's shadow
      // `:host-context(div)` is transformed to
      // `-shadowcsshost-no-combinatordiv, div -shadowcsshost-no-combinator`
      // the `div` is not part of the component in the 2nd selectors and should not be scoped.
      // Historically `component-tag:host` was matching the component so we also want to preserve
      // this behavior to avoid breaking legacy apps (it should not match).
      // The behavior should be:
      // - `tag:host` -> `tag[h]` (this is to avoid breaking legacy apps, should not match anything)
      // - `tag :host` -> `tag [h]` (`tag` is not scoped because it's considered part of a
      //   `:host-context(tag)`)

      var hasHost = selector.indexOf(_polyfillHostNoCombinator) > -1; // Only scope parts after the first `-shadowcsshost-no-combinator` when it is present

      var shouldScope = !hasHost;

      while ((res = sep.exec(selector)) !== null) {
        var separator = res[1];

        var _part = selector.slice(startIndex, res.index).trim();

        shouldScope = shouldScope || _part.indexOf(_polyfillHostNoCombinator) > -1;
        var scopedPart = shouldScope ? _scopeSelectorPart(_part) : _part;
        scopedSelector += "".concat(scopedPart, " ").concat(separator, " ");
        startIndex = sep.lastIndex;
      }

      var part = selector.substring(startIndex);
      shouldScope = shouldScope || part.indexOf(_polyfillHostNoCombinator) > -1;
      scopedSelector += shouldScope ? _scopeSelectorPart(part) : part; // replace the placeholders with their original values

      return safeContent.restore(scopedSelector);
    }
  }, {
    key: "_insertPolyfillHostInCssText",
    value: function _insertPolyfillHostInCssText(selector) {
      return selector.replace(_colonHostContextRe, _polyfillHostContext).replace(_colonHostRe, _polyfillHost);
    }
  }]);

  return ShadowCss;
}();

var SafeSelector = /*#__PURE__*/function () {
  function SafeSelector(selector) {
    var _this104 = this;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, SafeSelector);

    this.placeholders = [];
    this.index = 0; // Replaces attribute selectors with placeholders.
    // The WS in [attr="va lue"] would otherwise be interpreted as a selector separator.

    selector = this._escapeRegexMatches(selector, /(\[[^\]]*\])/g); // CSS allows for certain special characters to be used in selectors if they're escaped.
    // E.g. `.foo:blue` won't match a class called `foo:blue`, because the colon denotes a
    // pseudo-class, but writing `.foo\:blue` will match, because the colon was escaped.
    // Replace all escape sequences (`\` followed by a character) with a placeholder so
    // that our handling of pseudo-selectors doesn't mess with them.

    selector = this._escapeRegexMatches(selector, /(\\.)/g); // Replaces the expression in `:nth-child(2n + 1)` with a placeholder.
    // WS and "+" would otherwise be interpreted as selector separators.

    this._content = selector.replace(/(:nth-[-\w]+)(\([^)]+\))/g, function (_, pseudo, exp) {
      var replaceBy = "__ph-".concat(_this104.index, "__");

      _this104.placeholders.push(exp);

      _this104.index++;
      return pseudo + replaceBy;
    });
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(SafeSelector, [{
    key: "restore",
    value: function restore(content) {
      var _this105 = this;

      return content.replace(/__ph-(\d+)__/g, function (_ph, index) {
        return _this105.placeholders[+index];
      });
    }
  }, {
    key: "content",
    value: function content() {
      return this._content;
    }
    /**
     * Replaces all of the substrings that match a regex within a
     * special string (e.g. `__ph-0__`, `__ph-1__`, etc).
     */

  }, {
    key: "_escapeRegexMatches",
    value: function _escapeRegexMatches(content, pattern) {
      var _this106 = this;

      return content.replace(pattern, function (_, keep) {
        var replaceBy = "__ph-".concat(_this106.index, "__");

        _this106.placeholders.push(keep);

        _this106.index++;
        return replaceBy;
      });
    }
  }]);

  return SafeSelector;
}();

var _cssContentNextSelectorRe = /polyfill-next-selector[^}]*content:[\s]*?(['"])(.*?)\1[;\s]*}([^{]*?){/gim;
var _cssContentRuleRe = /(polyfill-rule)[^}]*(content:[\s]*(['"])(.*?)\3)[;\s]*[^}]*}/gim;
var _cssContentUnscopedRuleRe = /(polyfill-unscoped-rule)[^}]*(content:[\s]*(['"])(.*?)\3)[;\s]*[^}]*}/gim;
var _polyfillHost = '-shadowcsshost'; // note: :host-context pre-processed to -shadowcsshostcontext.

var _polyfillHostContext = '-shadowcsscontext';

var _parenSuffix = '(?:\\((' + '(?:\\([^)(]*\\)|[^)(]*)+?' + ')\\))?([^,{]*)';

var _cssColonHostRe = new RegExp(_polyfillHost + _parenSuffix, 'gim');

var _cssColonHostContextReGlobal = new RegExp(_polyfillHostContext + _parenSuffix, 'gim');

var _cssColonHostContextRe = new RegExp(_polyfillHostContext + _parenSuffix, 'im');

var _polyfillHostNoCombinator = _polyfillHost + '-no-combinator';

var _polyfillHostNoCombinatorRe = /-shadowcsshost-no-combinator([^\s]*)/;
var _shadowDOMSelectorsRe = [/::shadow/g, /::content/g, // Deprecated selectors
/\/shadow-deep\//g, /\/shadow\//g]; // The deep combinator is deprecated in the CSS spec
// Support for `>>>`, `deep`, `::ng-deep` is then also deprecated and will be removed in the future.
// see https://github.com/angular/angular/pull/17677

var _shadowDeepSelectors = /(?:>>>)|(?:\/deep\/)|(?:::ng-deep)/g;
var _selectorReSuffix = '([>\\s~+[.,{:][\\s\\S]*)?$';
var _polyfillHostRe = /-shadowcsshost/gim;
var _colonHostRe = /:host/gim;
var _colonHostContextRe = /:host-context/gim;
var _commentRe = /\/\*[\s\S]*?\*\//g;

function stripComments(input) {
  return input.replace(_commentRe, '');
}

var _commentWithHashRe = /\/\*\s*#\s*source(Mapping)?URL=[\s\S]+?\*\//g;

function extractCommentsWithHash(input) {
  return input.match(_commentWithHashRe) || [];
}

var BLOCK_PLACEHOLDER = '%BLOCK%';
var QUOTE_PLACEHOLDER = '%QUOTED%';
var _ruleRe = /(\s*)([^;\{\}]+?)(\s*)((?:{%BLOCK%}?\s*;?)|(?:\s*;))/g;
var _quotedRe = /%QUOTED%/g;
var CONTENT_PAIRS = new Map([['{', '}']]);
var QUOTE_PAIRS = new Map([["\"", "\""], ["'", "'"]]);

var CssRule = /*#__PURE__*/(0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(function CssRule(selector, content) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, CssRule);

  this.selector = selector;
  this.content = content;
});

function processRules(input, ruleCallback) {
  var inputWithEscapedQuotes = escapeBlocks(input, QUOTE_PAIRS, QUOTE_PLACEHOLDER);
  var inputWithEscapedBlocks = escapeBlocks(inputWithEscapedQuotes.escapedString, CONTENT_PAIRS, BLOCK_PLACEHOLDER);
  var nextBlockIndex = 0;
  var nextQuoteIndex = 0;
  return inputWithEscapedBlocks.escapedString.replace(_ruleRe, function () {
    var selector = arguments.length <= 2 ? undefined : arguments[2];
    var content = '';
    var suffix = arguments.length <= 4 ? undefined : arguments[4];
    var contentPrefix = '';

    if (suffix && suffix.startsWith('{' + BLOCK_PLACEHOLDER)) {
      content = inputWithEscapedBlocks.blocks[nextBlockIndex++];
      suffix = suffix.substring(BLOCK_PLACEHOLDER.length + 1);
      contentPrefix = '{';
    }

    var rule = ruleCallback(new CssRule(selector, content));
    return "".concat(arguments.length <= 1 ? undefined : arguments[1]).concat(rule.selector).concat(arguments.length <= 3 ? undefined : arguments[3]).concat(contentPrefix).concat(rule.content).concat(suffix);
  }).replace(_quotedRe, function () {
    return inputWithEscapedQuotes.blocks[nextQuoteIndex++];
  });
}

var StringWithEscapedBlocks = /*#__PURE__*/(0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(function StringWithEscapedBlocks(escapedString, blocks) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, StringWithEscapedBlocks);

  this.escapedString = escapedString;
  this.blocks = blocks;
});

function escapeBlocks(input, charPairs, placeholder) {
  var resultParts = [];
  var escapedBlocks = [];
  var openCharCount = 0;
  var nonBlockStartIndex = 0;
  var blockStartIndex = -1;
  var openChar;
  var closeChar;

  for (var i = 0; i < input.length; i++) {
    var char = input[i];

    if (char === '\\') {
      i++;
    } else if (char === closeChar) {
      openCharCount--;

      if (openCharCount === 0) {
        escapedBlocks.push(input.substring(blockStartIndex, i));
        resultParts.push(placeholder);
        nonBlockStartIndex = i;
        blockStartIndex = -1;
        openChar = closeChar = undefined;
      }
    } else if (char === openChar) {
      openCharCount++;
    } else if (openCharCount === 0 && charPairs.has(char)) {
      openChar = char;
      closeChar = charPairs.get(char);
      openCharCount = 1;
      blockStartIndex = i + 1;
      resultParts.push(input.substring(nonBlockStartIndex, blockStartIndex));
    }
  }

  if (blockStartIndex !== -1) {
    escapedBlocks.push(input.substring(blockStartIndex));
    resultParts.push(placeholder);
  } else {
    resultParts.push(input.substring(nonBlockStartIndex));
  }

  return new StringWithEscapedBlocks(resultParts.join(''), escapedBlocks);
}
/**
 * Combine the `contextSelectors` with the `hostMarker` and the `otherSelectors`
 * to create a selector that matches the same as `:host-context()`.
 *
 * Given a single context selector `A` we need to output selectors that match on the host and as an
 * ancestor of the host:
 *
 * ```
 * A <hostMarker>, A<hostMarker> {}
 * ```
 *
 * When there is more than one context selector we also have to create combinations of those
 * selectors with each other. For example if there are `A` and `B` selectors the output is:
 *
 * ```
 * AB<hostMarker>, AB <hostMarker>, A B<hostMarker>,
 * B A<hostMarker>, A B <hostMarker>, B A <hostMarker> {}
 * ```
 *
 * And so on...
 *
 * @param hostMarker the string that selects the host element.
 * @param contextSelectors an array of context selectors that will be combined.
 * @param otherSelectors the rest of the selectors that are not context selectors.
 */


function combineHostContextSelectors(contextSelectors, otherSelectors) {
  var hostMarker = _polyfillHostNoCombinator;
  _polyfillHostRe.lastIndex = 0; // reset the regex to ensure we get an accurate test

  var otherSelectorsHasHost = _polyfillHostRe.test(otherSelectors); // If there are no context selectors then just output a host marker


  if (contextSelectors.length === 0) {
    return hostMarker + otherSelectors;
  }

  var combined = [contextSelectors.pop() || ''];

  while (contextSelectors.length > 0) {
    var length = combined.length;
    var contextSelector = contextSelectors.pop();

    for (var i = 0; i < length; i++) {
      var previousSelectors = combined[i]; // Add the new selector as a descendant of the previous selectors

      combined[length * 2 + i] = previousSelectors + ' ' + contextSelector; // Add the new selector as an ancestor of the previous selectors

      combined[length + i] = contextSelector + ' ' + previousSelectors; // Add the new selector to act on the same element as the previous selectors

      combined[i] = contextSelector + previousSelectors;
    }
  } // Finally connect the selector to the `hostMarker`s: either acting directly on the host
  // (A<hostMarker>) or as an ancestor (A <hostMarker>).


  return combined.map(function (s) {
    return otherSelectorsHasHost ? "".concat(s).concat(otherSelectors) : "".concat(s).concat(hostMarker).concat(otherSelectors, ", ").concat(s, " ").concat(hostMarker).concat(otherSelectors);
  }).join(',');
}
/**
 * Mutate the given `groups` array so that there are `multiples` clones of the original array
 * stored.
 *
 * For example `repeatGroups([a, b], 3)` will result in `[a, b, a, b, a, b]` - but importantly the
 * newly added groups will be clones of the original.
 *
 * @param groups An array of groups of strings that will be repeated. This array is mutated
 *     in-place.
 * @param multiples The number of times the current groups should appear.
 */


function repeatGroups(groups, multiples) {
  var length = groups.length;

  for (var i = 1; i < multiples; i++) {
    for (var j = 0; j < length; j++) {
      groups[j + i * length] = groups[j].slice(0);
    }
  }
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * Parses string representation of a style and converts it into object literal.
 *
 * @param value string representation of style as used in the `style` attribute in HTML.
 *   Example: `color: red; height: auto`.
 * @returns An array of style property name and value pairs, e.g. `['color', 'red', 'height',
 * 'auto']`
 */


function parse(value) {
  // we use a string array here instead of a string map
  // because a string-map is not guaranteed to retain the
  // order of the entries whereas a string array can be
  // constructed in a [key, value, key, value] format.
  var styles = [];
  var i = 0;
  var parenDepth = 0;
  var quote = 0
  /* Char.QuoteNone */
  ;
  var valueStart = 0;
  var propStart = 0;
  var currentProp = null;
  var valueHasQuotes = false;

  while (i < value.length) {
    var token = value.charCodeAt(i++);

    switch (token) {
      case 40
      /* Char.OpenParen */
      :
        parenDepth++;
        break;

      case 41
      /* Char.CloseParen */
      :
        parenDepth--;
        break;

      case 39
      /* Char.QuoteSingle */
      :
        // valueStart needs to be there since prop values don't
        // have quotes in CSS
        valueHasQuotes = valueHasQuotes || valueStart > 0;

        if (quote === 0
        /* Char.QuoteNone */
        ) {
          quote = 39
          /* Char.QuoteSingle */
          ;
        } else if (quote === 39
        /* Char.QuoteSingle */
        && value.charCodeAt(i - 1) !== 92
        /* Char.BackSlash */
        ) {
          quote = 0
          /* Char.QuoteNone */
          ;
        }

        break;

      case 34
      /* Char.QuoteDouble */
      :
        // same logic as above
        valueHasQuotes = valueHasQuotes || valueStart > 0;

        if (quote === 0
        /* Char.QuoteNone */
        ) {
          quote = 34
          /* Char.QuoteDouble */
          ;
        } else if (quote === 34
        /* Char.QuoteDouble */
        && value.charCodeAt(i - 1) !== 92
        /* Char.BackSlash */
        ) {
          quote = 0
          /* Char.QuoteNone */
          ;
        }

        break;

      case 58
      /* Char.Colon */
      :
        if (!currentProp && parenDepth === 0 && quote === 0
        /* Char.QuoteNone */
        ) {
          currentProp = hyphenate(value.substring(propStart, i - 1).trim());
          valueStart = i;
        }

        break;

      case 59
      /* Char.Semicolon */
      :
        if (currentProp && valueStart > 0 && parenDepth === 0 && quote === 0
        /* Char.QuoteNone */
        ) {
          var styleVal = value.substring(valueStart, i - 1).trim();
          styles.push(currentProp, valueHasQuotes ? stripUnnecessaryQuotes(styleVal) : styleVal);
          propStart = i;
          valueStart = 0;
          currentProp = null;
          valueHasQuotes = false;
        }

        break;
    }
  }

  if (currentProp && valueStart) {
    var _styleVal = value.slice(valueStart).trim();

    styles.push(currentProp, valueHasQuotes ? stripUnnecessaryQuotes(_styleVal) : _styleVal);
  }

  return styles;
}

function stripUnnecessaryQuotes(value) {
  var qS = value.charCodeAt(0);
  var qE = value.charCodeAt(value.length - 1);

  if (qS == qE && (qS == 39
  /* Char.QuoteSingle */
  || qS == 34
  /* Char.QuoteDouble */
  )) {
    var tempValue = value.substring(1, value.length - 1); // special case to avoid using a multi-quoted string that was just chomped
    // (e.g. `font-family: "Verdana", "sans-serif"`)

    if (tempValue.indexOf('\'') == -1 && tempValue.indexOf('"') == -1) {
      value = tempValue;
    }
  }

  return value;
}

function hyphenate(value) {
  return value.replace(/[a-z][A-Z]/g, function (v) {
    return v.charAt(0) + '-' + v.charAt(1);
  }).toLowerCase();
}

var IMPORTANT_FLAG = '!important';
/**
 * Minimum amount of binding slots required in the runtime for style/class bindings.
 *
 * Styling in Angular uses up two slots in the runtime LView/TData data structures to
 * record binding data, property information and metadata.
 *
 * When a binding is registered it will place the following information in the `LView`:
 *
 * slot 1) binding value
 * slot 2) cached value (all other values collected before it in string form)
 *
 * When a binding is registered it will place the following information in the `TData`:
 *
 * slot 1) prop name
 * slot 2) binding index that points to the previous style/class binding (and some extra config
 * values)
 *
 * Let's imagine we have a binding that looks like so:
 *
 * ```
 * <div [style.width]="x" [style.height]="y">
 * ```
 *
 * Our `LView` and `TData` data-structures look like so:
 *
 * ```typescript
 * LView = [
 *   // ...
 *   x, // value of x
 *   "width: x",
 *
 *   y, // value of y
 *   "width: x; height: y",
 *   // ...
 * ];
 *
 * TData = [
 *   // ...
 *   "width", // binding slot 20
 *   0,
 *
 *   "height",
 *   20,
 *   // ...
 * ];
 * ```
 *
 * */

var MIN_STYLING_BINDING_SLOTS_REQUIRED = 2;
/**
 * Produces creation/update instructions for all styling bindings (class and style)
 *
 * It also produces the creation instruction to register all initial styling values
 * (which are all the static class="..." and style="..." attribute values that exist
 * on an element within a template).
 *
 * The builder class below handles producing instructions for the following cases:
 *
 * - Static style/class attributes (style="..." and class="...")
 * - Dynamic style/class map bindings ([style]="map" and [class]="map|string")
 * - Dynamic style/class property bindings ([style.prop]="exp" and [class.name]="exp")
 *
 * Due to the complex relationship of all of these cases, the instructions generated
 * for these attributes/properties/bindings must be done so in the correct order. The
 * order which these must be generated is as follows:
 *
 * if (createMode) {
 *   styling(...)
 * }
 * if (updateMode) {
 *   styleMap(...)
 *   classMap(...)
 *   styleProp(...)
 *   classProp(...)
 * }
 *
 * The creation/update methods within the builder class produce these instructions.
 */

var StylingBuilder = /*#__PURE__*/function () {
  function StylingBuilder(_directiveExpr) {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, StylingBuilder);

    this._directiveExpr = _directiveExpr;
    /** Whether or not there are any static styling values present */

    this._hasInitialValues = false;
    /**
     *  Whether or not there are any styling bindings present
     *  (i.e. `[style]`, `[class]`, `[style.prop]` or `[class.name]`)
     */

    this.hasBindings = false;
    this.hasBindingsWithPipes = false;
    /** the input for [class] (if it exists) */

    this._classMapInput = null;
    /** the input for [style] (if it exists) */

    this._styleMapInput = null;
    /** an array of each [style.prop] input */

    this._singleStyleInputs = null;
    /** an array of each [class.name] input */

    this._singleClassInputs = null;
    this._lastStylingInput = null;
    this._firstStylingInput = null; // maps are used instead of hash maps because a Map will
    // retain the ordering of the keys

    /**
     * Represents the location of each style binding in the template
     * (e.g. `<div [style.width]="w" [style.height]="h">` implies
     * that `width=0` and `height=1`)
     */

    this._stylesIndex = new Map();
    /**
     * Represents the location of each class binding in the template
     * (e.g. `<div [class.big]="b" [class.hidden]="h">` implies
     * that `big=0` and `hidden=1`)
     */

    this._classesIndex = new Map();
    this._initialStyleValues = [];
    this._initialClassValues = [];
  }
  /**
   * Registers a given input to the styling builder to be later used when producing AOT code.
   *
   * The code below will only accept the input if it is somehow tied to styling (whether it be
   * style/class bindings or static style/class attributes).
   */


  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(StylingBuilder, [{
    key: "registerBoundInput",
    value: function registerBoundInput(input) {
      // [attr.style] or [attr.class] are skipped in the code below,
      // they should not be treated as styling-based bindings since
      // they are intended to be written directly to the attr and
      // will therefore skip all style/class resolution that is present
      // with style="", [style]="" and [style.prop]="", class="",
      // [class.prop]="". [class]="" assignments
      var binding = null;
      var name = input.name;

      switch (input.type) {
        case 0
        /* BindingType.Property */
        :
          binding = this.registerInputBasedOnName(name, input.value, input.sourceSpan);
          break;

        case 3
        /* BindingType.Style */
        :
          binding = this.registerStyleInput(name, false, input.value, input.sourceSpan, input.unit);
          break;

        case 2
        /* BindingType.Class */
        :
          binding = this.registerClassInput(name, false, input.value, input.sourceSpan);
          break;
      }

      return binding ? true : false;
    }
  }, {
    key: "registerInputBasedOnName",
    value: function registerInputBasedOnName(name, expression, sourceSpan) {
      var binding = null;
      var prefix = name.substring(0, 6);
      var isStyle = name === 'style' || prefix === 'style.' || prefix === 'style!';
      var isClass = !isStyle && (name === 'class' || prefix === 'class.' || prefix === 'class!');

      if (isStyle || isClass) {
        var isMapBased = name.charAt(5) !== '.'; // style.prop or class.prop makes this a no

        var property = name.slice(isMapBased ? 5 : 6); // the dot explains why there's a +1

        if (isStyle) {
          binding = this.registerStyleInput(property, isMapBased, expression, sourceSpan);
        } else {
          binding = this.registerClassInput(property, isMapBased, expression, sourceSpan);
        }
      }

      return binding;
    }
  }, {
    key: "registerStyleInput",
    value: function registerStyleInput(name, isMapBased, value, sourceSpan, suffix) {
      if (isEmptyExpression(value)) {
        return null;
      } // CSS custom properties are case-sensitive so we shouldn't normalize them.
      // See: https://www.w3.org/TR/css-variables-1/#defining-variables


      if (!isCssCustomProperty(name)) {
        name = hyphenate(name);
      }

      var _parseProperty = parseProperty(name),
          property = _parseProperty.property,
          hasOverrideFlag = _parseProperty.hasOverrideFlag,
          bindingSuffix = _parseProperty.suffix;

      suffix = typeof suffix === 'string' && suffix.length !== 0 ? suffix : bindingSuffix;
      var entry = {
        name: property,
        suffix: suffix,
        value: value,
        sourceSpan: sourceSpan,
        hasOverrideFlag: hasOverrideFlag
      };

      if (isMapBased) {
        this._styleMapInput = entry;
      } else {
        (this._singleStyleInputs = this._singleStyleInputs || []).push(entry);
        registerIntoMap(this._stylesIndex, property);
      }

      this._lastStylingInput = entry;
      this._firstStylingInput = this._firstStylingInput || entry;

      this._checkForPipes(value);

      this.hasBindings = true;
      return entry;
    }
  }, {
    key: "registerClassInput",
    value: function registerClassInput(name, isMapBased, value, sourceSpan) {
      if (isEmptyExpression(value)) {
        return null;
      }

      var _parseProperty2 = parseProperty(name),
          property = _parseProperty2.property,
          hasOverrideFlag = _parseProperty2.hasOverrideFlag;

      var entry = {
        name: property,
        value: value,
        sourceSpan: sourceSpan,
        hasOverrideFlag: hasOverrideFlag,
        suffix: null
      };

      if (isMapBased) {
        this._classMapInput = entry;
      } else {
        (this._singleClassInputs = this._singleClassInputs || []).push(entry);
        registerIntoMap(this._classesIndex, property);
      }

      this._lastStylingInput = entry;
      this._firstStylingInput = this._firstStylingInput || entry;

      this._checkForPipes(value);

      this.hasBindings = true;
      return entry;
    }
  }, {
    key: "_checkForPipes",
    value: function _checkForPipes(value) {
      if (value instanceof ASTWithSource && value.ast instanceof BindingPipe) {
        this.hasBindingsWithPipes = true;
      }
    }
    /**
     * Registers the element's static style string value to the builder.
     *
     * @param value the style string (e.g. `width:100px; height:200px;`)
     */

  }, {
    key: "registerStyleAttr",
    value: function registerStyleAttr(value) {
      this._initialStyleValues = parse(value);
      this._hasInitialValues = true;
    }
    /**
     * Registers the element's static class string value to the builder.
     *
     * @param value the className string (e.g. `disabled gold zoom`)
     */

  }, {
    key: "registerClassAttr",
    value: function registerClassAttr(value) {
      this._initialClassValues = value.trim().split(/\s+/g);
      this._hasInitialValues = true;
    }
    /**
     * Appends all styling-related expressions to the provided attrs array.
     *
     * @param attrs an existing array where each of the styling expressions
     * will be inserted into.
     */

  }, {
    key: "populateInitialStylingAttrs",
    value: function populateInitialStylingAttrs(attrs) {
      // [CLASS_MARKER, 'foo', 'bar', 'baz' ...]
      if (this._initialClassValues.length) {
        attrs.push(literal(1
        /* AttributeMarker.Classes */
        ));

        for (var i = 0; i < this._initialClassValues.length; i++) {
          attrs.push(literal(this._initialClassValues[i]));
        }
      } // [STYLE_MARKER, 'width', '200px', 'height', '100px', ...]


      if (this._initialStyleValues.length) {
        attrs.push(literal(2
        /* AttributeMarker.Styles */
        ));

        for (var _i5 = 0; _i5 < this._initialStyleValues.length; _i5 += 2) {
          attrs.push(literal(this._initialStyleValues[_i5]), literal(this._initialStyleValues[_i5 + 1]));
        }
      }
    }
    /**
     * Builds an instruction with all the expressions and parameters for `elementHostAttrs`.
     *
     * The instruction generation code below is used for producing the AOT statement code which is
     * responsible for registering initial styles (within a directive hostBindings' creation block),
     * as well as any of the provided attribute values, to the directive host element.
     */

  }, {
    key: "assignHostAttrs",
    value: function assignHostAttrs(attrs, definitionMap) {
      if (this._directiveExpr && (attrs.length || this._hasInitialValues)) {
        this.populateInitialStylingAttrs(attrs);
        definitionMap.set('hostAttrs', literalArr(attrs));
      }
    }
    /**
     * Builds an instruction with all the expressions and parameters for `classMap`.
     *
     * The instruction data will contain all expressions for `classMap` to function
     * which includes the `[class]` expression params.
     */

  }, {
    key: "buildClassMapInstruction",
    value: function buildClassMapInstruction(valueConverter) {
      if (this._classMapInput) {
        return this._buildMapBasedInstruction(valueConverter, true, this._classMapInput);
      }

      return null;
    }
    /**
     * Builds an instruction with all the expressions and parameters for `styleMap`.
     *
     * The instruction data will contain all expressions for `styleMap` to function
     * which includes the `[style]` expression params.
     */

  }, {
    key: "buildStyleMapInstruction",
    value: function buildStyleMapInstruction(valueConverter) {
      if (this._styleMapInput) {
        return this._buildMapBasedInstruction(valueConverter, false, this._styleMapInput);
      }

      return null;
    }
  }, {
    key: "_buildMapBasedInstruction",
    value: function _buildMapBasedInstruction(valueConverter, isClassBased, stylingInput) {
      // each styling binding value is stored in the LView
      // map-based bindings allocate two slots: one for the
      // previous binding value and another for the previous
      // className or style attribute value.
      var totalBindingSlotsRequired = MIN_STYLING_BINDING_SLOTS_REQUIRED; // these values must be outside of the update block so that they can
      // be evaluated (the AST visit call) during creation time so that any
      // pipes can be picked up in time before the template is built

      var mapValue = stylingInput.value.visit(valueConverter);
      var reference;

      if (mapValue instanceof Interpolation) {
        totalBindingSlotsRequired += mapValue.expressions.length;
        reference = isClassBased ? getClassMapInterpolationExpression(mapValue) : getStyleMapInterpolationExpression(mapValue);
      } else {
        reference = isClassBased ? Identifiers.classMap : Identifiers.styleMap;
      }

      return {
        reference: reference,
        calls: [{
          supportsInterpolation: true,
          sourceSpan: stylingInput.sourceSpan,
          allocateBindingSlots: totalBindingSlotsRequired,
          params: function params(convertFn) {
            var convertResult = convertFn(mapValue);
            var params = Array.isArray(convertResult) ? convertResult : [convertResult];
            return params;
          }
        }]
      };
    }
  }, {
    key: "_buildSingleInputs",
    value: function _buildSingleInputs(reference, inputs, valueConverter, getInterpolationExpressionFn, isClassBased) {
      var instructions = [];
      inputs.forEach(function (input) {
        var previousInstruction = instructions[instructions.length - 1];
        var value = input.value.visit(valueConverter);
        var referenceForCall = reference; // each styling binding value is stored in the LView
        // but there are two values stored for each binding:
        //   1) the value itself
        //   2) an intermediate value (concatenation of style up to this point).
        //      We need to store the intermediate value so that we don't allocate
        //      the strings on each CD.

        var totalBindingSlotsRequired = MIN_STYLING_BINDING_SLOTS_REQUIRED;

        if (value instanceof Interpolation) {
          totalBindingSlotsRequired += value.expressions.length;

          if (getInterpolationExpressionFn) {
            referenceForCall = getInterpolationExpressionFn(value);
          }
        }

        var call = {
          sourceSpan: input.sourceSpan,
          allocateBindingSlots: totalBindingSlotsRequired,
          supportsInterpolation: !!getInterpolationExpressionFn,
          params: function params(convertFn) {
            // params => stylingProp(propName, value, suffix)
            var params = [];
            params.push(literal(input.name));
            var convertResult = convertFn(value);

            if (Array.isArray(convertResult)) {
              params.push.apply(params, (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(convertResult));
            } else {
              params.push(convertResult);
            } // [style.prop] bindings may use suffix values (e.g. px, em, etc...), therefore,
            // if that is detected then we need to pass that in as an optional param.


            if (!isClassBased && input.suffix !== null) {
              params.push(literal(input.suffix));
            }

            return params;
          }
        }; // If we ended up generating a call to the same instruction as the previous styling property
        // we can chain the calls together safely to save some bytes, otherwise we have to generate
        // a separate instruction call. This is primarily a concern with interpolation instructions
        // where we may start off with one `reference`, but end up using another based on the
        // number of interpolations.

        if (previousInstruction && previousInstruction.reference === referenceForCall) {
          previousInstruction.calls.push(call);
        } else {
          instructions.push({
            reference: referenceForCall,
            calls: [call]
          });
        }
      });
      return instructions;
    }
  }, {
    key: "_buildClassInputs",
    value: function _buildClassInputs(valueConverter) {
      if (this._singleClassInputs) {
        return this._buildSingleInputs(Identifiers.classProp, this._singleClassInputs, valueConverter, null, true);
      }

      return [];
    }
  }, {
    key: "_buildStyleInputs",
    value: function _buildStyleInputs(valueConverter) {
      if (this._singleStyleInputs) {
        return this._buildSingleInputs(Identifiers.styleProp, this._singleStyleInputs, valueConverter, getStylePropInterpolationExpression, false);
      }

      return [];
    }
    /**
     * Constructs all instructions which contain the expressions that will be placed
     * into the update block of a template function or a directive hostBindings function.
     */

  }, {
    key: "buildUpdateLevelInstructions",
    value: function buildUpdateLevelInstructions(valueConverter) {
      var instructions = [];

      if (this.hasBindings) {
        var styleMapInstruction = this.buildStyleMapInstruction(valueConverter);

        if (styleMapInstruction) {
          instructions.push(styleMapInstruction);
        }

        var classMapInstruction = this.buildClassMapInstruction(valueConverter);

        if (classMapInstruction) {
          instructions.push(classMapInstruction);
        }

        instructions.push.apply(instructions, (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(this._buildStyleInputs(valueConverter)));
        instructions.push.apply(instructions, (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(this._buildClassInputs(valueConverter)));
      }

      return instructions;
    }
  }]);

  return StylingBuilder;
}();

function registerIntoMap(map, key) {
  if (!map.has(key)) {
    map.set(key, map.size);
  }
}

function parseProperty(name) {
  var hasOverrideFlag = false;
  var overrideIndex = name.indexOf(IMPORTANT_FLAG);

  if (overrideIndex !== -1) {
    name = overrideIndex > 0 ? name.substring(0, overrideIndex) : '';
    hasOverrideFlag = true;
  }

  var suffix = null;
  var property = name;
  var unitIndex = name.lastIndexOf('.');

  if (unitIndex > 0) {
    suffix = name.slice(unitIndex + 1);
    property = name.substring(0, unitIndex);
  }

  return {
    property: property,
    suffix: suffix,
    hasOverrideFlag: hasOverrideFlag
  };
}
/**
 * Gets the instruction to generate for an interpolated class map.
 * @param interpolation An Interpolation AST
 */


function getClassMapInterpolationExpression(interpolation) {
  switch (getInterpolationArgsLength(interpolation)) {
    case 1:
      return Identifiers.classMap;

    case 3:
      return Identifiers.classMapInterpolate1;

    case 5:
      return Identifiers.classMapInterpolate2;

    case 7:
      return Identifiers.classMapInterpolate3;

    case 9:
      return Identifiers.classMapInterpolate4;

    case 11:
      return Identifiers.classMapInterpolate5;

    case 13:
      return Identifiers.classMapInterpolate6;

    case 15:
      return Identifiers.classMapInterpolate7;

    case 17:
      return Identifiers.classMapInterpolate8;

    default:
      return Identifiers.classMapInterpolateV;
  }
}
/**
 * Gets the instruction to generate for an interpolated style map.
 * @param interpolation An Interpolation AST
 */


function getStyleMapInterpolationExpression(interpolation) {
  switch (getInterpolationArgsLength(interpolation)) {
    case 1:
      return Identifiers.styleMap;

    case 3:
      return Identifiers.styleMapInterpolate1;

    case 5:
      return Identifiers.styleMapInterpolate2;

    case 7:
      return Identifiers.styleMapInterpolate3;

    case 9:
      return Identifiers.styleMapInterpolate4;

    case 11:
      return Identifiers.styleMapInterpolate5;

    case 13:
      return Identifiers.styleMapInterpolate6;

    case 15:
      return Identifiers.styleMapInterpolate7;

    case 17:
      return Identifiers.styleMapInterpolate8;

    default:
      return Identifiers.styleMapInterpolateV;
  }
}
/**
 * Gets the instruction to generate for an interpolated style prop.
 * @param interpolation An Interpolation AST
 */


function getStylePropInterpolationExpression(interpolation) {
  switch (getInterpolationArgsLength(interpolation)) {
    case 1:
      return Identifiers.styleProp;

    case 3:
      return Identifiers.stylePropInterpolate1;

    case 5:
      return Identifiers.stylePropInterpolate2;

    case 7:
      return Identifiers.stylePropInterpolate3;

    case 9:
      return Identifiers.stylePropInterpolate4;

    case 11:
      return Identifiers.stylePropInterpolate5;

    case 13:
      return Identifiers.stylePropInterpolate6;

    case 15:
      return Identifiers.stylePropInterpolate7;

    case 17:
      return Identifiers.stylePropInterpolate8;

    default:
      return Identifiers.stylePropInterpolateV;
  }
}
/**
 * Checks whether property name is a custom CSS property.
 * See: https://www.w3.org/TR/css-variables-1
 */


function isCssCustomProperty(name) {
  return name.startsWith('--');
}

function isEmptyExpression(ast) {
  if (ast instanceof ASTWithSource) {
    ast = ast.ast;
  }

  return ast instanceof EmptyExpr;
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */


var TokenType;

(function (TokenType) {
  TokenType[TokenType["Character"] = 0] = "Character";
  TokenType[TokenType["Identifier"] = 1] = "Identifier";
  TokenType[TokenType["PrivateIdentifier"] = 2] = "PrivateIdentifier";
  TokenType[TokenType["Keyword"] = 3] = "Keyword";
  TokenType[TokenType["String"] = 4] = "String";
  TokenType[TokenType["Operator"] = 5] = "Operator";
  TokenType[TokenType["Number"] = 6] = "Number";
  TokenType[TokenType["Error"] = 7] = "Error";
})(TokenType || (TokenType = {}));

var KEYWORDS = ['var', 'let', 'as', 'null', 'undefined', 'true', 'false', 'if', 'else', 'this'];

var Lexer = /*#__PURE__*/function () {
  function Lexer() {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, Lexer);
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(Lexer, [{
    key: "tokenize",
    value: function tokenize(text) {
      var scanner = new _Scanner(text);
      var tokens = [];
      var token = scanner.scanToken();

      while (token != null) {
        tokens.push(token);
        token = scanner.scanToken();
      }

      return tokens;
    }
  }]);

  return Lexer;
}();

var Token = /*#__PURE__*/function () {
  function Token(index, end, type, numValue, strValue) {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, Token);

    this.index = index;
    this.end = end;
    this.type = type;
    this.numValue = numValue;
    this.strValue = strValue;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(Token, [{
    key: "isCharacter",
    value: function isCharacter(code) {
      return this.type == TokenType.Character && this.numValue == code;
    }
  }, {
    key: "isNumber",
    value: function isNumber() {
      return this.type == TokenType.Number;
    }
  }, {
    key: "isString",
    value: function isString() {
      return this.type == TokenType.String;
    }
  }, {
    key: "isOperator",
    value: function isOperator(operator) {
      return this.type == TokenType.Operator && this.strValue == operator;
    }
  }, {
    key: "isIdentifier",
    value: function isIdentifier() {
      return this.type == TokenType.Identifier;
    }
  }, {
    key: "isPrivateIdentifier",
    value: function isPrivateIdentifier() {
      return this.type == TokenType.PrivateIdentifier;
    }
  }, {
    key: "isKeyword",
    value: function isKeyword() {
      return this.type == TokenType.Keyword;
    }
  }, {
    key: "isKeywordLet",
    value: function isKeywordLet() {
      return this.type == TokenType.Keyword && this.strValue == 'let';
    }
  }, {
    key: "isKeywordAs",
    value: function isKeywordAs() {
      return this.type == TokenType.Keyword && this.strValue == 'as';
    }
  }, {
    key: "isKeywordNull",
    value: function isKeywordNull() {
      return this.type == TokenType.Keyword && this.strValue == 'null';
    }
  }, {
    key: "isKeywordUndefined",
    value: function isKeywordUndefined() {
      return this.type == TokenType.Keyword && this.strValue == 'undefined';
    }
  }, {
    key: "isKeywordTrue",
    value: function isKeywordTrue() {
      return this.type == TokenType.Keyword && this.strValue == 'true';
    }
  }, {
    key: "isKeywordFalse",
    value: function isKeywordFalse() {
      return this.type == TokenType.Keyword && this.strValue == 'false';
    }
  }, {
    key: "isKeywordThis",
    value: function isKeywordThis() {
      return this.type == TokenType.Keyword && this.strValue == 'this';
    }
  }, {
    key: "isError",
    value: function isError() {
      return this.type == TokenType.Error;
    }
  }, {
    key: "toNumber",
    value: function toNumber() {
      return this.type == TokenType.Number ? this.numValue : -1;
    }
  }, {
    key: "toString",
    value: function toString() {
      switch (this.type) {
        case TokenType.Character:
        case TokenType.Identifier:
        case TokenType.Keyword:
        case TokenType.Operator:
        case TokenType.PrivateIdentifier:
        case TokenType.String:
        case TokenType.Error:
          return this.strValue;

        case TokenType.Number:
          return this.numValue.toString();

        default:
          return null;
      }
    }
  }]);

  return Token;
}();

function newCharacterToken(index, end, code) {
  return new Token(index, end, TokenType.Character, code, String.fromCharCode(code));
}

function newIdentifierToken(index, end, text) {
  return new Token(index, end, TokenType.Identifier, 0, text);
}

function newPrivateIdentifierToken(index, end, text) {
  return new Token(index, end, TokenType.PrivateIdentifier, 0, text);
}

function newKeywordToken(index, end, text) {
  return new Token(index, end, TokenType.Keyword, 0, text);
}

function newOperatorToken(index, end, text) {
  return new Token(index, end, TokenType.Operator, 0, text);
}

function newStringToken(index, end, text) {
  return new Token(index, end, TokenType.String, 0, text);
}

function newNumberToken(index, end, n) {
  return new Token(index, end, TokenType.Number, n, '');
}

function newErrorToken(index, end, message) {
  return new Token(index, end, TokenType.Error, 0, message);
}

var EOF = new Token(-1, -1, TokenType.Character, 0, '');

var _Scanner = /*#__PURE__*/function () {
  function _Scanner(input) {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, _Scanner);

    this.input = input;
    this.peek = 0;
    this.index = -1;
    this.length = input.length;
    this.advance();
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(_Scanner, [{
    key: "advance",
    value: function advance() {
      this.peek = ++this.index >= this.length ? $EOF : this.input.charCodeAt(this.index);
    }
  }, {
    key: "scanToken",
    value: function scanToken() {
      var input = this.input,
          length = this.length;
      var peek = this.peek,
          index = this.index; // Skip whitespace.

      while (peek <= $SPACE) {
        if (++index >= length) {
          peek = $EOF;
          break;
        } else {
          peek = input.charCodeAt(index);
        }
      }

      this.peek = peek;
      this.index = index;

      if (index >= length) {
        return null;
      } // Handle identifiers and numbers.


      if (isIdentifierStart(peek)) return this.scanIdentifier();
      if (isDigit(peek)) return this.scanNumber(index);
      var start = index;

      switch (peek) {
        case $PERIOD:
          this.advance();
          return isDigit(this.peek) ? this.scanNumber(start) : newCharacterToken(start, this.index, $PERIOD);

        case $LPAREN:
        case $RPAREN:
        case $LBRACE:
        case $RBRACE:
        case $LBRACKET:
        case $RBRACKET:
        case $COMMA:
        case $COLON:
        case $SEMICOLON:
          return this.scanCharacter(start, peek);

        case $SQ:
        case $DQ:
          return this.scanString();

        case $HASH:
          return this.scanPrivateIdentifier();

        case $PLUS:
        case $MINUS:
        case $STAR:
        case $SLASH:
        case $PERCENT:
        case $CARET:
          return this.scanOperator(start, String.fromCharCode(peek));

        case $QUESTION:
          return this.scanQuestion(start);

        case $LT:
        case $GT:
          return this.scanComplexOperator(start, String.fromCharCode(peek), $EQ, '=');

        case $BANG:
        case $EQ:
          return this.scanComplexOperator(start, String.fromCharCode(peek), $EQ, '=', $EQ, '=');

        case $AMPERSAND:
          return this.scanComplexOperator(start, '&', $AMPERSAND, '&');

        case $BAR:
          return this.scanComplexOperator(start, '|', $BAR, '|');

        case $NBSP:
          while (isWhitespace(this.peek)) {
            this.advance();
          }

          return this.scanToken();
      }

      this.advance();
      return this.error("Unexpected character [".concat(String.fromCharCode(peek), "]"), 0);
    }
  }, {
    key: "scanCharacter",
    value: function scanCharacter(start, code) {
      this.advance();
      return newCharacterToken(start, this.index, code);
    }
  }, {
    key: "scanOperator",
    value: function scanOperator(start, str) {
      this.advance();
      return newOperatorToken(start, this.index, str);
    }
    /**
     * Tokenize a 2/3 char long operator
     *
     * @param start start index in the expression
     * @param one first symbol (always part of the operator)
     * @param twoCode code point for the second symbol
     * @param two second symbol (part of the operator when the second code point matches)
     * @param threeCode code point for the third symbol
     * @param three third symbol (part of the operator when provided and matches source expression)
     */

  }, {
    key: "scanComplexOperator",
    value: function scanComplexOperator(start, one, twoCode, two, threeCode, three) {
      this.advance();
      var str = one;

      if (this.peek == twoCode) {
        this.advance();
        str += two;
      }

      if (threeCode != null && this.peek == threeCode) {
        this.advance();
        str += three;
      }

      return newOperatorToken(start, this.index, str);
    }
  }, {
    key: "scanIdentifier",
    value: function scanIdentifier() {
      var start = this.index;
      this.advance();

      while (isIdentifierPart(this.peek)) {
        this.advance();
      }

      var str = this.input.substring(start, this.index);
      return KEYWORDS.indexOf(str) > -1 ? newKeywordToken(start, this.index, str) : newIdentifierToken(start, this.index, str);
    }
    /** Scans an ECMAScript private identifier. */

  }, {
    key: "scanPrivateIdentifier",
    value: function scanPrivateIdentifier() {
      var start = this.index;
      this.advance();

      if (!isIdentifierStart(this.peek)) {
        return this.error('Invalid character [#]', -1);
      }

      while (isIdentifierPart(this.peek)) {
        this.advance();
      }

      var identifierName = this.input.substring(start, this.index);
      return newPrivateIdentifierToken(start, this.index, identifierName);
    }
  }, {
    key: "scanNumber",
    value: function scanNumber(start) {
      var simple = this.index === start;
      var hasSeparators = false;
      this.advance(); // Skip initial digit.

      while (true) {
        if (isDigit(this.peek)) {// Do nothing.
        } else if (this.peek === $_) {
          // Separators are only valid when they're surrounded by digits. E.g. `1_0_1` is
          // valid while `_101` and `101_` are not. The separator can't be next to the decimal
          // point or another separator either. Note that it's unlikely that we'll hit a case where
          // the underscore is at the start, because that's a valid identifier and it will be picked
          // up earlier in the parsing. We validate for it anyway just in case.
          if (!isDigit(this.input.charCodeAt(this.index - 1)) || !isDigit(this.input.charCodeAt(this.index + 1))) {
            return this.error('Invalid numeric separator', 0);
          }

          hasSeparators = true;
        } else if (this.peek === $PERIOD) {
          simple = false;
        } else if (isExponentStart(this.peek)) {
          this.advance();
          if (isExponentSign(this.peek)) this.advance();
          if (!isDigit(this.peek)) return this.error('Invalid exponent', -1);
          simple = false;
        } else {
          break;
        }

        this.advance();
      }

      var str = this.input.substring(start, this.index);

      if (hasSeparators) {
        str = str.replace(/_/g, '');
      }

      var value = simple ? parseIntAutoRadix(str) : parseFloat(str);
      return newNumberToken(start, this.index, value);
    }
  }, {
    key: "scanString",
    value: function scanString() {
      var start = this.index;
      var quote = this.peek;
      this.advance(); // Skip initial quote.

      var buffer = '';
      var marker = this.index;
      var input = this.input;

      while (this.peek != quote) {
        if (this.peek == $BACKSLASH) {
          buffer += input.substring(marker, this.index);
          this.advance();
          var unescapedCode = void 0; // Workaround for TS2.1-introduced type strictness

          this.peek = this.peek;

          if (this.peek == $u) {
            // 4 character hex code for unicode character.
            var hex = input.substring(this.index + 1, this.index + 5);

            if (/^[0-9a-f]+$/i.test(hex)) {
              unescapedCode = parseInt(hex, 16);
            } else {
              return this.error("Invalid unicode escape [\\u".concat(hex, "]"), 0);
            }

            for (var i = 0; i < 5; i++) {
              this.advance();
            }
          } else {
            unescapedCode = unescape(this.peek);
            this.advance();
          }

          buffer += String.fromCharCode(unescapedCode);
          marker = this.index;
        } else if (this.peek == $EOF) {
          return this.error('Unterminated quote', 0);
        } else {
          this.advance();
        }
      }

      var last = input.substring(marker, this.index);
      this.advance(); // Skip terminating quote.

      return newStringToken(start, this.index, buffer + last);
    }
  }, {
    key: "scanQuestion",
    value: function scanQuestion(start) {
      this.advance();
      var str = '?'; // Either `a ?? b` or 'a?.b'.

      if (this.peek === $QUESTION || this.peek === $PERIOD) {
        str += this.peek === $PERIOD ? '.' : '?';
        this.advance();
      }

      return newOperatorToken(start, this.index, str);
    }
  }, {
    key: "error",
    value: function error(message, offset) {
      var position = this.index + offset;
      return newErrorToken(position, this.index, "Lexer Error: ".concat(message, " at column ").concat(position, " in expression [").concat(this.input, "]"));
    }
  }]);

  return _Scanner;
}();

function isIdentifierStart(code) {
  return $a <= code && code <= $z || $A <= code && code <= $Z || code == $_ || code == $$;
}

function isIdentifier(input) {
  if (input.length == 0) return false;
  var scanner = new _Scanner(input);
  if (!isIdentifierStart(scanner.peek)) return false;
  scanner.advance();

  while (scanner.peek !== $EOF) {
    if (!isIdentifierPart(scanner.peek)) return false;
    scanner.advance();
  }

  return true;
}

function isIdentifierPart(code) {
  return isAsciiLetter(code) || isDigit(code) || code == $_ || code == $$;
}

function isExponentStart(code) {
  return code == $e || code == $E;
}

function isExponentSign(code) {
  return code == $MINUS || code == $PLUS;
}

function unescape(code) {
  switch (code) {
    case $n:
      return $LF;

    case $f:
      return $FF;

    case $r:
      return $CR;

    case $t:
      return $TAB;

    case $v:
      return $VTAB;

    default:
      return code;
  }
}

function parseIntAutoRadix(text) {
  var result = parseInt(text);

  if (isNaN(result)) {
    throw new Error('Invalid integer literal when parsing ' + text);
  }

  return result;
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */


var SplitInterpolation = /*#__PURE__*/(0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(function SplitInterpolation(strings, expressions, offsets) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, SplitInterpolation);

  this.strings = strings;
  this.expressions = expressions;
  this.offsets = offsets;
});

var TemplateBindingParseResult = /*#__PURE__*/(0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(function TemplateBindingParseResult(templateBindings, warnings, errors) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, TemplateBindingParseResult);

  this.templateBindings = templateBindings;
  this.warnings = warnings;
  this.errors = errors;
});

var Parser$1 = /*#__PURE__*/function () {
  function Parser$1(_lexer) {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, Parser$1);

    this._lexer = _lexer;
    this.errors = [];
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(Parser$1, [{
    key: "parseAction",
    value: function parseAction(input, isAssignmentEvent, location, absoluteOffset) {
      var interpolationConfig = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : DEFAULT_INTERPOLATION_CONFIG;

      this._checkNoInterpolation(input, location, interpolationConfig);

      var sourceToLex = this._stripComments(input);

      var tokens = this._lexer.tokenize(sourceToLex);

      var flags = 1
      /* ParseFlags.Action */
      ;

      if (isAssignmentEvent) {
        flags |= 2
        /* ParseFlags.AssignmentEvent */
        ;
      }

      var ast = new _ParseAST(input, location, absoluteOffset, tokens, flags, this.errors, 0).parseChain();
      return new ASTWithSource(ast, input, location, absoluteOffset, this.errors);
    }
  }, {
    key: "parseBinding",
    value: function parseBinding(input, location, absoluteOffset) {
      var interpolationConfig = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_INTERPOLATION_CONFIG;

      var ast = this._parseBindingAst(input, location, absoluteOffset, interpolationConfig);

      return new ASTWithSource(ast, input, location, absoluteOffset, this.errors);
    }
  }, {
    key: "checkSimpleExpression",
    value: function checkSimpleExpression(ast) {
      var checker = new SimpleExpressionChecker();
      ast.visit(checker);
      return checker.errors;
    }
  }, {
    key: "parseSimpleBinding",
    value: function parseSimpleBinding(input, location, absoluteOffset) {
      var interpolationConfig = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_INTERPOLATION_CONFIG;

      var ast = this._parseBindingAst(input, location, absoluteOffset, interpolationConfig);

      var errors = this.checkSimpleExpression(ast);

      if (errors.length > 0) {
        this._reportError("Host binding expression cannot contain ".concat(errors.join(' ')), input, location);
      }

      return new ASTWithSource(ast, input, location, absoluteOffset, this.errors);
    }
  }, {
    key: "_reportError",
    value: function _reportError(message, input, errLocation, ctxLocation) {
      this.errors.push(new ParserError(message, input, errLocation, ctxLocation));
    }
  }, {
    key: "_parseBindingAst",
    value: function _parseBindingAst(input, location, absoluteOffset, interpolationConfig) {
      this._checkNoInterpolation(input, location, interpolationConfig);

      var sourceToLex = this._stripComments(input);

      var tokens = this._lexer.tokenize(sourceToLex);

      return new _ParseAST(input, location, absoluteOffset, tokens, 0
      /* ParseFlags.None */
      , this.errors, 0).parseChain();
    }
    /**
     * Parse microsyntax template expression and return a list of bindings or
     * parsing errors in case the given expression is invalid.
     *
     * For example,
     * ```
     *   <div *ngFor="let item of items">
     *         ^      ^ absoluteValueOffset for `templateValue`
     *         absoluteKeyOffset for `templateKey`
     * ```
     * contains three bindings:
     * 1. ngFor -> null
     * 2. item -> NgForOfContext.$implicit
     * 3. ngForOf -> items
     *
     * This is apparent from the de-sugared template:
     * ```
     *   <ng-template ngFor let-item [ngForOf]="items">
     * ```
     *
     * @param templateKey name of directive, without the * prefix. For example: ngIf, ngFor
     * @param templateValue RHS of the microsyntax attribute
     * @param templateUrl template filename if it's external, component filename if it's inline
     * @param absoluteKeyOffset start of the `templateKey`
     * @param absoluteValueOffset start of the `templateValue`
     */

  }, {
    key: "parseTemplateBindings",
    value: function parseTemplateBindings(templateKey, templateValue, templateUrl, absoluteKeyOffset, absoluteValueOffset) {
      var tokens = this._lexer.tokenize(templateValue);

      var parser = new _ParseAST(templateValue, templateUrl, absoluteValueOffset, tokens, 0
      /* ParseFlags.None */
      , this.errors, 0
      /* relative offset */
      );
      return parser.parseTemplateBindings({
        source: templateKey,
        span: new AbsoluteSourceSpan(absoluteKeyOffset, absoluteKeyOffset + templateKey.length)
      });
    }
  }, {
    key: "parseInterpolation",
    value: function parseInterpolation(input, location, absoluteOffset, interpolatedTokens) {
      var interpolationConfig = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : DEFAULT_INTERPOLATION_CONFIG;

      var _this$splitInterpolat = this.splitInterpolation(input, location, interpolatedTokens, interpolationConfig),
          strings = _this$splitInterpolat.strings,
          expressions = _this$splitInterpolat.expressions,
          offsets = _this$splitInterpolat.offsets;

      if (expressions.length === 0) return null;
      var expressionNodes = [];

      for (var i = 0; i < expressions.length; ++i) {
        var expressionText = expressions[i].text;

        var sourceToLex = this._stripComments(expressionText);

        var tokens = this._lexer.tokenize(sourceToLex);

        var ast = new _ParseAST(input, location, absoluteOffset, tokens, 0
        /* ParseFlags.None */
        , this.errors, offsets[i]).parseChain();
        expressionNodes.push(ast);
      }

      return this.createInterpolationAst(strings.map(function (s) {
        return s.text;
      }), expressionNodes, input, location, absoluteOffset);
    }
    /**
     * Similar to `parseInterpolation`, but treats the provided string as a single expression
     * element that would normally appear within the interpolation prefix and suffix (`{{` and `}}`).
     * This is used for parsing the switch expression in ICUs.
     */

  }, {
    key: "parseInterpolationExpression",
    value: function parseInterpolationExpression(expression, location, absoluteOffset) {
      var sourceToLex = this._stripComments(expression);

      var tokens = this._lexer.tokenize(sourceToLex);

      var ast = new _ParseAST(expression, location, absoluteOffset, tokens, 0
      /* ParseFlags.None */
      , this.errors, 0).parseChain();
      var strings = ['', '']; // The prefix and suffix strings are both empty

      return this.createInterpolationAst(strings, [ast], expression, location, absoluteOffset);
    }
  }, {
    key: "createInterpolationAst",
    value: function createInterpolationAst(strings, expressions, input, location, absoluteOffset) {
      var span = new ParseSpan(0, input.length);
      var interpolation = new Interpolation(span, span.toAbsolute(absoluteOffset), strings, expressions);
      return new ASTWithSource(interpolation, input, location, absoluteOffset, this.errors);
    }
    /**
     * Splits a string of text into "raw" text segments and expressions present in interpolations in
     * the string.
     * Returns `null` if there are no interpolations, otherwise a
     * `SplitInterpolation` with splits that look like
     *   <raw text> <expression> <raw text> ... <raw text> <expression> <raw text>
     */

  }, {
    key: "splitInterpolation",
    value: function splitInterpolation(input, location, interpolatedTokens) {
      var interpolationConfig = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_INTERPOLATION_CONFIG;

      var _a;

      var strings = [];
      var expressions = [];
      var offsets = [];
      var inputToTemplateIndexMap = interpolatedTokens ? getIndexMapForOriginalTemplate(interpolatedTokens) : null;
      var i = 0;
      var atInterpolation = false;
      var extendLastString = false;
      var interpStart = interpolationConfig.start,
          interpEnd = interpolationConfig.end;

      while (i < input.length) {
        if (!atInterpolation) {
          // parse until starting {{
          var _start2 = i;
          i = input.indexOf(interpStart, i);

          if (i === -1) {
            i = input.length;
          }

          var text = input.substring(_start2, i);
          strings.push({
            text: text,
            start: _start2,
            end: i
          });
          atInterpolation = true;
        } else {
          // parse from starting {{ to ending }} while ignoring content inside quotes.
          var fullStart = i;
          var exprStart = fullStart + interpStart.length;

          var exprEnd = this._getInterpolationEndIndex(input, interpEnd, exprStart);

          if (exprEnd === -1) {
            // Could not find the end of the interpolation; do not parse an expression.
            // Instead we should extend the content on the last raw string.
            atInterpolation = false;
            extendLastString = true;
            break;
          }

          var fullEnd = exprEnd + interpEnd.length;

          var _text = input.substring(exprStart, exprEnd);

          if (_text.trim().length === 0) {
            this._reportError('Blank expressions are not allowed in interpolated strings', input, "at column ".concat(i, " in"), location);
          }

          expressions.push({
            text: _text,
            start: fullStart,
            end: fullEnd
          });
          var startInOriginalTemplate = (_a = inputToTemplateIndexMap === null || inputToTemplateIndexMap === void 0 ? void 0 : inputToTemplateIndexMap.get(fullStart)) !== null && _a !== void 0 ? _a : fullStart;
          var offset = startInOriginalTemplate + interpStart.length;
          offsets.push(offset);
          i = fullEnd;
          atInterpolation = false;
        }
      }

      if (!atInterpolation) {
        // If we are now at a text section, add the remaining content as a raw string.
        if (extendLastString) {
          var piece = strings[strings.length - 1];
          piece.text += input.substring(i);
          piece.end = input.length;
        } else {
          strings.push({
            text: input.substring(i),
            start: i,
            end: input.length
          });
        }
      }

      return new SplitInterpolation(strings, expressions, offsets);
    }
  }, {
    key: "wrapLiteralPrimitive",
    value: function wrapLiteralPrimitive(input, location, absoluteOffset) {
      var span = new ParseSpan(0, input == null ? 0 : input.length);
      return new ASTWithSource(new LiteralPrimitive(span, span.toAbsolute(absoluteOffset), input), input, location, absoluteOffset, this.errors);
    }
  }, {
    key: "_stripComments",
    value: function _stripComments(input) {
      var i = this._commentStart(input);

      return i != null ? input.substring(0, i) : input;
    }
  }, {
    key: "_commentStart",
    value: function _commentStart(input) {
      var outerQuote = null;

      for (var i = 0; i < input.length - 1; i++) {
        var char = input.charCodeAt(i);
        var nextChar = input.charCodeAt(i + 1);
        if (char === $SLASH && nextChar == $SLASH && outerQuote == null) return i;

        if (outerQuote === char) {
          outerQuote = null;
        } else if (outerQuote == null && isQuote(char)) {
          outerQuote = char;
        }
      }

      return null;
    }
  }, {
    key: "_checkNoInterpolation",
    value: function _checkNoInterpolation(input, location, _ref6) {
      var start = _ref6.start,
          end = _ref6.end;
      var startIndex = -1;
      var endIndex = -1;

      var _iterator10 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper_js__WEBPACK_IMPORTED_MODULE_9__["default"])(this._forEachUnquotedChar(input, 0)),
          _step10;

      try {
        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
          var charIndex = _step10.value;

          if (startIndex === -1) {
            if (input.startsWith(start)) {
              startIndex = charIndex;
            }
          } else {
            endIndex = this._getInterpolationEndIndex(input, end, charIndex);

            if (endIndex > -1) {
              break;
            }
          }
        }
      } catch (err) {
        _iterator10.e(err);
      } finally {
        _iterator10.f();
      }

      if (startIndex > -1 && endIndex > -1) {
        this._reportError("Got interpolation (".concat(start).concat(end, ") where expression was expected"), input, "at column ".concat(startIndex, " in"), location);
      }
    }
    /**
     * Finds the index of the end of an interpolation expression
     * while ignoring comments and quoted content.
     */

  }, {
    key: "_getInterpolationEndIndex",
    value: function _getInterpolationEndIndex(input, expressionEnd, start) {
      var _iterator11 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper_js__WEBPACK_IMPORTED_MODULE_9__["default"])(this._forEachUnquotedChar(input, start)),
          _step11;

      try {
        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
          var charIndex = _step11.value;

          if (input.startsWith(expressionEnd, charIndex)) {
            return charIndex;
          } // Nothing else in the expression matters after we've
          // hit a comment so look directly for the end token.


          if (input.startsWith('//', charIndex)) {
            return input.indexOf(expressionEnd, charIndex);
          }
        }
      } catch (err) {
        _iterator11.e(err);
      } finally {
        _iterator11.f();
      }

      return -1;
    }
    /**
     * Generator used to iterate over the character indexes of a string that are outside of quotes.
     * @param input String to loop through.
     * @param start Index within the string at which to start.
     */

  }, {
    key: "_forEachUnquotedChar",
    value:
    /*#__PURE__*/
    _regeneratorRuntime().mark(function _forEachUnquotedChar(input, start) {
      var currentQuote, escapeCount, i, char;
      return _regeneratorRuntime().wrap(function _forEachUnquotedChar$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              currentQuote = null;
              escapeCount = 0;
              i = start;

            case 3:
              if (!(i < input.length)) {
                _context2.next = 16;
                break;
              }

              char = input[i]; // Skip the characters inside quotes. Note that we only care about the outer-most
              // quotes matching up and we need to account for escape characters.

              if (!(isQuote(input.charCodeAt(i)) && (currentQuote === null || currentQuote === char) && escapeCount % 2 === 0)) {
                _context2.next = 9;
                break;
              }

              currentQuote = currentQuote === null ? char : null;
              _context2.next = 12;
              break;

            case 9:
              if (!(currentQuote === null)) {
                _context2.next = 12;
                break;
              }

              _context2.next = 12;
              return i;

            case 12:
              escapeCount = char === '\\' ? escapeCount + 1 : 0;

            case 13:
              i++;
              _context2.next = 3;
              break;

            case 16:
            case "end":
              return _context2.stop();
          }
        }
      }, _forEachUnquotedChar);
    })
  }]);

  return Parser$1;
}();
/** Describes a stateful context an expression parser is in. */


var ParseContextFlags;

(function (ParseContextFlags) {
  ParseContextFlags[ParseContextFlags["None"] = 0] = "None";
  /**
   * A Writable context is one in which a value may be written to an lvalue.
   * For example, after we see a property access, we may expect a write to the
   * property via the "=" operator.
   *   prop
   *        ^ possible "=" after
   */

  ParseContextFlags[ParseContextFlags["Writable"] = 1] = "Writable";
})(ParseContextFlags || (ParseContextFlags = {}));

var _ParseAST = /*#__PURE__*/function () {
  function _ParseAST(input, location, absoluteOffset, tokens, parseFlags, errors, offset) {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, _ParseAST);

    this.input = input;
    this.location = location;
    this.absoluteOffset = absoluteOffset;
    this.tokens = tokens;
    this.parseFlags = parseFlags;
    this.errors = errors;
    this.offset = offset;
    this.rparensExpected = 0;
    this.rbracketsExpected = 0;
    this.rbracesExpected = 0;
    this.context = ParseContextFlags.None; // Cache of expression start and input indeces to the absolute source span they map to, used to
    // prevent creating superfluous source spans in `sourceSpan`.
    // A serial of the expression start and input index is used for mapping because both are stateful
    // and may change for subsequent expressions visited by the parser.

    this.sourceSpanCache = new Map();
    this.index = 0;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(_ParseAST, [{
    key: "peek",
    value: function peek(offset) {
      var i = this.index + offset;
      return i < this.tokens.length ? this.tokens[i] : EOF;
    }
  }, {
    key: "next",
    get: function get() {
      return this.peek(0);
    }
    /** Whether all the parser input has been processed. */

  }, {
    key: "atEOF",
    get: function get() {
      return this.index >= this.tokens.length;
    }
    /**
     * Index of the next token to be processed, or the end of the last token if all have been
     * processed.
     */

  }, {
    key: "inputIndex",
    get: function get() {
      return this.atEOF ? this.currentEndIndex : this.next.index + this.offset;
    }
    /**
     * End index of the last processed token, or the start of the first token if none have been
     * processed.
     */

  }, {
    key: "currentEndIndex",
    get: function get() {
      if (this.index > 0) {
        var curToken = this.peek(-1);
        return curToken.end + this.offset;
      } // No tokens have been processed yet; return the next token's start or the length of the input
      // if there is no token.


      if (this.tokens.length === 0) {
        return this.input.length + this.offset;
      }

      return this.next.index + this.offset;
    }
    /**
     * Returns the absolute offset of the start of the current token.
     */

  }, {
    key: "currentAbsoluteOffset",
    get: function get() {
      return this.absoluteOffset + this.inputIndex;
    }
    /**
     * Retrieve a `ParseSpan` from `start` to the current position (or to `artificialEndIndex` if
     * provided).
     *
     * @param start Position from which the `ParseSpan` will start.
     * @param artificialEndIndex Optional ending index to be used if provided (and if greater than the
     *     natural ending index)
     */

  }, {
    key: "span",
    value: function span(start, artificialEndIndex) {
      var endIndex = this.currentEndIndex;

      if (artificialEndIndex !== undefined && artificialEndIndex > this.currentEndIndex) {
        endIndex = artificialEndIndex;
      } // In some unusual parsing scenarios (like when certain tokens are missing and an `EmptyExpr` is
      // being created), the current token may already be advanced beyond the `currentEndIndex`. This
      // appears to be a deep-seated parser bug.
      //
      // As a workaround for now, swap the start and end indices to ensure a valid `ParseSpan`.
      // TODO(alxhub): fix the bug upstream in the parser state, and remove this workaround.


      if (start > endIndex) {
        var tmp = endIndex;
        endIndex = start;
        start = tmp;
      }

      return new ParseSpan(start, endIndex);
    }
  }, {
    key: "sourceSpan",
    value: function sourceSpan(start, artificialEndIndex) {
      var serial = "".concat(start, "@").concat(this.inputIndex, ":").concat(artificialEndIndex);

      if (!this.sourceSpanCache.has(serial)) {
        this.sourceSpanCache.set(serial, this.span(start, artificialEndIndex).toAbsolute(this.absoluteOffset));
      }

      return this.sourceSpanCache.get(serial);
    }
  }, {
    key: "advance",
    value: function advance() {
      this.index++;
    }
    /**
     * Executes a callback in the provided context.
     */

  }, {
    key: "withContext",
    value: function withContext(context, cb) {
      this.context |= context;
      var ret = cb();
      this.context ^= context;
      return ret;
    }
  }, {
    key: "consumeOptionalCharacter",
    value: function consumeOptionalCharacter(code) {
      if (this.next.isCharacter(code)) {
        this.advance();
        return true;
      } else {
        return false;
      }
    }
  }, {
    key: "peekKeywordLet",
    value: function peekKeywordLet() {
      return this.next.isKeywordLet();
    }
  }, {
    key: "peekKeywordAs",
    value: function peekKeywordAs() {
      return this.next.isKeywordAs();
    }
    /**
     * Consumes an expected character, otherwise emits an error about the missing expected character
     * and skips over the token stream until reaching a recoverable point.
     *
     * See `this.error` and `this.skip` for more details.
     */

  }, {
    key: "expectCharacter",
    value: function expectCharacter(code) {
      if (this.consumeOptionalCharacter(code)) return;
      this.error("Missing expected ".concat(String.fromCharCode(code)));
    }
  }, {
    key: "consumeOptionalOperator",
    value: function consumeOptionalOperator(op) {
      if (this.next.isOperator(op)) {
        this.advance();
        return true;
      } else {
        return false;
      }
    }
  }, {
    key: "expectOperator",
    value: function expectOperator(operator) {
      if (this.consumeOptionalOperator(operator)) return;
      this.error("Missing expected operator ".concat(operator));
    }
  }, {
    key: "prettyPrintToken",
    value: function prettyPrintToken(tok) {
      return tok === EOF ? 'end of input' : "token ".concat(tok);
    }
  }, {
    key: "expectIdentifierOrKeyword",
    value: function expectIdentifierOrKeyword() {
      var n = this.next;

      if (!n.isIdentifier() && !n.isKeyword()) {
        if (n.isPrivateIdentifier()) {
          this._reportErrorForPrivateIdentifier(n, 'expected identifier or keyword');
        } else {
          this.error("Unexpected ".concat(this.prettyPrintToken(n), ", expected identifier or keyword"));
        }

        return null;
      }

      this.advance();
      return n.toString();
    }
  }, {
    key: "expectIdentifierOrKeywordOrString",
    value: function expectIdentifierOrKeywordOrString() {
      var n = this.next;

      if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {
        if (n.isPrivateIdentifier()) {
          this._reportErrorForPrivateIdentifier(n, 'expected identifier, keyword or string');
        } else {
          this.error("Unexpected ".concat(this.prettyPrintToken(n), ", expected identifier, keyword, or string"));
        }

        return '';
      }

      this.advance();
      return n.toString();
    }
  }, {
    key: "parseChain",
    value: function parseChain() {
      var exprs = [];
      var start = this.inputIndex;

      while (this.index < this.tokens.length) {
        var expr = this.parsePipe();
        exprs.push(expr);

        if (this.consumeOptionalCharacter($SEMICOLON)) {
          if (!(this.parseFlags & 1
          /* ParseFlags.Action */
          )) {
            this.error('Binding expression cannot contain chained expression');
          }

          while (this.consumeOptionalCharacter($SEMICOLON)) {} // read all semicolons

        } else if (this.index < this.tokens.length) {
          this.error("Unexpected token '".concat(this.next, "'"));
        }
      }

      if (exprs.length == 0) {
        // We have no expressions so create an empty expression that spans the entire input length
        var artificialStart = this.offset;
        var artificialEnd = this.offset + this.input.length;
        return new EmptyExpr(this.span(artificialStart, artificialEnd), this.sourceSpan(artificialStart, artificialEnd));
      }

      if (exprs.length == 1) return exprs[0];
      return new Chain(this.span(start), this.sourceSpan(start), exprs);
    }
  }, {
    key: "parsePipe",
    value: function parsePipe() {
      var start = this.inputIndex;
      var result = this.parseExpression();

      if (this.consumeOptionalOperator('|')) {
        if (this.parseFlags & 1
        /* ParseFlags.Action */
        ) {
          this.error('Cannot have a pipe in an action expression');
        }

        do {
          var nameStart = this.inputIndex;
          var nameId = this.expectIdentifierOrKeyword();
          var nameSpan = void 0;
          var fullSpanEnd = undefined;

          if (nameId !== null) {
            nameSpan = this.sourceSpan(nameStart);
          } else {
            // No valid identifier was found, so we'll assume an empty pipe name ('').
            nameId = ''; // However, there may have been whitespace present between the pipe character and the next
            // token in the sequence (or the end of input). We want to track this whitespace so that
            // the `BindingPipe` we produce covers not just the pipe character, but any trailing
            // whitespace beyond it. Another way of thinking about this is that the zero-length name
            // is assumed to be at the end of any whitespace beyond the pipe character.
            //
            // Therefore, we push the end of the `ParseSpan` for this pipe all the way up to the
            // beginning of the next token, or until the end of input if the next token is EOF.

            fullSpanEnd = this.next.index !== -1 ? this.next.index : this.input.length + this.offset; // The `nameSpan` for an empty pipe name is zero-length at the end of any whitespace
            // beyond the pipe character.

            nameSpan = new ParseSpan(fullSpanEnd, fullSpanEnd).toAbsolute(this.absoluteOffset);
          }

          var args = [];

          while (this.consumeOptionalCharacter($COLON)) {
            args.push(this.parseExpression()); // If there are additional expressions beyond the name, then the artificial end for the
            // name is no longer relevant.
          }

          result = new BindingPipe(this.span(start), this.sourceSpan(start, fullSpanEnd), result, nameId, args, nameSpan);
        } while (this.consumeOptionalOperator('|'));
      }

      return result;
    }
  }, {
    key: "parseExpression",
    value: function parseExpression() {
      return this.parseConditional();
    }
  }, {
    key: "parseConditional",
    value: function parseConditional() {
      var start = this.inputIndex;
      var result = this.parseLogicalOr();

      if (this.consumeOptionalOperator('?')) {
        var yes = this.parsePipe();
        var no;

        if (!this.consumeOptionalCharacter($COLON)) {
          var end = this.inputIndex;
          var expression = this.input.substring(start, end);
          this.error("Conditional expression ".concat(expression, " requires all 3 expressions"));
          no = new EmptyExpr(this.span(start), this.sourceSpan(start));
        } else {
          no = this.parsePipe();
        }

        return new Conditional(this.span(start), this.sourceSpan(start), result, yes, no);
      } else {
        return result;
      }
    }
  }, {
    key: "parseLogicalOr",
    value: function parseLogicalOr() {
      // '||'
      var start = this.inputIndex;
      var result = this.parseLogicalAnd();

      while (this.consumeOptionalOperator('||')) {
        var right = this.parseLogicalAnd();
        result = new Binary(this.span(start), this.sourceSpan(start), '||', result, right);
      }

      return result;
    }
  }, {
    key: "parseLogicalAnd",
    value: function parseLogicalAnd() {
      // '&&'
      var start = this.inputIndex;
      var result = this.parseNullishCoalescing();

      while (this.consumeOptionalOperator('&&')) {
        var right = this.parseNullishCoalescing();
        result = new Binary(this.span(start), this.sourceSpan(start), '&&', result, right);
      }

      return result;
    }
  }, {
    key: "parseNullishCoalescing",
    value: function parseNullishCoalescing() {
      // '??'
      var start = this.inputIndex;
      var result = this.parseEquality();

      while (this.consumeOptionalOperator('??')) {
        var right = this.parseEquality();
        result = new Binary(this.span(start), this.sourceSpan(start), '??', result, right);
      }

      return result;
    }
  }, {
    key: "parseEquality",
    value: function parseEquality() {
      // '==','!=','===','!=='
      var start = this.inputIndex;
      var result = this.parseRelational();

      while (this.next.type == TokenType.Operator) {
        var operator = this.next.strValue;

        switch (operator) {
          case '==':
          case '===':
          case '!=':
          case '!==':
            this.advance();
            var right = this.parseRelational();
            result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);
            continue;
        }

        break;
      }

      return result;
    }
  }, {
    key: "parseRelational",
    value: function parseRelational() {
      // '<', '>', '<=', '>='
      var start = this.inputIndex;
      var result = this.parseAdditive();

      while (this.next.type == TokenType.Operator) {
        var operator = this.next.strValue;

        switch (operator) {
          case '<':
          case '>':
          case '<=':
          case '>=':
            this.advance();
            var right = this.parseAdditive();
            result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);
            continue;
        }

        break;
      }

      return result;
    }
  }, {
    key: "parseAdditive",
    value: function parseAdditive() {
      // '+', '-'
      var start = this.inputIndex;
      var result = this.parseMultiplicative();

      while (this.next.type == TokenType.Operator) {
        var operator = this.next.strValue;

        switch (operator) {
          case '+':
          case '-':
            this.advance();
            var right = this.parseMultiplicative();
            result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);
            continue;
        }

        break;
      }

      return result;
    }
  }, {
    key: "parseMultiplicative",
    value: function parseMultiplicative() {
      // '*', '%', '/'
      var start = this.inputIndex;
      var result = this.parsePrefix();

      while (this.next.type == TokenType.Operator) {
        var operator = this.next.strValue;

        switch (operator) {
          case '*':
          case '%':
          case '/':
            this.advance();
            var right = this.parsePrefix();
            result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);
            continue;
        }

        break;
      }

      return result;
    }
  }, {
    key: "parsePrefix",
    value: function parsePrefix() {
      if (this.next.type == TokenType.Operator) {
        var _start3 = this.inputIndex;
        var operator = this.next.strValue;
        var result;

        switch (operator) {
          case '+':
            this.advance();
            result = this.parsePrefix();
            return Unary.createPlus(this.span(_start3), this.sourceSpan(_start3), result);

          case '-':
            this.advance();
            result = this.parsePrefix();
            return Unary.createMinus(this.span(_start3), this.sourceSpan(_start3), result);

          case '!':
            this.advance();
            result = this.parsePrefix();
            return new PrefixNot(this.span(_start3), this.sourceSpan(_start3), result);
        }
      }

      return this.parseCallChain();
    }
  }, {
    key: "parseCallChain",
    value: function parseCallChain() {
      var start = this.inputIndex;
      var result = this.parsePrimary();

      while (true) {
        if (this.consumeOptionalCharacter($PERIOD)) {
          result = this.parseAccessMember(result, start, false);
        } else if (this.consumeOptionalOperator('?.')) {
          if (this.consumeOptionalCharacter($LPAREN)) {
            result = this.parseCall(result, start, true);
          } else {
            result = this.consumeOptionalCharacter($LBRACKET) ? this.parseKeyedReadOrWrite(result, start, true) : this.parseAccessMember(result, start, true);
          }
        } else if (this.consumeOptionalCharacter($LBRACKET)) {
          result = this.parseKeyedReadOrWrite(result, start, false);
        } else if (this.consumeOptionalCharacter($LPAREN)) {
          result = this.parseCall(result, start, false);
        } else if (this.consumeOptionalOperator('!')) {
          result = new NonNullAssert(this.span(start), this.sourceSpan(start), result);
        } else {
          return result;
        }
      }
    }
  }, {
    key: "parsePrimary",
    value: function parsePrimary() {
      var start = this.inputIndex;

      if (this.consumeOptionalCharacter($LPAREN)) {
        this.rparensExpected++;
        var result = this.parsePipe();
        this.rparensExpected--;
        this.expectCharacter($RPAREN);
        return result;
      } else if (this.next.isKeywordNull()) {
        this.advance();
        return new LiteralPrimitive(this.span(start), this.sourceSpan(start), null);
      } else if (this.next.isKeywordUndefined()) {
        this.advance();
        return new LiteralPrimitive(this.span(start), this.sourceSpan(start), void 0);
      } else if (this.next.isKeywordTrue()) {
        this.advance();
        return new LiteralPrimitive(this.span(start), this.sourceSpan(start), true);
      } else if (this.next.isKeywordFalse()) {
        this.advance();
        return new LiteralPrimitive(this.span(start), this.sourceSpan(start), false);
      } else if (this.next.isKeywordThis()) {
        this.advance();
        return new ThisReceiver(this.span(start), this.sourceSpan(start));
      } else if (this.consumeOptionalCharacter($LBRACKET)) {
        this.rbracketsExpected++;
        var elements = this.parseExpressionList($RBRACKET);
        this.rbracketsExpected--;
        this.expectCharacter($RBRACKET);
        return new LiteralArray(this.span(start), this.sourceSpan(start), elements);
      } else if (this.next.isCharacter($LBRACE)) {
        return this.parseLiteralMap();
      } else if (this.next.isIdentifier()) {
        return this.parseAccessMember(new ImplicitReceiver(this.span(start), this.sourceSpan(start)), start, false);
      } else if (this.next.isNumber()) {
        var value = this.next.toNumber();
        this.advance();
        return new LiteralPrimitive(this.span(start), this.sourceSpan(start), value);
      } else if (this.next.isString()) {
        var literalValue = this.next.toString();
        this.advance();
        return new LiteralPrimitive(this.span(start), this.sourceSpan(start), literalValue);
      } else if (this.next.isPrivateIdentifier()) {
        this._reportErrorForPrivateIdentifier(this.next, null);

        return new EmptyExpr(this.span(start), this.sourceSpan(start));
      } else if (this.index >= this.tokens.length) {
        this.error("Unexpected end of expression: ".concat(this.input));
        return new EmptyExpr(this.span(start), this.sourceSpan(start));
      } else {
        this.error("Unexpected token ".concat(this.next));
        return new EmptyExpr(this.span(start), this.sourceSpan(start));
      }
    }
  }, {
    key: "parseExpressionList",
    value: function parseExpressionList(terminator) {
      var result = [];

      do {
        if (!this.next.isCharacter(terminator)) {
          result.push(this.parsePipe());
        } else {
          break;
        }
      } while (this.consumeOptionalCharacter($COMMA));

      return result;
    }
  }, {
    key: "parseLiteralMap",
    value: function parseLiteralMap() {
      var keys = [];
      var values = [];
      var start = this.inputIndex;
      this.expectCharacter($LBRACE);

      if (!this.consumeOptionalCharacter($RBRACE)) {
        this.rbracesExpected++;

        do {
          var keyStart = this.inputIndex;
          var quoted = this.next.isString();
          var key = this.expectIdentifierOrKeywordOrString();
          keys.push({
            key: key,
            quoted: quoted
          }); // Properties with quoted keys can't use the shorthand syntax.

          if (quoted) {
            this.expectCharacter($COLON);
            values.push(this.parsePipe());
          } else if (this.consumeOptionalCharacter($COLON)) {
            values.push(this.parsePipe());
          } else {
            var span = this.span(keyStart);
            var sourceSpan = this.sourceSpan(keyStart);
            values.push(new PropertyRead(span, sourceSpan, sourceSpan, new ImplicitReceiver(span, sourceSpan), key));
          }
        } while (this.consumeOptionalCharacter($COMMA));

        this.rbracesExpected--;
        this.expectCharacter($RBRACE);
      }

      return new LiteralMap(this.span(start), this.sourceSpan(start), keys, values);
    }
  }, {
    key: "parseAccessMember",
    value: function parseAccessMember(readReceiver, start, isSafe) {
      var _this107 = this;

      var nameStart = this.inputIndex;
      var id = this.withContext(ParseContextFlags.Writable, function () {
        var _a;

        var id = (_a = _this107.expectIdentifierOrKeyword()) !== null && _a !== void 0 ? _a : '';

        if (id.length === 0) {
          _this107.error("Expected identifier for property access", readReceiver.span.end);
        }

        return id;
      });
      var nameSpan = this.sourceSpan(nameStart);
      var receiver;

      if (isSafe) {
        if (this.consumeOptionalAssignment()) {
          this.error('The \'?.\' operator cannot be used in the assignment');
          receiver = new EmptyExpr(this.span(start), this.sourceSpan(start));
        } else {
          receiver = new SafePropertyRead(this.span(start), this.sourceSpan(start), nameSpan, readReceiver, id);
        }
      } else {
        if (this.consumeOptionalAssignment()) {
          if (!(this.parseFlags & 1
          /* ParseFlags.Action */
          )) {
            this.error('Bindings cannot contain assignments');
            return new EmptyExpr(this.span(start), this.sourceSpan(start));
          }

          var value = this.parseConditional();
          receiver = new PropertyWrite(this.span(start), this.sourceSpan(start), nameSpan, readReceiver, id, value);
        } else {
          receiver = new PropertyRead(this.span(start), this.sourceSpan(start), nameSpan, readReceiver, id);
        }
      }

      return receiver;
    }
  }, {
    key: "parseCall",
    value: function parseCall(receiver, start, isSafe) {
      var argumentStart = this.inputIndex;
      this.rparensExpected++;
      var args = this.parseCallArguments();
      var argumentSpan = this.span(argumentStart, this.inputIndex).toAbsolute(this.absoluteOffset);
      this.expectCharacter($RPAREN);
      this.rparensExpected--;
      var span = this.span(start);
      var sourceSpan = this.sourceSpan(start);
      return isSafe ? new SafeCall(span, sourceSpan, receiver, args, argumentSpan) : new Call(span, sourceSpan, receiver, args, argumentSpan);
    }
  }, {
    key: "consumeOptionalAssignment",
    value: function consumeOptionalAssignment() {
      // When parsing assignment events (originating from two-way-binding aka banana-in-a-box syntax),
      // it is valid for the primary expression to be terminated by the non-null operator. This
      // primary expression is substituted as LHS of the assignment operator to achieve
      // two-way-binding, such that the LHS could be the non-null operator. The grammar doesn't
      // naturally allow for this syntax, so assignment events are parsed specially.
      if (this.parseFlags & 2
      /* ParseFlags.AssignmentEvent */
      && this.next.isOperator('!') && this.peek(1).isOperator('=')) {
        // First skip over the ! operator.
        this.advance(); // Then skip over the = operator, to fully consume the optional assignment operator.

        this.advance();
        return true;
      }

      return this.consumeOptionalOperator('=');
    }
  }, {
    key: "parseCallArguments",
    value: function parseCallArguments() {
      if (this.next.isCharacter($RPAREN)) return [];
      var positionals = [];

      do {
        positionals.push(this.parsePipe());
      } while (this.consumeOptionalCharacter($COMMA));

      return positionals;
    }
    /**
     * Parses an identifier, a keyword, a string with an optional `-` in between,
     * and returns the string along with its absolute source span.
     */

  }, {
    key: "expectTemplateBindingKey",
    value: function expectTemplateBindingKey() {
      var result = '';
      var operatorFound = false;
      var start = this.currentAbsoluteOffset;

      do {
        result += this.expectIdentifierOrKeywordOrString();
        operatorFound = this.consumeOptionalOperator('-');

        if (operatorFound) {
          result += '-';
        }
      } while (operatorFound);

      return {
        source: result,
        span: new AbsoluteSourceSpan(start, start + result.length)
      };
    }
    /**
     * Parse microsyntax template expression and return a list of bindings or
     * parsing errors in case the given expression is invalid.
     *
     * For example,
     * ```
     *   <div *ngFor="let item of items; index as i; trackBy: func">
     * ```
     * contains five bindings:
     * 1. ngFor -> null
     * 2. item -> NgForOfContext.$implicit
     * 3. ngForOf -> items
     * 4. i -> NgForOfContext.index
     * 5. ngForTrackBy -> func
     *
     * For a full description of the microsyntax grammar, see
     * https://gist.github.com/mhevery/d3530294cff2e4a1b3fe15ff75d08855
     *
     * @param templateKey name of the microsyntax directive, like ngIf, ngFor,
     * without the *, along with its absolute span.
     */

  }, {
    key: "parseTemplateBindings",
    value: function parseTemplateBindings(templateKey) {
      var bindings = []; // The first binding is for the template key itself
      // In *ngFor="let item of items", key = "ngFor", value = null
      // In *ngIf="cond | pipe", key = "ngIf", value = "cond | pipe"

      bindings.push.apply(bindings, (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(this.parseDirectiveKeywordBindings(templateKey)));

      while (this.index < this.tokens.length) {
        // If it starts with 'let', then this must be variable declaration
        var letBinding = this.parseLetBinding();

        if (letBinding) {
          bindings.push(letBinding);
        } else {
          // Two possible cases here, either `value "as" key` or
          // "directive-keyword expression". We don't know which case, but both
          // "value" and "directive-keyword" are template binding key, so consume
          // the key first.
          var key = this.expectTemplateBindingKey(); // Peek at the next token, if it is "as" then this must be variable
          // declaration.

          var binding = this.parseAsBinding(key);

          if (binding) {
            bindings.push(binding);
          } else {
            // Otherwise the key must be a directive keyword, like "of". Transform
            // the key to actual key. Eg. of -> ngForOf, trackBy -> ngForTrackBy
            key.source = templateKey.source + key.source.charAt(0).toUpperCase() + key.source.substring(1);
            bindings.push.apply(bindings, (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(this.parseDirectiveKeywordBindings(key)));
          }
        }

        this.consumeStatementTerminator();
      }

      return new TemplateBindingParseResult(bindings, []
      /* warnings */
      , this.errors);
    }
  }, {
    key: "parseKeyedReadOrWrite",
    value: function parseKeyedReadOrWrite(receiver, start, isSafe) {
      var _this108 = this;

      return this.withContext(ParseContextFlags.Writable, function () {
        _this108.rbracketsExpected++;

        var key = _this108.parsePipe();

        if (key instanceof EmptyExpr) {
          _this108.error("Key access cannot be empty");
        }

        _this108.rbracketsExpected--;

        _this108.expectCharacter($RBRACKET);

        if (_this108.consumeOptionalOperator('=')) {
          if (isSafe) {
            _this108.error('The \'?.\' operator cannot be used in the assignment');
          } else {
            var value = _this108.parseConditional();

            return new KeyedWrite(_this108.span(start), _this108.sourceSpan(start), receiver, key, value);
          }
        } else {
          return isSafe ? new SafeKeyedRead(_this108.span(start), _this108.sourceSpan(start), receiver, key) : new KeyedRead(_this108.span(start), _this108.sourceSpan(start), receiver, key);
        }

        return new EmptyExpr(_this108.span(start), _this108.sourceSpan(start));
      });
    }
    /**
     * Parse a directive keyword, followed by a mandatory expression.
     * For example, "of items", "trackBy: func".
     * The bindings are: ngForOf -> items, ngForTrackBy -> func
     * There could be an optional "as" binding that follows the expression.
     * For example,
     * ```
     *   *ngFor="let item of items | slice:0:1 as collection".
     *                    ^^ ^^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^
     *               keyword    bound target   optional 'as' binding
     * ```
     *
     * @param key binding key, for example, ngFor, ngIf, ngForOf, along with its
     * absolute span.
     */

  }, {
    key: "parseDirectiveKeywordBindings",
    value: function parseDirectiveKeywordBindings(key) {
      var bindings = [];
      this.consumeOptionalCharacter($COLON); // trackBy: trackByFunction

      var value = this.getDirectiveBoundTarget();
      var spanEnd = this.currentAbsoluteOffset; // The binding could optionally be followed by "as". For example,
      // *ngIf="cond | pipe as x". In this case, the key in the "as" binding
      // is "x" and the value is the template key itself ("ngIf"). Note that the
      // 'key' in the current context now becomes the "value" in the next binding.

      var asBinding = this.parseAsBinding(key);

      if (!asBinding) {
        this.consumeStatementTerminator();
        spanEnd = this.currentAbsoluteOffset;
      }

      var sourceSpan = new AbsoluteSourceSpan(key.span.start, spanEnd);
      bindings.push(new ExpressionBinding(sourceSpan, key, value));

      if (asBinding) {
        bindings.push(asBinding);
      }

      return bindings;
    }
    /**
     * Return the expression AST for the bound target of a directive keyword
     * binding. For example,
     * ```
     *   *ngIf="condition | pipe"
     *          ^^^^^^^^^^^^^^^^ bound target for "ngIf"
     *   *ngFor="let item of items"
     *                       ^^^^^ bound target for "ngForOf"
     * ```
     */

  }, {
    key: "getDirectiveBoundTarget",
    value: function getDirectiveBoundTarget() {
      if (this.next === EOF || this.peekKeywordAs() || this.peekKeywordLet()) {
        return null;
      }

      var ast = this.parsePipe(); // example: "condition | async"

      var _ast$span = ast.span,
          start = _ast$span.start,
          end = _ast$span.end;
      var value = this.input.substring(start, end);
      return new ASTWithSource(ast, value, this.location, this.absoluteOffset + start, this.errors);
    }
    /**
     * Return the binding for a variable declared using `as`. Note that the order
     * of the key-value pair in this declaration is reversed. For example,
     * ```
     *   *ngFor="let item of items; index as i"
     *                              ^^^^^    ^
     *                              value    key
     * ```
     *
     * @param value name of the value in the declaration, "ngIf" in the example
     * above, along with its absolute span.
     */

  }, {
    key: "parseAsBinding",
    value: function parseAsBinding(value) {
      if (!this.peekKeywordAs()) {
        return null;
      }

      this.advance(); // consume the 'as' keyword

      var key = this.expectTemplateBindingKey();
      this.consumeStatementTerminator();
      var sourceSpan = new AbsoluteSourceSpan(value.span.start, this.currentAbsoluteOffset);
      return new VariableBinding(sourceSpan, key, value);
    }
    /**
     * Return the binding for a variable declared using `let`. For example,
     * ```
     *   *ngFor="let item of items; let i=index;"
     *           ^^^^^^^^           ^^^^^^^^^^^
     * ```
     * In the first binding, `item` is bound to `NgForOfContext.$implicit`.
     * In the second binding, `i` is bound to `NgForOfContext.index`.
     */

  }, {
    key: "parseLetBinding",
    value: function parseLetBinding() {
      if (!this.peekKeywordLet()) {
        return null;
      }

      var spanStart = this.currentAbsoluteOffset;
      this.advance(); // consume the 'let' keyword

      var key = this.expectTemplateBindingKey();
      var value = null;

      if (this.consumeOptionalOperator('=')) {
        value = this.expectTemplateBindingKey();
      }

      this.consumeStatementTerminator();
      var sourceSpan = new AbsoluteSourceSpan(spanStart, this.currentAbsoluteOffset);
      return new VariableBinding(sourceSpan, key, value);
    }
    /**
     * Consume the optional statement terminator: semicolon or comma.
     */

  }, {
    key: "consumeStatementTerminator",
    value: function consumeStatementTerminator() {
      this.consumeOptionalCharacter($SEMICOLON) || this.consumeOptionalCharacter($COMMA);
    }
    /**
     * Records an error and skips over the token stream until reaching a recoverable point. See
     * `this.skip` for more details on token skipping.
     */

  }, {
    key: "error",
    value: function error(message) {
      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      this.errors.push(new ParserError(message, this.input, this.locationText(index), this.location));
      this.skip();
    }
  }, {
    key: "locationText",
    value: function locationText() {
      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      if (index == null) index = this.index;
      return index < this.tokens.length ? "at column ".concat(this.tokens[index].index + 1, " in") : "at the end of the expression";
    }
    /**
     * Records an error for an unexpected private identifier being discovered.
     * @param token Token representing a private identifier.
     * @param extraMessage Optional additional message being appended to the error.
     */

  }, {
    key: "_reportErrorForPrivateIdentifier",
    value: function _reportErrorForPrivateIdentifier(token, extraMessage) {
      var errorMessage = "Private identifiers are not supported. Unexpected private identifier: ".concat(token);

      if (extraMessage !== null) {
        errorMessage += ", ".concat(extraMessage);
      }

      this.error(errorMessage);
    }
    /**
     * Error recovery should skip tokens until it encounters a recovery point.
     *
     * The following are treated as unconditional recovery points:
     *   - end of input
     *   - ';' (parseChain() is always the root production, and it expects a ';')
     *   - '|' (since pipes may be chained and each pipe expression may be treated independently)
     *
     * The following are conditional recovery points:
     *   - ')', '}', ']' if one of calling productions is expecting one of these symbols
     *     - This allows skip() to recover from errors such as '(a.) + 1' allowing more of the AST to
     *       be retained (it doesn't skip any tokens as the ')' is retained because of the '(' begins
     *       an '(' <expr> ')' production).
     *       The recovery points of grouping symbols must be conditional as they must be skipped if
     *       none of the calling productions are not expecting the closing token else we will never
     *       make progress in the case of an extraneous group closing symbol (such as a stray ')').
     *       That is, we skip a closing symbol if we are not in a grouping production.
     *   - '=' in a `Writable` context
     *     - In this context, we are able to recover after seeing the `=` operator, which
     *       signals the presence of an independent rvalue expression following the `=` operator.
     *
     * If a production expects one of these token it increments the corresponding nesting count,
     * and then decrements it just prior to checking if the token is in the input.
     */

  }, {
    key: "skip",
    value: function skip() {
      var n = this.next;

      while (this.index < this.tokens.length && !n.isCharacter($SEMICOLON) && !n.isOperator('|') && (this.rparensExpected <= 0 || !n.isCharacter($RPAREN)) && (this.rbracesExpected <= 0 || !n.isCharacter($RBRACE)) && (this.rbracketsExpected <= 0 || !n.isCharacter($RBRACKET)) && (!(this.context & ParseContextFlags.Writable) || !n.isOperator('='))) {
        if (this.next.isError()) {
          this.errors.push(new ParserError(this.next.toString(), this.input, this.locationText(), this.location));
        }

        this.advance();
        n = this.next;
      }
    }
  }]);

  return _ParseAST;
}();

var SimpleExpressionChecker = /*#__PURE__*/function (_RecursiveAstVisitor) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(SimpleExpressionChecker, _RecursiveAstVisitor);

  var _super67 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(SimpleExpressionChecker);

  function SimpleExpressionChecker() {
    var _this109;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, SimpleExpressionChecker);

    _this109 = _super67.apply(this, arguments);
    _this109.errors = [];
    return _this109;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(SimpleExpressionChecker, [{
    key: "visitPipe",
    value: function visitPipe() {
      this.errors.push('pipes');
    }
  }]);

  return SimpleExpressionChecker;
}(RecursiveAstVisitor);
/**
 * Computes the real offset in the original template for indexes in an interpolation.
 *
 * Because templates can have encoded HTML entities and the input passed to the parser at this stage
 * of the compiler is the _decoded_ value, we need to compute the real offset using the original
 * encoded values in the interpolated tokens. Note that this is only a special case handling for
 * `MlParserTokenType.ENCODED_ENTITY` token types. All other interpolated tokens are expected to
 * have parts which exactly match the input string for parsing the interpolation.
 *
 * @param interpolatedTokens The tokens for the interpolated value.
 *
 * @returns A map of index locations in the decoded template to indexes in the original template
 */


function getIndexMapForOriginalTemplate(interpolatedTokens) {
  var offsetMap = new Map();
  var consumedInOriginalTemplate = 0;
  var consumedInInput = 0;
  var tokenIndex = 0;

  while (tokenIndex < interpolatedTokens.length) {
    var currentToken = interpolatedTokens[tokenIndex];

    if (currentToken.type === 9
    /* MlParserTokenType.ENCODED_ENTITY */
    ) {
      var _currentToken$parts = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_slicedToArray_js__WEBPACK_IMPORTED_MODULE_3__["default"])(currentToken.parts, 2),
          decoded = _currentToken$parts[0],
          encoded = _currentToken$parts[1];

      consumedInOriginalTemplate += encoded.length;
      consumedInInput += decoded.length;
    } else {
      var lengthOfParts = currentToken.parts.reduce(function (sum, current) {
        return sum + current.length;
      }, 0);
      consumedInInput += lengthOfParts;
      consumedInOriginalTemplate += lengthOfParts;
    }

    offsetMap.set(consumedInInput, consumedInOriginalTemplate);
    tokenIndex++;
  }

  return offsetMap;
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */


var NodeWithI18n = /*#__PURE__*/(0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(function NodeWithI18n(sourceSpan, i18n) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, NodeWithI18n);

  this.sourceSpan = sourceSpan;
  this.i18n = i18n;
});

var Text = /*#__PURE__*/function (_NodeWithI18n) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(Text, _NodeWithI18n);

  var _super68 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(Text);

  function Text(value, sourceSpan, tokens, i18n) {
    var _this110;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, Text);

    _this110 = _super68.call(this, sourceSpan, i18n);
    _this110.value = value;
    _this110.tokens = tokens;
    return _this110;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(Text, [{
    key: "visit",
    value: function visit(visitor, context) {
      return visitor.visitText(this, context);
    }
  }]);

  return Text;
}(NodeWithI18n);

var Expansion = /*#__PURE__*/function (_NodeWithI18n2) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(Expansion, _NodeWithI18n2);

  var _super69 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(Expansion);

  function Expansion(switchValue, type, cases, sourceSpan, switchValueSourceSpan, i18n) {
    var _this111;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, Expansion);

    _this111 = _super69.call(this, sourceSpan, i18n);
    _this111.switchValue = switchValue;
    _this111.type = type;
    _this111.cases = cases;
    _this111.switchValueSourceSpan = switchValueSourceSpan;
    return _this111;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(Expansion, [{
    key: "visit",
    value: function visit(visitor, context) {
      return visitor.visitExpansion(this, context);
    }
  }]);

  return Expansion;
}(NodeWithI18n);

var ExpansionCase = /*#__PURE__*/function () {
  function ExpansionCase(value, expression, sourceSpan, valueSourceSpan, expSourceSpan) {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, ExpansionCase);

    this.value = value;
    this.expression = expression;
    this.sourceSpan = sourceSpan;
    this.valueSourceSpan = valueSourceSpan;
    this.expSourceSpan = expSourceSpan;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(ExpansionCase, [{
    key: "visit",
    value: function visit(visitor, context) {
      return visitor.visitExpansionCase(this, context);
    }
  }]);

  return ExpansionCase;
}();

var Attribute = /*#__PURE__*/function (_NodeWithI18n3) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(Attribute, _NodeWithI18n3);

  var _super70 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(Attribute);

  function Attribute(name, value, sourceSpan, keySpan, valueSpan, valueTokens, i18n) {
    var _this112;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, Attribute);

    _this112 = _super70.call(this, sourceSpan, i18n);
    _this112.name = name;
    _this112.value = value;
    _this112.keySpan = keySpan;
    _this112.valueSpan = valueSpan;
    _this112.valueTokens = valueTokens;
    return _this112;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(Attribute, [{
    key: "visit",
    value: function visit(visitor, context) {
      return visitor.visitAttribute(this, context);
    }
  }]);

  return Attribute;
}(NodeWithI18n);

var Element = /*#__PURE__*/function (_NodeWithI18n4) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(Element, _NodeWithI18n4);

  var _super71 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(Element);

  function Element(name, attrs, children, sourceSpan, startSourceSpan) {
    var _this113;

    var endSourceSpan = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
    var i18n = arguments.length > 6 ? arguments[6] : undefined;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, Element);

    _this113 = _super71.call(this, sourceSpan, i18n);
    _this113.name = name;
    _this113.attrs = attrs;
    _this113.children = children;
    _this113.startSourceSpan = startSourceSpan;
    _this113.endSourceSpan = endSourceSpan;
    return _this113;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(Element, [{
    key: "visit",
    value: function visit(visitor, context) {
      return visitor.visitElement(this, context);
    }
  }]);

  return Element;
}(NodeWithI18n);

var Comment = /*#__PURE__*/function () {
  function Comment(value, sourceSpan) {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, Comment);

    this.value = value;
    this.sourceSpan = sourceSpan;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(Comment, [{
    key: "visit",
    value: function visit(visitor, context) {
      return visitor.visitComment(this, context);
    }
  }]);

  return Comment;
}();

function visitAll(visitor, nodes) {
  var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var result = [];
  var visit = visitor.visit ? function (ast) {
    return visitor.visit(ast, context) || ast.visit(visitor, context);
  } : function (ast) {
    return ast.visit(visitor, context);
  };
  nodes.forEach(function (ast) {
    var astResult = visit(ast);

    if (astResult) {
      result.push(astResult);
    }
  });
  return result;
}

var RecursiveVisitor = /*#__PURE__*/function () {
  function RecursiveVisitor() {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, RecursiveVisitor);
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(RecursiveVisitor, [{
    key: "visitElement",
    value: function visitElement(ast, context) {
      this.visitChildren(context, function (visit) {
        visit(ast.attrs);
        visit(ast.children);
      });
    }
  }, {
    key: "visitAttribute",
    value: function visitAttribute(ast, context) {}
  }, {
    key: "visitText",
    value: function visitText(ast, context) {}
  }, {
    key: "visitComment",
    value: function visitComment(ast, context) {}
  }, {
    key: "visitExpansion",
    value: function visitExpansion(ast, context) {
      return this.visitChildren(context, function (visit) {
        visit(ast.cases);
      });
    }
  }, {
    key: "visitExpansionCase",
    value: function visitExpansionCase(ast, context) {}
  }, {
    key: "visitChildren",
    value: function visitChildren(context, cb) {
      var results = [];
      var t = this;

      function visit(children) {
        if (children) results.push(visitAll(t, children, context));
      }

      cb(visit);
      return Array.prototype.concat.apply([], results);
    }
  }]);

  return RecursiveVisitor;
}();
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
// Mapping between all HTML entity names and their unicode representation.
// Generated from https://html.spec.whatwg.org/multipage/entities.json by stripping
// the `&` and `;` from the keys and removing the duplicates.
// see https://www.w3.org/TR/html51/syntax.html#named-character-references


var NAMED_ENTITIES = {
  'AElig': "\xC6",
  'AMP': "&",
  'amp': "&",
  'Aacute': "\xC1",
  'Abreve': "\u0102",
  'Acirc': "\xC2",
  'Acy': "\u0410",
  'Afr': "\uD835\uDD04",
  'Agrave': "\xC0",
  'Alpha': "\u0391",
  'Amacr': "\u0100",
  'And': "\u2A53",
  'Aogon': "\u0104",
  'Aopf': "\uD835\uDD38",
  'ApplyFunction': "\u2061",
  'af': "\u2061",
  'Aring': "\xC5",
  'angst': "\xC5",
  'Ascr': "\uD835\uDC9C",
  'Assign': "\u2254",
  'colone': "\u2254",
  'coloneq': "\u2254",
  'Atilde': "\xC3",
  'Auml': "\xC4",
  'Backslash': "\u2216",
  'setminus': "\u2216",
  'setmn': "\u2216",
  'smallsetminus': "\u2216",
  'ssetmn': "\u2216",
  'Barv': "\u2AE7",
  'Barwed': "\u2306",
  'doublebarwedge': "\u2306",
  'Bcy': "\u0411",
  'Because': "\u2235",
  'becaus': "\u2235",
  'because': "\u2235",
  'Bernoullis': "\u212C",
  'Bscr': "\u212C",
  'bernou': "\u212C",
  'Beta': "\u0392",
  'Bfr': "\uD835\uDD05",
  'Bopf': "\uD835\uDD39",
  'Breve': "\u02D8",
  'breve': "\u02D8",
  'Bumpeq': "\u224E",
  'HumpDownHump': "\u224E",
  'bump': "\u224E",
  'CHcy': "\u0427",
  'COPY': "\xA9",
  'copy': "\xA9",
  'Cacute': "\u0106",
  'Cap': "\u22D2",
  'CapitalDifferentialD': "\u2145",
  'DD': "\u2145",
  'Cayleys': "\u212D",
  'Cfr': "\u212D",
  'Ccaron': "\u010C",
  'Ccedil': "\xC7",
  'Ccirc': "\u0108",
  'Cconint': "\u2230",
  'Cdot': "\u010A",
  'Cedilla': "\xB8",
  'cedil': "\xB8",
  'CenterDot': "\xB7",
  'centerdot': "\xB7",
  'middot': "\xB7",
  'Chi': "\u03A7",
  'CircleDot': "\u2299",
  'odot': "\u2299",
  'CircleMinus': "\u2296",
  'ominus': "\u2296",
  'CirclePlus': "\u2295",
  'oplus': "\u2295",
  'CircleTimes': "\u2297",
  'otimes': "\u2297",
  'ClockwiseContourIntegral': "\u2232",
  'cwconint': "\u2232",
  'CloseCurlyDoubleQuote': "\u201D",
  'rdquo': "\u201D",
  'rdquor': "\u201D",
  'CloseCurlyQuote': "\u2019",
  'rsquo': "\u2019",
  'rsquor': "\u2019",
  'Colon': "\u2237",
  'Proportion': "\u2237",
  'Colone': "\u2A74",
  'Congruent': "\u2261",
  'equiv': "\u2261",
  'Conint': "\u222F",
  'DoubleContourIntegral': "\u222F",
  'ContourIntegral': "\u222E",
  'conint': "\u222E",
  'oint': "\u222E",
  'Copf': "\u2102",
  'complexes': "\u2102",
  'Coproduct': "\u2210",
  'coprod': "\u2210",
  'CounterClockwiseContourIntegral': "\u2233",
  'awconint': "\u2233",
  'Cross': "\u2A2F",
  'Cscr': "\uD835\uDC9E",
  'Cup': "\u22D3",
  'CupCap': "\u224D",
  'asympeq': "\u224D",
  'DDotrahd': "\u2911",
  'DJcy': "\u0402",
  'DScy': "\u0405",
  'DZcy': "\u040F",
  'Dagger': "\u2021",
  'ddagger': "\u2021",
  'Darr': "\u21A1",
  'Dashv': "\u2AE4",
  'DoubleLeftTee': "\u2AE4",
  'Dcaron': "\u010E",
  'Dcy': "\u0414",
  'Del': "\u2207",
  'nabla': "\u2207",
  'Delta': "\u0394",
  'Dfr': "\uD835\uDD07",
  'DiacriticalAcute': "\xB4",
  'acute': "\xB4",
  'DiacriticalDot': "\u02D9",
  'dot': "\u02D9",
  'DiacriticalDoubleAcute': "\u02DD",
  'dblac': "\u02DD",
  'DiacriticalGrave': "`",
  'grave': "`",
  'DiacriticalTilde': "\u02DC",
  'tilde': "\u02DC",
  'Diamond': "\u22C4",
  'diam': "\u22C4",
  'diamond': "\u22C4",
  'DifferentialD': "\u2146",
  'dd': "\u2146",
  'Dopf': "\uD835\uDD3B",
  'Dot': "\xA8",
  'DoubleDot': "\xA8",
  'die': "\xA8",
  'uml': "\xA8",
  'DotDot': "\u20DC",
  'DotEqual': "\u2250",
  'doteq': "\u2250",
  'esdot': "\u2250",
  'DoubleDownArrow': "\u21D3",
  'Downarrow': "\u21D3",
  'dArr': "\u21D3",
  'DoubleLeftArrow': "\u21D0",
  'Leftarrow': "\u21D0",
  'lArr': "\u21D0",
  'DoubleLeftRightArrow': "\u21D4",
  'Leftrightarrow': "\u21D4",
  'hArr': "\u21D4",
  'iff': "\u21D4",
  'DoubleLongLeftArrow': "\u27F8",
  'Longleftarrow': "\u27F8",
  'xlArr': "\u27F8",
  'DoubleLongLeftRightArrow': "\u27FA",
  'Longleftrightarrow': "\u27FA",
  'xhArr': "\u27FA",
  'DoubleLongRightArrow': "\u27F9",
  'Longrightarrow': "\u27F9",
  'xrArr': "\u27F9",
  'DoubleRightArrow': "\u21D2",
  'Implies': "\u21D2",
  'Rightarrow': "\u21D2",
  'rArr': "\u21D2",
  'DoubleRightTee': "\u22A8",
  'vDash': "\u22A8",
  'DoubleUpArrow': "\u21D1",
  'Uparrow': "\u21D1",
  'uArr': "\u21D1",
  'DoubleUpDownArrow': "\u21D5",
  'Updownarrow': "\u21D5",
  'vArr': "\u21D5",
  'DoubleVerticalBar': "\u2225",
  'par': "\u2225",
  'parallel': "\u2225",
  'shortparallel': "\u2225",
  'spar': "\u2225",
  'DownArrow': "\u2193",
  'ShortDownArrow': "\u2193",
  'darr': "\u2193",
  'downarrow': "\u2193",
  'DownArrowBar': "\u2913",
  'DownArrowUpArrow': "\u21F5",
  'duarr': "\u21F5",
  'DownBreve': "\u0311",
  'DownLeftRightVector': "\u2950",
  'DownLeftTeeVector': "\u295E",
  'DownLeftVector': "\u21BD",
  'leftharpoondown': "\u21BD",
  'lhard': "\u21BD",
  'DownLeftVectorBar': "\u2956",
  'DownRightTeeVector': "\u295F",
  'DownRightVector': "\u21C1",
  'rhard': "\u21C1",
  'rightharpoondown': "\u21C1",
  'DownRightVectorBar': "\u2957",
  'DownTee': "\u22A4",
  'top': "\u22A4",
  'DownTeeArrow': "\u21A7",
  'mapstodown': "\u21A7",
  'Dscr': "\uD835\uDC9F",
  'Dstrok': "\u0110",
  'ENG': "\u014A",
  'ETH': "\xD0",
  'Eacute': "\xC9",
  'Ecaron': "\u011A",
  'Ecirc': "\xCA",
  'Ecy': "\u042D",
  'Edot': "\u0116",
  'Efr': "\uD835\uDD08",
  'Egrave': "\xC8",
  'Element': "\u2208",
  'in': "\u2208",
  'isin': "\u2208",
  'isinv': "\u2208",
  'Emacr': "\u0112",
  'EmptySmallSquare': "\u25FB",
  'EmptyVerySmallSquare': "\u25AB",
  'Eogon': "\u0118",
  'Eopf': "\uD835\uDD3C",
  'Epsilon': "\u0395",
  'Equal': "\u2A75",
  'EqualTilde': "\u2242",
  'eqsim': "\u2242",
  'esim': "\u2242",
  'Equilibrium': "\u21CC",
  'rightleftharpoons': "\u21CC",
  'rlhar': "\u21CC",
  'Escr': "\u2130",
  'expectation': "\u2130",
  'Esim': "\u2A73",
  'Eta': "\u0397",
  'Euml': "\xCB",
  'Exists': "\u2203",
  'exist': "\u2203",
  'ExponentialE': "\u2147",
  'ee': "\u2147",
  'exponentiale': "\u2147",
  'Fcy': "\u0424",
  'Ffr': "\uD835\uDD09",
  'FilledSmallSquare': "\u25FC",
  'FilledVerySmallSquare': "\u25AA",
  'blacksquare': "\u25AA",
  'squarf': "\u25AA",
  'squf': "\u25AA",
  'Fopf': "\uD835\uDD3D",
  'ForAll': "\u2200",
  'forall': "\u2200",
  'Fouriertrf': "\u2131",
  'Fscr': "\u2131",
  'GJcy': "\u0403",
  'GT': ">",
  'gt': ">",
  'Gamma': "\u0393",
  'Gammad': "\u03DC",
  'Gbreve': "\u011E",
  'Gcedil': "\u0122",
  'Gcirc': "\u011C",
  'Gcy': "\u0413",
  'Gdot': "\u0120",
  'Gfr': "\uD835\uDD0A",
  'Gg': "\u22D9",
  'ggg': "\u22D9",
  'Gopf': "\uD835\uDD3E",
  'GreaterEqual': "\u2265",
  'ge': "\u2265",
  'geq': "\u2265",
  'GreaterEqualLess': "\u22DB",
  'gel': "\u22DB",
  'gtreqless': "\u22DB",
  'GreaterFullEqual': "\u2267",
  'gE': "\u2267",
  'geqq': "\u2267",
  'GreaterGreater': "\u2AA2",
  'GreaterLess': "\u2277",
  'gl': "\u2277",
  'gtrless': "\u2277",
  'GreaterSlantEqual': "\u2A7E",
  'geqslant': "\u2A7E",
  'ges': "\u2A7E",
  'GreaterTilde': "\u2273",
  'gsim': "\u2273",
  'gtrsim': "\u2273",
  'Gscr': "\uD835\uDCA2",
  'Gt': "\u226B",
  'NestedGreaterGreater': "\u226B",
  'gg': "\u226B",
  'HARDcy': "\u042A",
  'Hacek': "\u02C7",
  'caron': "\u02C7",
  'Hat': "^",
  'Hcirc': "\u0124",
  'Hfr': "\u210C",
  'Poincareplane': "\u210C",
  'HilbertSpace': "\u210B",
  'Hscr': "\u210B",
  'hamilt': "\u210B",
  'Hopf': "\u210D",
  'quaternions': "\u210D",
  'HorizontalLine': "\u2500",
  'boxh': "\u2500",
  'Hstrok': "\u0126",
  'HumpEqual': "\u224F",
  'bumpe': "\u224F",
  'bumpeq': "\u224F",
  'IEcy': "\u0415",
  'IJlig': "\u0132",
  'IOcy': "\u0401",
  'Iacute': "\xCD",
  'Icirc': "\xCE",
  'Icy': "\u0418",
  'Idot': "\u0130",
  'Ifr': "\u2111",
  'Im': "\u2111",
  'image': "\u2111",
  'imagpart': "\u2111",
  'Igrave': "\xCC",
  'Imacr': "\u012A",
  'ImaginaryI': "\u2148",
  'ii': "\u2148",
  'Int': "\u222C",
  'Integral': "\u222B",
  'int': "\u222B",
  'Intersection': "\u22C2",
  'bigcap': "\u22C2",
  'xcap': "\u22C2",
  'InvisibleComma': "\u2063",
  'ic': "\u2063",
  'InvisibleTimes': "\u2062",
  'it': "\u2062",
  'Iogon': "\u012E",
  'Iopf': "\uD835\uDD40",
  'Iota': "\u0399",
  'Iscr': "\u2110",
  'imagline': "\u2110",
  'Itilde': "\u0128",
  'Iukcy': "\u0406",
  'Iuml': "\xCF",
  'Jcirc': "\u0134",
  'Jcy': "\u0419",
  'Jfr': "\uD835\uDD0D",
  'Jopf': "\uD835\uDD41",
  'Jscr': "\uD835\uDCA5",
  'Jsercy': "\u0408",
  'Jukcy': "\u0404",
  'KHcy': "\u0425",
  'KJcy': "\u040C",
  'Kappa': "\u039A",
  'Kcedil': "\u0136",
  'Kcy': "\u041A",
  'Kfr': "\uD835\uDD0E",
  'Kopf': "\uD835\uDD42",
  'Kscr': "\uD835\uDCA6",
  'LJcy': "\u0409",
  'LT': "<",
  'lt': "<",
  'Lacute': "\u0139",
  'Lambda': "\u039B",
  'Lang': "\u27EA",
  'Laplacetrf': "\u2112",
  'Lscr': "\u2112",
  'lagran': "\u2112",
  'Larr': "\u219E",
  'twoheadleftarrow': "\u219E",
  'Lcaron': "\u013D",
  'Lcedil': "\u013B",
  'Lcy': "\u041B",
  'LeftAngleBracket': "\u27E8",
  'lang': "\u27E8",
  'langle': "\u27E8",
  'LeftArrow': "\u2190",
  'ShortLeftArrow': "\u2190",
  'larr': "\u2190",
  'leftarrow': "\u2190",
  'slarr': "\u2190",
  'LeftArrowBar': "\u21E4",
  'larrb': "\u21E4",
  'LeftArrowRightArrow': "\u21C6",
  'leftrightarrows': "\u21C6",
  'lrarr': "\u21C6",
  'LeftCeiling': "\u2308",
  'lceil': "\u2308",
  'LeftDoubleBracket': "\u27E6",
  'lobrk': "\u27E6",
  'LeftDownTeeVector': "\u2961",
  'LeftDownVector': "\u21C3",
  'dharl': "\u21C3",
  'downharpoonleft': "\u21C3",
  'LeftDownVectorBar': "\u2959",
  'LeftFloor': "\u230A",
  'lfloor': "\u230A",
  'LeftRightArrow': "\u2194",
  'harr': "\u2194",
  'leftrightarrow': "\u2194",
  'LeftRightVector': "\u294E",
  'LeftTee': "\u22A3",
  'dashv': "\u22A3",
  'LeftTeeArrow': "\u21A4",
  'mapstoleft': "\u21A4",
  'LeftTeeVector': "\u295A",
  'LeftTriangle': "\u22B2",
  'vartriangleleft': "\u22B2",
  'vltri': "\u22B2",
  'LeftTriangleBar': "\u29CF",
  'LeftTriangleEqual': "\u22B4",
  'ltrie': "\u22B4",
  'trianglelefteq': "\u22B4",
  'LeftUpDownVector': "\u2951",
  'LeftUpTeeVector': "\u2960",
  'LeftUpVector': "\u21BF",
  'uharl': "\u21BF",
  'upharpoonleft': "\u21BF",
  'LeftUpVectorBar': "\u2958",
  'LeftVector': "\u21BC",
  'leftharpoonup': "\u21BC",
  'lharu': "\u21BC",
  'LeftVectorBar': "\u2952",
  'LessEqualGreater': "\u22DA",
  'leg': "\u22DA",
  'lesseqgtr': "\u22DA",
  'LessFullEqual': "\u2266",
  'lE': "\u2266",
  'leqq': "\u2266",
  'LessGreater': "\u2276",
  'lessgtr': "\u2276",
  'lg': "\u2276",
  'LessLess': "\u2AA1",
  'LessSlantEqual': "\u2A7D",
  'leqslant': "\u2A7D",
  'les': "\u2A7D",
  'LessTilde': "\u2272",
  'lesssim': "\u2272",
  'lsim': "\u2272",
  'Lfr': "\uD835\uDD0F",
  'Ll': "\u22D8",
  'Lleftarrow': "\u21DA",
  'lAarr': "\u21DA",
  'Lmidot': "\u013F",
  'LongLeftArrow': "\u27F5",
  'longleftarrow': "\u27F5",
  'xlarr': "\u27F5",
  'LongLeftRightArrow': "\u27F7",
  'longleftrightarrow': "\u27F7",
  'xharr': "\u27F7",
  'LongRightArrow': "\u27F6",
  'longrightarrow': "\u27F6",
  'xrarr': "\u27F6",
  'Lopf': "\uD835\uDD43",
  'LowerLeftArrow': "\u2199",
  'swarr': "\u2199",
  'swarrow': "\u2199",
  'LowerRightArrow': "\u2198",
  'searr': "\u2198",
  'searrow': "\u2198",
  'Lsh': "\u21B0",
  'lsh': "\u21B0",
  'Lstrok': "\u0141",
  'Lt': "\u226A",
  'NestedLessLess': "\u226A",
  'll': "\u226A",
  'Map': "\u2905",
  'Mcy': "\u041C",
  'MediumSpace': "\u205F",
  'Mellintrf': "\u2133",
  'Mscr': "\u2133",
  'phmmat': "\u2133",
  'Mfr': "\uD835\uDD10",
  'MinusPlus': "\u2213",
  'mnplus': "\u2213",
  'mp': "\u2213",
  'Mopf': "\uD835\uDD44",
  'Mu': "\u039C",
  'NJcy': "\u040A",
  'Nacute': "\u0143",
  'Ncaron': "\u0147",
  'Ncedil': "\u0145",
  'Ncy': "\u041D",
  'NegativeMediumSpace': "\u200B",
  'NegativeThickSpace': "\u200B",
  'NegativeThinSpace': "\u200B",
  'NegativeVeryThinSpace': "\u200B",
  'ZeroWidthSpace': "\u200B",
  'NewLine': "\n",
  'Nfr': "\uD835\uDD11",
  'NoBreak': "\u2060",
  'NonBreakingSpace': "\xA0",
  'nbsp': "\xA0",
  'Nopf': "\u2115",
  'naturals': "\u2115",
  'Not': "\u2AEC",
  'NotCongruent': "\u2262",
  'nequiv': "\u2262",
  'NotCupCap': "\u226D",
  'NotDoubleVerticalBar': "\u2226",
  'npar': "\u2226",
  'nparallel': "\u2226",
  'nshortparallel': "\u2226",
  'nspar': "\u2226",
  'NotElement': "\u2209",
  'notin': "\u2209",
  'notinva': "\u2209",
  'NotEqual': "\u2260",
  'ne': "\u2260",
  'NotEqualTilde': "\u2242\u0338",
  'nesim': "\u2242\u0338",
  'NotExists': "\u2204",
  'nexist': "\u2204",
  'nexists': "\u2204",
  'NotGreater': "\u226F",
  'ngt': "\u226F",
  'ngtr': "\u226F",
  'NotGreaterEqual': "\u2271",
  'nge': "\u2271",
  'ngeq': "\u2271",
  'NotGreaterFullEqual': "\u2267\u0338",
  'ngE': "\u2267\u0338",
  'ngeqq': "\u2267\u0338",
  'NotGreaterGreater': "\u226B\u0338",
  'nGtv': "\u226B\u0338",
  'NotGreaterLess': "\u2279",
  'ntgl': "\u2279",
  'NotGreaterSlantEqual': "\u2A7E\u0338",
  'ngeqslant': "\u2A7E\u0338",
  'nges': "\u2A7E\u0338",
  'NotGreaterTilde': "\u2275",
  'ngsim': "\u2275",
  'NotHumpDownHump': "\u224E\u0338",
  'nbump': "\u224E\u0338",
  'NotHumpEqual': "\u224F\u0338",
  'nbumpe': "\u224F\u0338",
  'NotLeftTriangle': "\u22EA",
  'nltri': "\u22EA",
  'ntriangleleft': "\u22EA",
  'NotLeftTriangleBar': "\u29CF\u0338",
  'NotLeftTriangleEqual': "\u22EC",
  'nltrie': "\u22EC",
  'ntrianglelefteq': "\u22EC",
  'NotLess': "\u226E",
  'nless': "\u226E",
  'nlt': "\u226E",
  'NotLessEqual': "\u2270",
  'nle': "\u2270",
  'nleq': "\u2270",
  'NotLessGreater': "\u2278",
  'ntlg': "\u2278",
  'NotLessLess': "\u226A\u0338",
  'nLtv': "\u226A\u0338",
  'NotLessSlantEqual': "\u2A7D\u0338",
  'nleqslant': "\u2A7D\u0338",
  'nles': "\u2A7D\u0338",
  'NotLessTilde': "\u2274",
  'nlsim': "\u2274",
  'NotNestedGreaterGreater': "\u2AA2\u0338",
  'NotNestedLessLess': "\u2AA1\u0338",
  'NotPrecedes': "\u2280",
  'npr': "\u2280",
  'nprec': "\u2280",
  'NotPrecedesEqual': "\u2AAF\u0338",
  'npre': "\u2AAF\u0338",
  'npreceq': "\u2AAF\u0338",
  'NotPrecedesSlantEqual': "\u22E0",
  'nprcue': "\u22E0",
  'NotReverseElement': "\u220C",
  'notni': "\u220C",
  'notniva': "\u220C",
  'NotRightTriangle': "\u22EB",
  'nrtri': "\u22EB",
  'ntriangleright': "\u22EB",
  'NotRightTriangleBar': "\u29D0\u0338",
  'NotRightTriangleEqual': "\u22ED",
  'nrtrie': "\u22ED",
  'ntrianglerighteq': "\u22ED",
  'NotSquareSubset': "\u228F\u0338",
  'NotSquareSubsetEqual': "\u22E2",
  'nsqsube': "\u22E2",
  'NotSquareSuperset': "\u2290\u0338",
  'NotSquareSupersetEqual': "\u22E3",
  'nsqsupe': "\u22E3",
  'NotSubset': "\u2282\u20D2",
  'nsubset': "\u2282\u20D2",
  'vnsub': "\u2282\u20D2",
  'NotSubsetEqual': "\u2288",
  'nsube': "\u2288",
  'nsubseteq': "\u2288",
  'NotSucceeds': "\u2281",
  'nsc': "\u2281",
  'nsucc': "\u2281",
  'NotSucceedsEqual': "\u2AB0\u0338",
  'nsce': "\u2AB0\u0338",
  'nsucceq': "\u2AB0\u0338",
  'NotSucceedsSlantEqual': "\u22E1",
  'nsccue': "\u22E1",
  'NotSucceedsTilde': "\u227F\u0338",
  'NotSuperset': "\u2283\u20D2",
  'nsupset': "\u2283\u20D2",
  'vnsup': "\u2283\u20D2",
  'NotSupersetEqual': "\u2289",
  'nsupe': "\u2289",
  'nsupseteq': "\u2289",
  'NotTilde': "\u2241",
  'nsim': "\u2241",
  'NotTildeEqual': "\u2244",
  'nsime': "\u2244",
  'nsimeq': "\u2244",
  'NotTildeFullEqual': "\u2247",
  'ncong': "\u2247",
  'NotTildeTilde': "\u2249",
  'nap': "\u2249",
  'napprox': "\u2249",
  'NotVerticalBar': "\u2224",
  'nmid': "\u2224",
  'nshortmid': "\u2224",
  'nsmid': "\u2224",
  'Nscr': "\uD835\uDCA9",
  'Ntilde': "\xD1",
  'Nu': "\u039D",
  'OElig': "\u0152",
  'Oacute': "\xD3",
  'Ocirc': "\xD4",
  'Ocy': "\u041E",
  'Odblac': "\u0150",
  'Ofr': "\uD835\uDD12",
  'Ograve': "\xD2",
  'Omacr': "\u014C",
  'Omega': "\u03A9",
  'ohm': "\u03A9",
  'Omicron': "\u039F",
  'Oopf': "\uD835\uDD46",
  'OpenCurlyDoubleQuote': "\u201C",
  'ldquo': "\u201C",
  'OpenCurlyQuote': "\u2018",
  'lsquo': "\u2018",
  'Or': "\u2A54",
  'Oscr': "\uD835\uDCAA",
  'Oslash': "\xD8",
  'Otilde': "\xD5",
  'Otimes': "\u2A37",
  'Ouml': "\xD6",
  'OverBar': "\u203E",
  'oline': "\u203E",
  'OverBrace': "\u23DE",
  'OverBracket': "\u23B4",
  'tbrk': "\u23B4",
  'OverParenthesis': "\u23DC",
  'PartialD': "\u2202",
  'part': "\u2202",
  'Pcy': "\u041F",
  'Pfr': "\uD835\uDD13",
  'Phi': "\u03A6",
  'Pi': "\u03A0",
  'PlusMinus': "\xB1",
  'plusmn': "\xB1",
  'pm': "\xB1",
  'Popf': "\u2119",
  'primes': "\u2119",
  'Pr': "\u2ABB",
  'Precedes': "\u227A",
  'pr': "\u227A",
  'prec': "\u227A",
  'PrecedesEqual': "\u2AAF",
  'pre': "\u2AAF",
  'preceq': "\u2AAF",
  'PrecedesSlantEqual': "\u227C",
  'prcue': "\u227C",
  'preccurlyeq': "\u227C",
  'PrecedesTilde': "\u227E",
  'precsim': "\u227E",
  'prsim': "\u227E",
  'Prime': "\u2033",
  'Product': "\u220F",
  'prod': "\u220F",
  'Proportional': "\u221D",
  'prop': "\u221D",
  'propto': "\u221D",
  'varpropto': "\u221D",
  'vprop': "\u221D",
  'Pscr': "\uD835\uDCAB",
  'Psi': "\u03A8",
  'QUOT': "\"",
  'quot': "\"",
  'Qfr': "\uD835\uDD14",
  'Qopf': "\u211A",
  'rationals': "\u211A",
  'Qscr': "\uD835\uDCAC",
  'RBarr': "\u2910",
  'drbkarow': "\u2910",
  'REG': "\xAE",
  'circledR': "\xAE",
  'reg': "\xAE",
  'Racute': "\u0154",
  'Rang': "\u27EB",
  'Rarr': "\u21A0",
  'twoheadrightarrow': "\u21A0",
  'Rarrtl': "\u2916",
  'Rcaron': "\u0158",
  'Rcedil': "\u0156",
  'Rcy': "\u0420",
  'Re': "\u211C",
  'Rfr': "\u211C",
  'real': "\u211C",
  'realpart': "\u211C",
  'ReverseElement': "\u220B",
  'SuchThat': "\u220B",
  'ni': "\u220B",
  'niv': "\u220B",
  'ReverseEquilibrium': "\u21CB",
  'leftrightharpoons': "\u21CB",
  'lrhar': "\u21CB",
  'ReverseUpEquilibrium': "\u296F",
  'duhar': "\u296F",
  'Rho': "\u03A1",
  'RightAngleBracket': "\u27E9",
  'rang': "\u27E9",
  'rangle': "\u27E9",
  'RightArrow': "\u2192",
  'ShortRightArrow': "\u2192",
  'rarr': "\u2192",
  'rightarrow': "\u2192",
  'srarr': "\u2192",
  'RightArrowBar': "\u21E5",
  'rarrb': "\u21E5",
  'RightArrowLeftArrow': "\u21C4",
  'rightleftarrows': "\u21C4",
  'rlarr': "\u21C4",
  'RightCeiling': "\u2309",
  'rceil': "\u2309",
  'RightDoubleBracket': "\u27E7",
  'robrk': "\u27E7",
  'RightDownTeeVector': "\u295D",
  'RightDownVector': "\u21C2",
  'dharr': "\u21C2",
  'downharpoonright': "\u21C2",
  'RightDownVectorBar': "\u2955",
  'RightFloor': "\u230B",
  'rfloor': "\u230B",
  'RightTee': "\u22A2",
  'vdash': "\u22A2",
  'RightTeeArrow': "\u21A6",
  'map': "\u21A6",
  'mapsto': "\u21A6",
  'RightTeeVector': "\u295B",
  'RightTriangle': "\u22B3",
  'vartriangleright': "\u22B3",
  'vrtri': "\u22B3",
  'RightTriangleBar': "\u29D0",
  'RightTriangleEqual': "\u22B5",
  'rtrie': "\u22B5",
  'trianglerighteq': "\u22B5",
  'RightUpDownVector': "\u294F",
  'RightUpTeeVector': "\u295C",
  'RightUpVector': "\u21BE",
  'uharr': "\u21BE",
  'upharpoonright': "\u21BE",
  'RightUpVectorBar': "\u2954",
  'RightVector': "\u21C0",
  'rharu': "\u21C0",
  'rightharpoonup': "\u21C0",
  'RightVectorBar': "\u2953",
  'Ropf': "\u211D",
  'reals': "\u211D",
  'RoundImplies': "\u2970",
  'Rrightarrow': "\u21DB",
  'rAarr': "\u21DB",
  'Rscr': "\u211B",
  'realine': "\u211B",
  'Rsh': "\u21B1",
  'rsh': "\u21B1",
  'RuleDelayed': "\u29F4",
  'SHCHcy': "\u0429",
  'SHcy': "\u0428",
  'SOFTcy': "\u042C",
  'Sacute': "\u015A",
  'Sc': "\u2ABC",
  'Scaron': "\u0160",
  'Scedil': "\u015E",
  'Scirc': "\u015C",
  'Scy': "\u0421",
  'Sfr': "\uD835\uDD16",
  'ShortUpArrow': "\u2191",
  'UpArrow': "\u2191",
  'uarr': "\u2191",
  'uparrow': "\u2191",
  'Sigma': "\u03A3",
  'SmallCircle': "\u2218",
  'compfn': "\u2218",
  'Sopf': "\uD835\uDD4A",
  'Sqrt': "\u221A",
  'radic': "\u221A",
  'Square': "\u25A1",
  'squ': "\u25A1",
  'square': "\u25A1",
  'SquareIntersection': "\u2293",
  'sqcap': "\u2293",
  'SquareSubset': "\u228F",
  'sqsub': "\u228F",
  'sqsubset': "\u228F",
  'SquareSubsetEqual': "\u2291",
  'sqsube': "\u2291",
  'sqsubseteq': "\u2291",
  'SquareSuperset': "\u2290",
  'sqsup': "\u2290",
  'sqsupset': "\u2290",
  'SquareSupersetEqual': "\u2292",
  'sqsupe': "\u2292",
  'sqsupseteq': "\u2292",
  'SquareUnion': "\u2294",
  'sqcup': "\u2294",
  'Sscr': "\uD835\uDCAE",
  'Star': "\u22C6",
  'sstarf': "\u22C6",
  'Sub': "\u22D0",
  'Subset': "\u22D0",
  'SubsetEqual': "\u2286",
  'sube': "\u2286",
  'subseteq': "\u2286",
  'Succeeds': "\u227B",
  'sc': "\u227B",
  'succ': "\u227B",
  'SucceedsEqual': "\u2AB0",
  'sce': "\u2AB0",
  'succeq': "\u2AB0",
  'SucceedsSlantEqual': "\u227D",
  'sccue': "\u227D",
  'succcurlyeq': "\u227D",
  'SucceedsTilde': "\u227F",
  'scsim': "\u227F",
  'succsim': "\u227F",
  'Sum': "\u2211",
  'sum': "\u2211",
  'Sup': "\u22D1",
  'Supset': "\u22D1",
  'Superset': "\u2283",
  'sup': "\u2283",
  'supset': "\u2283",
  'SupersetEqual': "\u2287",
  'supe': "\u2287",
  'supseteq': "\u2287",
  'THORN': "\xDE",
  'TRADE': "\u2122",
  'trade': "\u2122",
  'TSHcy': "\u040B",
  'TScy': "\u0426",
  'Tab': "\t",
  'Tau': "\u03A4",
  'Tcaron': "\u0164",
  'Tcedil': "\u0162",
  'Tcy': "\u0422",
  'Tfr': "\uD835\uDD17",
  'Therefore': "\u2234",
  'there4': "\u2234",
  'therefore': "\u2234",
  'Theta': "\u0398",
  'ThickSpace': "\u205F\u200A",
  'ThinSpace': "\u2009",
  'thinsp': "\u2009",
  'Tilde': "\u223C",
  'sim': "\u223C",
  'thicksim': "\u223C",
  'thksim': "\u223C",
  'TildeEqual': "\u2243",
  'sime': "\u2243",
  'simeq': "\u2243",
  'TildeFullEqual': "\u2245",
  'cong': "\u2245",
  'TildeTilde': "\u2248",
  'ap': "\u2248",
  'approx': "\u2248",
  'asymp': "\u2248",
  'thickapprox': "\u2248",
  'thkap': "\u2248",
  'Topf': "\uD835\uDD4B",
  'TripleDot': "\u20DB",
  'tdot': "\u20DB",
  'Tscr': "\uD835\uDCAF",
  'Tstrok': "\u0166",
  'Uacute': "\xDA",
  'Uarr': "\u219F",
  'Uarrocir': "\u2949",
  'Ubrcy': "\u040E",
  'Ubreve': "\u016C",
  'Ucirc': "\xDB",
  'Ucy': "\u0423",
  'Udblac': "\u0170",
  'Ufr': "\uD835\uDD18",
  'Ugrave': "\xD9",
  'Umacr': "\u016A",
  'UnderBar': "_",
  'lowbar': "_",
  'UnderBrace': "\u23DF",
  'UnderBracket': "\u23B5",
  'bbrk': "\u23B5",
  'UnderParenthesis': "\u23DD",
  'Union': "\u22C3",
  'bigcup': "\u22C3",
  'xcup': "\u22C3",
  'UnionPlus': "\u228E",
  'uplus': "\u228E",
  'Uogon': "\u0172",
  'Uopf': "\uD835\uDD4C",
  'UpArrowBar': "\u2912",
  'UpArrowDownArrow': "\u21C5",
  'udarr': "\u21C5",
  'UpDownArrow': "\u2195",
  'updownarrow': "\u2195",
  'varr': "\u2195",
  'UpEquilibrium': "\u296E",
  'udhar': "\u296E",
  'UpTee': "\u22A5",
  'bot': "\u22A5",
  'bottom': "\u22A5",
  'perp': "\u22A5",
  'UpTeeArrow': "\u21A5",
  'mapstoup': "\u21A5",
  'UpperLeftArrow': "\u2196",
  'nwarr': "\u2196",
  'nwarrow': "\u2196",
  'UpperRightArrow': "\u2197",
  'nearr': "\u2197",
  'nearrow': "\u2197",
  'Upsi': "\u03D2",
  'upsih': "\u03D2",
  'Upsilon': "\u03A5",
  'Uring': "\u016E",
  'Uscr': "\uD835\uDCB0",
  'Utilde': "\u0168",
  'Uuml': "\xDC",
  'VDash': "\u22AB",
  'Vbar': "\u2AEB",
  'Vcy': "\u0412",
  'Vdash': "\u22A9",
  'Vdashl': "\u2AE6",
  'Vee': "\u22C1",
  'bigvee': "\u22C1",
  'xvee': "\u22C1",
  'Verbar': "\u2016",
  'Vert': "\u2016",
  'VerticalBar': "\u2223",
  'mid': "\u2223",
  'shortmid': "\u2223",
  'smid': "\u2223",
  'VerticalLine': "|",
  'verbar': "|",
  'vert': "|",
  'VerticalSeparator': "\u2758",
  'VerticalTilde': "\u2240",
  'wr': "\u2240",
  'wreath': "\u2240",
  'VeryThinSpace': "\u200A",
  'hairsp': "\u200A",
  'Vfr': "\uD835\uDD19",
  'Vopf': "\uD835\uDD4D",
  'Vscr': "\uD835\uDCB1",
  'Vvdash': "\u22AA",
  'Wcirc': "\u0174",
  'Wedge': "\u22C0",
  'bigwedge': "\u22C0",
  'xwedge': "\u22C0",
  'Wfr': "\uD835\uDD1A",
  'Wopf': "\uD835\uDD4E",
  'Wscr': "\uD835\uDCB2",
  'Xfr': "\uD835\uDD1B",
  'Xi': "\u039E",
  'Xopf': "\uD835\uDD4F",
  'Xscr': "\uD835\uDCB3",
  'YAcy': "\u042F",
  'YIcy': "\u0407",
  'YUcy': "\u042E",
  'Yacute': "\xDD",
  'Ycirc': "\u0176",
  'Ycy': "\u042B",
  'Yfr': "\uD835\uDD1C",
  'Yopf': "\uD835\uDD50",
  'Yscr': "\uD835\uDCB4",
  'Yuml': "\u0178",
  'ZHcy': "\u0416",
  'Zacute': "\u0179",
  'Zcaron': "\u017D",
  'Zcy': "\u0417",
  'Zdot': "\u017B",
  'Zeta': "\u0396",
  'Zfr': "\u2128",
  'zeetrf': "\u2128",
  'Zopf': "\u2124",
  'integers': "\u2124",
  'Zscr': "\uD835\uDCB5",
  'aacute': "\xE1",
  'abreve': "\u0103",
  'ac': "\u223E",
  'mstpos': "\u223E",
  'acE': "\u223E\u0333",
  'acd': "\u223F",
  'acirc': "\xE2",
  'acy': "\u0430",
  'aelig': "\xE6",
  'afr': "\uD835\uDD1E",
  'agrave': "\xE0",
  'alefsym': "\u2135",
  'aleph': "\u2135",
  'alpha': "\u03B1",
  'amacr': "\u0101",
  'amalg': "\u2A3F",
  'and': "\u2227",
  'wedge': "\u2227",
  'andand': "\u2A55",
  'andd': "\u2A5C",
  'andslope': "\u2A58",
  'andv': "\u2A5A",
  'ang': "\u2220",
  'angle': "\u2220",
  'ange': "\u29A4",
  'angmsd': "\u2221",
  'measuredangle': "\u2221",
  'angmsdaa': "\u29A8",
  'angmsdab': "\u29A9",
  'angmsdac': "\u29AA",
  'angmsdad': "\u29AB",
  'angmsdae': "\u29AC",
  'angmsdaf': "\u29AD",
  'angmsdag': "\u29AE",
  'angmsdah': "\u29AF",
  'angrt': "\u221F",
  'angrtvb': "\u22BE",
  'angrtvbd': "\u299D",
  'angsph': "\u2222",
  'angzarr': "\u237C",
  'aogon': "\u0105",
  'aopf': "\uD835\uDD52",
  'apE': "\u2A70",
  'apacir': "\u2A6F",
  'ape': "\u224A",
  'approxeq': "\u224A",
  'apid': "\u224B",
  'apos': "'",
  'aring': "\xE5",
  'ascr': "\uD835\uDCB6",
  'ast': "*",
  'midast': "*",
  'atilde': "\xE3",
  'auml': "\xE4",
  'awint': "\u2A11",
  'bNot': "\u2AED",
  'backcong': "\u224C",
  'bcong': "\u224C",
  'backepsilon': "\u03F6",
  'bepsi': "\u03F6",
  'backprime': "\u2035",
  'bprime': "\u2035",
  'backsim': "\u223D",
  'bsim': "\u223D",
  'backsimeq': "\u22CD",
  'bsime': "\u22CD",
  'barvee': "\u22BD",
  'barwed': "\u2305",
  'barwedge': "\u2305",
  'bbrktbrk': "\u23B6",
  'bcy': "\u0431",
  'bdquo': "\u201E",
  'ldquor': "\u201E",
  'bemptyv': "\u29B0",
  'beta': "\u03B2",
  'beth': "\u2136",
  'between': "\u226C",
  'twixt': "\u226C",
  'bfr': "\uD835\uDD1F",
  'bigcirc': "\u25EF",
  'xcirc': "\u25EF",
  'bigodot': "\u2A00",
  'xodot': "\u2A00",
  'bigoplus': "\u2A01",
  'xoplus': "\u2A01",
  'bigotimes': "\u2A02",
  'xotime': "\u2A02",
  'bigsqcup': "\u2A06",
  'xsqcup': "\u2A06",
  'bigstar': "\u2605",
  'starf': "\u2605",
  'bigtriangledown': "\u25BD",
  'xdtri': "\u25BD",
  'bigtriangleup': "\u25B3",
  'xutri': "\u25B3",
  'biguplus': "\u2A04",
  'xuplus': "\u2A04",
  'bkarow': "\u290D",
  'rbarr': "\u290D",
  'blacklozenge': "\u29EB",
  'lozf': "\u29EB",
  'blacktriangle': "\u25B4",
  'utrif': "\u25B4",
  'blacktriangledown': "\u25BE",
  'dtrif': "\u25BE",
  'blacktriangleleft': "\u25C2",
  'ltrif': "\u25C2",
  'blacktriangleright': "\u25B8",
  'rtrif': "\u25B8",
  'blank': "\u2423",
  'blk12': "\u2592",
  'blk14': "\u2591",
  'blk34': "\u2593",
  'block': "\u2588",
  'bne': "=\u20E5",
  'bnequiv': "\u2261\u20E5",
  'bnot': "\u2310",
  'bopf': "\uD835\uDD53",
  'bowtie': "\u22C8",
  'boxDL': "\u2557",
  'boxDR': "\u2554",
  'boxDl': "\u2556",
  'boxDr': "\u2553",
  'boxH': "\u2550",
  'boxHD': "\u2566",
  'boxHU': "\u2569",
  'boxHd': "\u2564",
  'boxHu': "\u2567",
  'boxUL': "\u255D",
  'boxUR': "\u255A",
  'boxUl': "\u255C",
  'boxUr': "\u2559",
  'boxV': "\u2551",
  'boxVH': "\u256C",
  'boxVL': "\u2563",
  'boxVR': "\u2560",
  'boxVh': "\u256B",
  'boxVl': "\u2562",
  'boxVr': "\u255F",
  'boxbox': "\u29C9",
  'boxdL': "\u2555",
  'boxdR': "\u2552",
  'boxdl': "\u2510",
  'boxdr': "\u250C",
  'boxhD': "\u2565",
  'boxhU': "\u2568",
  'boxhd': "\u252C",
  'boxhu': "\u2534",
  'boxminus': "\u229F",
  'minusb': "\u229F",
  'boxplus': "\u229E",
  'plusb': "\u229E",
  'boxtimes': "\u22A0",
  'timesb': "\u22A0",
  'boxuL': "\u255B",
  'boxuR': "\u2558",
  'boxul': "\u2518",
  'boxur': "\u2514",
  'boxv': "\u2502",
  'boxvH': "\u256A",
  'boxvL': "\u2561",
  'boxvR': "\u255E",
  'boxvh': "\u253C",
  'boxvl': "\u2524",
  'boxvr': "\u251C",
  'brvbar': "\xA6",
  'bscr': "\uD835\uDCB7",
  'bsemi': "\u204F",
  'bsol': "\\",
  'bsolb': "\u29C5",
  'bsolhsub': "\u27C8",
  'bull': "\u2022",
  'bullet': "\u2022",
  'bumpE': "\u2AAE",
  'cacute': "\u0107",
  'cap': "\u2229",
  'capand': "\u2A44",
  'capbrcup': "\u2A49",
  'capcap': "\u2A4B",
  'capcup': "\u2A47",
  'capdot': "\u2A40",
  'caps': "\u2229\uFE00",
  'caret': "\u2041",
  'ccaps': "\u2A4D",
  'ccaron': "\u010D",
  'ccedil': "\xE7",
  'ccirc': "\u0109",
  'ccups': "\u2A4C",
  'ccupssm': "\u2A50",
  'cdot': "\u010B",
  'cemptyv': "\u29B2",
  'cent': "\xA2",
  'cfr': "\uD835\uDD20",
  'chcy': "\u0447",
  'check': "\u2713",
  'checkmark': "\u2713",
  'chi': "\u03C7",
  'cir': "\u25CB",
  'cirE': "\u29C3",
  'circ': "\u02C6",
  'circeq': "\u2257",
  'cire': "\u2257",
  'circlearrowleft': "\u21BA",
  'olarr': "\u21BA",
  'circlearrowright': "\u21BB",
  'orarr': "\u21BB",
  'circledS': "\u24C8",
  'oS': "\u24C8",
  'circledast': "\u229B",
  'oast': "\u229B",
  'circledcirc': "\u229A",
  'ocir': "\u229A",
  'circleddash': "\u229D",
  'odash': "\u229D",
  'cirfnint': "\u2A10",
  'cirmid': "\u2AEF",
  'cirscir': "\u29C2",
  'clubs': "\u2663",
  'clubsuit': "\u2663",
  'colon': ":",
  'comma': ",",
  'commat': "@",
  'comp': "\u2201",
  'complement': "\u2201",
  'congdot': "\u2A6D",
  'copf': "\uD835\uDD54",
  'copysr': "\u2117",
  'crarr': "\u21B5",
  'cross': "\u2717",
  'cscr': "\uD835\uDCB8",
  'csub': "\u2ACF",
  'csube': "\u2AD1",
  'csup': "\u2AD0",
  'csupe': "\u2AD2",
  'ctdot': "\u22EF",
  'cudarrl': "\u2938",
  'cudarrr': "\u2935",
  'cuepr': "\u22DE",
  'curlyeqprec': "\u22DE",
  'cuesc': "\u22DF",
  'curlyeqsucc': "\u22DF",
  'cularr': "\u21B6",
  'curvearrowleft': "\u21B6",
  'cularrp': "\u293D",
  'cup': "\u222A",
  'cupbrcap': "\u2A48",
  'cupcap': "\u2A46",
  'cupcup': "\u2A4A",
  'cupdot': "\u228D",
  'cupor': "\u2A45",
  'cups': "\u222A\uFE00",
  'curarr': "\u21B7",
  'curvearrowright': "\u21B7",
  'curarrm': "\u293C",
  'curlyvee': "\u22CE",
  'cuvee': "\u22CE",
  'curlywedge': "\u22CF",
  'cuwed': "\u22CF",
  'curren': "\xA4",
  'cwint': "\u2231",
  'cylcty': "\u232D",
  'dHar': "\u2965",
  'dagger': "\u2020",
  'daleth': "\u2138",
  'dash': "\u2010",
  'hyphen': "\u2010",
  'dbkarow': "\u290F",
  'rBarr': "\u290F",
  'dcaron': "\u010F",
  'dcy': "\u0434",
  'ddarr': "\u21CA",
  'downdownarrows': "\u21CA",
  'ddotseq': "\u2A77",
  'eDDot': "\u2A77",
  'deg': "\xB0",
  'delta': "\u03B4",
  'demptyv': "\u29B1",
  'dfisht': "\u297F",
  'dfr': "\uD835\uDD21",
  'diamondsuit': "\u2666",
  'diams': "\u2666",
  'digamma': "\u03DD",
  'gammad': "\u03DD",
  'disin': "\u22F2",
  'div': "\xF7",
  'divide': "\xF7",
  'divideontimes': "\u22C7",
  'divonx': "\u22C7",
  'djcy': "\u0452",
  'dlcorn': "\u231E",
  'llcorner': "\u231E",
  'dlcrop': "\u230D",
  'dollar': "$",
  'dopf': "\uD835\uDD55",
  'doteqdot': "\u2251",
  'eDot': "\u2251",
  'dotminus': "\u2238",
  'minusd': "\u2238",
  'dotplus': "\u2214",
  'plusdo': "\u2214",
  'dotsquare': "\u22A1",
  'sdotb': "\u22A1",
  'drcorn': "\u231F",
  'lrcorner': "\u231F",
  'drcrop': "\u230C",
  'dscr': "\uD835\uDCB9",
  'dscy': "\u0455",
  'dsol': "\u29F6",
  'dstrok': "\u0111",
  'dtdot': "\u22F1",
  'dtri': "\u25BF",
  'triangledown': "\u25BF",
  'dwangle': "\u29A6",
  'dzcy': "\u045F",
  'dzigrarr': "\u27FF",
  'eacute': "\xE9",
  'easter': "\u2A6E",
  'ecaron': "\u011B",
  'ecir': "\u2256",
  'eqcirc': "\u2256",
  'ecirc': "\xEA",
  'ecolon': "\u2255",
  'eqcolon': "\u2255",
  'ecy': "\u044D",
  'edot': "\u0117",
  'efDot': "\u2252",
  'fallingdotseq': "\u2252",
  'efr': "\uD835\uDD22",
  'eg': "\u2A9A",
  'egrave': "\xE8",
  'egs': "\u2A96",
  'eqslantgtr': "\u2A96",
  'egsdot': "\u2A98",
  'el': "\u2A99",
  'elinters': "\u23E7",
  'ell': "\u2113",
  'els': "\u2A95",
  'eqslantless': "\u2A95",
  'elsdot': "\u2A97",
  'emacr': "\u0113",
  'empty': "\u2205",
  'emptyset': "\u2205",
  'emptyv': "\u2205",
  'varnothing': "\u2205",
  'emsp13': "\u2004",
  'emsp14': "\u2005",
  'emsp': "\u2003",
  'eng': "\u014B",
  'ensp': "\u2002",
  'eogon': "\u0119",
  'eopf': "\uD835\uDD56",
  'epar': "\u22D5",
  'eparsl': "\u29E3",
  'eplus': "\u2A71",
  'epsi': "\u03B5",
  'epsilon': "\u03B5",
  'epsiv': "\u03F5",
  'straightepsilon': "\u03F5",
  'varepsilon': "\u03F5",
  'equals': "=",
  'equest': "\u225F",
  'questeq': "\u225F",
  'equivDD': "\u2A78",
  'eqvparsl': "\u29E5",
  'erDot': "\u2253",
  'risingdotseq': "\u2253",
  'erarr': "\u2971",
  'escr': "\u212F",
  'eta': "\u03B7",
  'eth': "\xF0",
  'euml': "\xEB",
  'euro': "\u20AC",
  'excl': "!",
  'fcy': "\u0444",
  'female': "\u2640",
  'ffilig': "\uFB03",
  'fflig': "\uFB00",
  'ffllig': "\uFB04",
  'ffr': "\uD835\uDD23",
  'filig': "\uFB01",
  'fjlig': "fj",
  'flat': "\u266D",
  'fllig': "\uFB02",
  'fltns': "\u25B1",
  'fnof': "\u0192",
  'fopf': "\uD835\uDD57",
  'fork': "\u22D4",
  'pitchfork': "\u22D4",
  'forkv': "\u2AD9",
  'fpartint': "\u2A0D",
  'frac12': "\xBD",
  'half': "\xBD",
  'frac13': "\u2153",
  'frac14': "\xBC",
  'frac15': "\u2155",
  'frac16': "\u2159",
  'frac18': "\u215B",
  'frac23': "\u2154",
  'frac25': "\u2156",
  'frac34': "\xBE",
  'frac35': "\u2157",
  'frac38': "\u215C",
  'frac45': "\u2158",
  'frac56': "\u215A",
  'frac58': "\u215D",
  'frac78': "\u215E",
  'frasl': "\u2044",
  'frown': "\u2322",
  'sfrown': "\u2322",
  'fscr': "\uD835\uDCBB",
  'gEl': "\u2A8C",
  'gtreqqless': "\u2A8C",
  'gacute': "\u01F5",
  'gamma': "\u03B3",
  'gap': "\u2A86",
  'gtrapprox': "\u2A86",
  'gbreve': "\u011F",
  'gcirc': "\u011D",
  'gcy': "\u0433",
  'gdot': "\u0121",
  'gescc': "\u2AA9",
  'gesdot': "\u2A80",
  'gesdoto': "\u2A82",
  'gesdotol': "\u2A84",
  'gesl': "\u22DB\uFE00",
  'gesles': "\u2A94",
  'gfr': "\uD835\uDD24",
  'gimel': "\u2137",
  'gjcy': "\u0453",
  'glE': "\u2A92",
  'gla': "\u2AA5",
  'glj': "\u2AA4",
  'gnE': "\u2269",
  'gneqq': "\u2269",
  'gnap': "\u2A8A",
  'gnapprox': "\u2A8A",
  'gne': "\u2A88",
  'gneq': "\u2A88",
  'gnsim': "\u22E7",
  'gopf': "\uD835\uDD58",
  'gscr': "\u210A",
  'gsime': "\u2A8E",
  'gsiml': "\u2A90",
  'gtcc': "\u2AA7",
  'gtcir': "\u2A7A",
  'gtdot': "\u22D7",
  'gtrdot': "\u22D7",
  'gtlPar': "\u2995",
  'gtquest': "\u2A7C",
  'gtrarr': "\u2978",
  'gvertneqq': "\u2269\uFE00",
  'gvnE': "\u2269\uFE00",
  'hardcy': "\u044A",
  'harrcir': "\u2948",
  'harrw': "\u21AD",
  'leftrightsquigarrow': "\u21AD",
  'hbar': "\u210F",
  'hslash': "\u210F",
  'planck': "\u210F",
  'plankv': "\u210F",
  'hcirc': "\u0125",
  'hearts': "\u2665",
  'heartsuit': "\u2665",
  'hellip': "\u2026",
  'mldr': "\u2026",
  'hercon': "\u22B9",
  'hfr': "\uD835\uDD25",
  'hksearow': "\u2925",
  'searhk': "\u2925",
  'hkswarow': "\u2926",
  'swarhk': "\u2926",
  'hoarr': "\u21FF",
  'homtht': "\u223B",
  'hookleftarrow': "\u21A9",
  'larrhk': "\u21A9",
  'hookrightarrow': "\u21AA",
  'rarrhk': "\u21AA",
  'hopf': "\uD835\uDD59",
  'horbar': "\u2015",
  'hscr': "\uD835\uDCBD",
  'hstrok': "\u0127",
  'hybull': "\u2043",
  'iacute': "\xED",
  'icirc': "\xEE",
  'icy': "\u0438",
  'iecy': "\u0435",
  'iexcl': "\xA1",
  'ifr': "\uD835\uDD26",
  'igrave': "\xEC",
  'iiiint': "\u2A0C",
  'qint': "\u2A0C",
  'iiint': "\u222D",
  'tint': "\u222D",
  'iinfin': "\u29DC",
  'iiota': "\u2129",
  'ijlig': "\u0133",
  'imacr': "\u012B",
  'imath': "\u0131",
  'inodot': "\u0131",
  'imof': "\u22B7",
  'imped': "\u01B5",
  'incare': "\u2105",
  'infin': "\u221E",
  'infintie': "\u29DD",
  'intcal': "\u22BA",
  'intercal': "\u22BA",
  'intlarhk': "\u2A17",
  'intprod': "\u2A3C",
  'iprod': "\u2A3C",
  'iocy': "\u0451",
  'iogon': "\u012F",
  'iopf': "\uD835\uDD5A",
  'iota': "\u03B9",
  'iquest': "\xBF",
  'iscr': "\uD835\uDCBE",
  'isinE': "\u22F9",
  'isindot': "\u22F5",
  'isins': "\u22F4",
  'isinsv': "\u22F3",
  'itilde': "\u0129",
  'iukcy': "\u0456",
  'iuml': "\xEF",
  'jcirc': "\u0135",
  'jcy': "\u0439",
  'jfr': "\uD835\uDD27",
  'jmath': "\u0237",
  'jopf': "\uD835\uDD5B",
  'jscr': "\uD835\uDCBF",
  'jsercy': "\u0458",
  'jukcy': "\u0454",
  'kappa': "\u03BA",
  'kappav': "\u03F0",
  'varkappa': "\u03F0",
  'kcedil': "\u0137",
  'kcy': "\u043A",
  'kfr': "\uD835\uDD28",
  'kgreen': "\u0138",
  'khcy': "\u0445",
  'kjcy': "\u045C",
  'kopf': "\uD835\uDD5C",
  'kscr': "\uD835\uDCC0",
  'lAtail': "\u291B",
  'lBarr': "\u290E",
  'lEg': "\u2A8B",
  'lesseqqgtr': "\u2A8B",
  'lHar': "\u2962",
  'lacute': "\u013A",
  'laemptyv': "\u29B4",
  'lambda': "\u03BB",
  'langd': "\u2991",
  'lap': "\u2A85",
  'lessapprox': "\u2A85",
  'laquo': "\xAB",
  'larrbfs': "\u291F",
  'larrfs': "\u291D",
  'larrlp': "\u21AB",
  'looparrowleft': "\u21AB",
  'larrpl': "\u2939",
  'larrsim': "\u2973",
  'larrtl': "\u21A2",
  'leftarrowtail': "\u21A2",
  'lat': "\u2AAB",
  'latail': "\u2919",
  'late': "\u2AAD",
  'lates': "\u2AAD\uFE00",
  'lbarr': "\u290C",
  'lbbrk': "\u2772",
  'lbrace': "{",
  'lcub': "{",
  'lbrack': "[",
  'lsqb': "[",
  'lbrke': "\u298B",
  'lbrksld': "\u298F",
  'lbrkslu': "\u298D",
  'lcaron': "\u013E",
  'lcedil': "\u013C",
  'lcy': "\u043B",
  'ldca': "\u2936",
  'ldrdhar': "\u2967",
  'ldrushar': "\u294B",
  'ldsh': "\u21B2",
  'le': "\u2264",
  'leq': "\u2264",
  'leftleftarrows': "\u21C7",
  'llarr': "\u21C7",
  'leftthreetimes': "\u22CB",
  'lthree': "\u22CB",
  'lescc': "\u2AA8",
  'lesdot': "\u2A7F",
  'lesdoto': "\u2A81",
  'lesdotor': "\u2A83",
  'lesg': "\u22DA\uFE00",
  'lesges': "\u2A93",
  'lessdot': "\u22D6",
  'ltdot': "\u22D6",
  'lfisht': "\u297C",
  'lfr': "\uD835\uDD29",
  'lgE': "\u2A91",
  'lharul': "\u296A",
  'lhblk': "\u2584",
  'ljcy': "\u0459",
  'llhard': "\u296B",
  'lltri': "\u25FA",
  'lmidot': "\u0140",
  'lmoust': "\u23B0",
  'lmoustache': "\u23B0",
  'lnE': "\u2268",
  'lneqq': "\u2268",
  'lnap': "\u2A89",
  'lnapprox': "\u2A89",
  'lne': "\u2A87",
  'lneq': "\u2A87",
  'lnsim': "\u22E6",
  'loang': "\u27EC",
  'loarr': "\u21FD",
  'longmapsto': "\u27FC",
  'xmap': "\u27FC",
  'looparrowright': "\u21AC",
  'rarrlp': "\u21AC",
  'lopar': "\u2985",
  'lopf': "\uD835\uDD5D",
  'loplus': "\u2A2D",
  'lotimes': "\u2A34",
  'lowast': "\u2217",
  'loz': "\u25CA",
  'lozenge': "\u25CA",
  'lpar': "(",
  'lparlt': "\u2993",
  'lrhard': "\u296D",
  'lrm': "\u200E",
  'lrtri': "\u22BF",
  'lsaquo': "\u2039",
  'lscr': "\uD835\uDCC1",
  'lsime': "\u2A8D",
  'lsimg': "\u2A8F",
  'lsquor': "\u201A",
  'sbquo': "\u201A",
  'lstrok': "\u0142",
  'ltcc': "\u2AA6",
  'ltcir': "\u2A79",
  'ltimes': "\u22C9",
  'ltlarr': "\u2976",
  'ltquest': "\u2A7B",
  'ltrPar': "\u2996",
  'ltri': "\u25C3",
  'triangleleft': "\u25C3",
  'lurdshar': "\u294A",
  'luruhar': "\u2966",
  'lvertneqq': "\u2268\uFE00",
  'lvnE': "\u2268\uFE00",
  'mDDot': "\u223A",
  'macr': "\xAF",
  'strns': "\xAF",
  'male': "\u2642",
  'malt': "\u2720",
  'maltese': "\u2720",
  'marker': "\u25AE",
  'mcomma': "\u2A29",
  'mcy': "\u043C",
  'mdash': "\u2014",
  'mfr': "\uD835\uDD2A",
  'mho': "\u2127",
  'micro': "\xB5",
  'midcir': "\u2AF0",
  'minus': "\u2212",
  'minusdu': "\u2A2A",
  'mlcp': "\u2ADB",
  'models': "\u22A7",
  'mopf': "\uD835\uDD5E",
  'mscr': "\uD835\uDCC2",
  'mu': "\u03BC",
  'multimap': "\u22B8",
  'mumap': "\u22B8",
  'nGg': "\u22D9\u0338",
  'nGt': "\u226B\u20D2",
  'nLeftarrow': "\u21CD",
  'nlArr': "\u21CD",
  'nLeftrightarrow': "\u21CE",
  'nhArr': "\u21CE",
  'nLl': "\u22D8\u0338",
  'nLt': "\u226A\u20D2",
  'nRightarrow': "\u21CF",
  'nrArr': "\u21CF",
  'nVDash': "\u22AF",
  'nVdash': "\u22AE",
  'nacute': "\u0144",
  'nang': "\u2220\u20D2",
  'napE': "\u2A70\u0338",
  'napid': "\u224B\u0338",
  'napos': "\u0149",
  'natur': "\u266E",
  'natural': "\u266E",
  'ncap': "\u2A43",
  'ncaron': "\u0148",
  'ncedil': "\u0146",
  'ncongdot': "\u2A6D\u0338",
  'ncup': "\u2A42",
  'ncy': "\u043D",
  'ndash': "\u2013",
  'neArr': "\u21D7",
  'nearhk': "\u2924",
  'nedot': "\u2250\u0338",
  'nesear': "\u2928",
  'toea': "\u2928",
  'nfr': "\uD835\uDD2B",
  'nharr': "\u21AE",
  'nleftrightarrow': "\u21AE",
  'nhpar': "\u2AF2",
  'nis': "\u22FC",
  'nisd': "\u22FA",
  'njcy': "\u045A",
  'nlE': "\u2266\u0338",
  'nleqq': "\u2266\u0338",
  'nlarr': "\u219A",
  'nleftarrow': "\u219A",
  'nldr': "\u2025",
  'nopf': "\uD835\uDD5F",
  'not': "\xAC",
  'notinE': "\u22F9\u0338",
  'notindot': "\u22F5\u0338",
  'notinvb': "\u22F7",
  'notinvc': "\u22F6",
  'notnivb': "\u22FE",
  'notnivc': "\u22FD",
  'nparsl': "\u2AFD\u20E5",
  'npart': "\u2202\u0338",
  'npolint': "\u2A14",
  'nrarr': "\u219B",
  'nrightarrow': "\u219B",
  'nrarrc': "\u2933\u0338",
  'nrarrw': "\u219D\u0338",
  'nscr': "\uD835\uDCC3",
  'nsub': "\u2284",
  'nsubE': "\u2AC5\u0338",
  'nsubseteqq': "\u2AC5\u0338",
  'nsup': "\u2285",
  'nsupE': "\u2AC6\u0338",
  'nsupseteqq': "\u2AC6\u0338",
  'ntilde': "\xF1",
  'nu': "\u03BD",
  'num': "#",
  'numero': "\u2116",
  'numsp': "\u2007",
  'nvDash': "\u22AD",
  'nvHarr': "\u2904",
  'nvap': "\u224D\u20D2",
  'nvdash': "\u22AC",
  'nvge': "\u2265\u20D2",
  'nvgt': ">\u20D2",
  'nvinfin': "\u29DE",
  'nvlArr': "\u2902",
  'nvle': "\u2264\u20D2",
  'nvlt': "<\u20D2",
  'nvltrie': "\u22B4\u20D2",
  'nvrArr': "\u2903",
  'nvrtrie': "\u22B5\u20D2",
  'nvsim': "\u223C\u20D2",
  'nwArr': "\u21D6",
  'nwarhk': "\u2923",
  'nwnear': "\u2927",
  'oacute': "\xF3",
  'ocirc': "\xF4",
  'ocy': "\u043E",
  'odblac': "\u0151",
  'odiv': "\u2A38",
  'odsold': "\u29BC",
  'oelig': "\u0153",
  'ofcir': "\u29BF",
  'ofr': "\uD835\uDD2C",
  'ogon': "\u02DB",
  'ograve': "\xF2",
  'ogt': "\u29C1",
  'ohbar': "\u29B5",
  'olcir': "\u29BE",
  'olcross': "\u29BB",
  'olt': "\u29C0",
  'omacr': "\u014D",
  'omega': "\u03C9",
  'omicron': "\u03BF",
  'omid': "\u29B6",
  'oopf': "\uD835\uDD60",
  'opar': "\u29B7",
  'operp': "\u29B9",
  'or': "\u2228",
  'vee': "\u2228",
  'ord': "\u2A5D",
  'order': "\u2134",
  'orderof': "\u2134",
  'oscr': "\u2134",
  'ordf': "\xAA",
  'ordm': "\xBA",
  'origof': "\u22B6",
  'oror': "\u2A56",
  'orslope': "\u2A57",
  'orv': "\u2A5B",
  'oslash': "\xF8",
  'osol': "\u2298",
  'otilde': "\xF5",
  'otimesas': "\u2A36",
  'ouml': "\xF6",
  'ovbar': "\u233D",
  'para': "\xB6",
  'parsim': "\u2AF3",
  'parsl': "\u2AFD",
  'pcy': "\u043F",
  'percnt': "%",
  'period': ".",
  'permil': "\u2030",
  'pertenk': "\u2031",
  'pfr': "\uD835\uDD2D",
  'phi': "\u03C6",
  'phiv': "\u03D5",
  'straightphi': "\u03D5",
  'varphi': "\u03D5",
  'phone': "\u260E",
  'pi': "\u03C0",
  'piv': "\u03D6",
  'varpi': "\u03D6",
  'planckh': "\u210E",
  'plus': "+",
  'plusacir': "\u2A23",
  'pluscir': "\u2A22",
  'plusdu': "\u2A25",
  'pluse': "\u2A72",
  'plussim': "\u2A26",
  'plustwo': "\u2A27",
  'pointint': "\u2A15",
  'popf': "\uD835\uDD61",
  'pound': "\xA3",
  'prE': "\u2AB3",
  'prap': "\u2AB7",
  'precapprox': "\u2AB7",
  'precnapprox': "\u2AB9",
  'prnap': "\u2AB9",
  'precneqq': "\u2AB5",
  'prnE': "\u2AB5",
  'precnsim': "\u22E8",
  'prnsim': "\u22E8",
  'prime': "\u2032",
  'profalar': "\u232E",
  'profline': "\u2312",
  'profsurf': "\u2313",
  'prurel': "\u22B0",
  'pscr': "\uD835\uDCC5",
  'psi': "\u03C8",
  'puncsp': "\u2008",
  'qfr': "\uD835\uDD2E",
  'qopf': "\uD835\uDD62",
  'qprime': "\u2057",
  'qscr': "\uD835\uDCC6",
  'quatint': "\u2A16",
  'quest': "?",
  'rAtail': "\u291C",
  'rHar': "\u2964",
  'race': "\u223D\u0331",
  'racute': "\u0155",
  'raemptyv': "\u29B3",
  'rangd': "\u2992",
  'range': "\u29A5",
  'raquo': "\xBB",
  'rarrap': "\u2975",
  'rarrbfs': "\u2920",
  'rarrc': "\u2933",
  'rarrfs': "\u291E",
  'rarrpl': "\u2945",
  'rarrsim': "\u2974",
  'rarrtl': "\u21A3",
  'rightarrowtail': "\u21A3",
  'rarrw': "\u219D",
  'rightsquigarrow': "\u219D",
  'ratail': "\u291A",
  'ratio': "\u2236",
  'rbbrk': "\u2773",
  'rbrace': "}",
  'rcub': "}",
  'rbrack': "]",
  'rsqb': "]",
  'rbrke': "\u298C",
  'rbrksld': "\u298E",
  'rbrkslu': "\u2990",
  'rcaron': "\u0159",
  'rcedil': "\u0157",
  'rcy': "\u0440",
  'rdca': "\u2937",
  'rdldhar': "\u2969",
  'rdsh': "\u21B3",
  'rect': "\u25AD",
  'rfisht': "\u297D",
  'rfr': "\uD835\uDD2F",
  'rharul': "\u296C",
  'rho': "\u03C1",
  'rhov': "\u03F1",
  'varrho': "\u03F1",
  'rightrightarrows': "\u21C9",
  'rrarr': "\u21C9",
  'rightthreetimes': "\u22CC",
  'rthree': "\u22CC",
  'ring': "\u02DA",
  'rlm': "\u200F",
  'rmoust': "\u23B1",
  'rmoustache': "\u23B1",
  'rnmid': "\u2AEE",
  'roang': "\u27ED",
  'roarr': "\u21FE",
  'ropar': "\u2986",
  'ropf': "\uD835\uDD63",
  'roplus': "\u2A2E",
  'rotimes': "\u2A35",
  'rpar': ")",
  'rpargt': "\u2994",
  'rppolint': "\u2A12",
  'rsaquo': "\u203A",
  'rscr': "\uD835\uDCC7",
  'rtimes': "\u22CA",
  'rtri': "\u25B9",
  'triangleright': "\u25B9",
  'rtriltri': "\u29CE",
  'ruluhar': "\u2968",
  'rx': "\u211E",
  'sacute': "\u015B",
  'scE': "\u2AB4",
  'scap': "\u2AB8",
  'succapprox': "\u2AB8",
  'scaron': "\u0161",
  'scedil': "\u015F",
  'scirc': "\u015D",
  'scnE': "\u2AB6",
  'succneqq': "\u2AB6",
  'scnap': "\u2ABA",
  'succnapprox': "\u2ABA",
  'scnsim': "\u22E9",
  'succnsim': "\u22E9",
  'scpolint': "\u2A13",
  'scy': "\u0441",
  'sdot': "\u22C5",
  'sdote': "\u2A66",
  'seArr': "\u21D8",
  'sect': "\xA7",
  'semi': ";",
  'seswar': "\u2929",
  'tosa': "\u2929",
  'sext': "\u2736",
  'sfr': "\uD835\uDD30",
  'sharp': "\u266F",
  'shchcy': "\u0449",
  'shcy': "\u0448",
  'shy': "\xAD",
  'sigma': "\u03C3",
  'sigmaf': "\u03C2",
  'sigmav': "\u03C2",
  'varsigma': "\u03C2",
  'simdot': "\u2A6A",
  'simg': "\u2A9E",
  'simgE': "\u2AA0",
  'siml': "\u2A9D",
  'simlE': "\u2A9F",
  'simne': "\u2246",
  'simplus': "\u2A24",
  'simrarr': "\u2972",
  'smashp': "\u2A33",
  'smeparsl': "\u29E4",
  'smile': "\u2323",
  'ssmile': "\u2323",
  'smt': "\u2AAA",
  'smte': "\u2AAC",
  'smtes': "\u2AAC\uFE00",
  'softcy': "\u044C",
  'sol': "/",
  'solb': "\u29C4",
  'solbar': "\u233F",
  'sopf': "\uD835\uDD64",
  'spades': "\u2660",
  'spadesuit': "\u2660",
  'sqcaps': "\u2293\uFE00",
  'sqcups': "\u2294\uFE00",
  'sscr': "\uD835\uDCC8",
  'star': "\u2606",
  'sub': "\u2282",
  'subset': "\u2282",
  'subE': "\u2AC5",
  'subseteqq': "\u2AC5",
  'subdot': "\u2ABD",
  'subedot': "\u2AC3",
  'submult': "\u2AC1",
  'subnE': "\u2ACB",
  'subsetneqq': "\u2ACB",
  'subne': "\u228A",
  'subsetneq': "\u228A",
  'subplus': "\u2ABF",
  'subrarr': "\u2979",
  'subsim': "\u2AC7",
  'subsub': "\u2AD5",
  'subsup': "\u2AD3",
  'sung': "\u266A",
  'sup1': "\xB9",
  'sup2': "\xB2",
  'sup3': "\xB3",
  'supE': "\u2AC6",
  'supseteqq': "\u2AC6",
  'supdot': "\u2ABE",
  'supdsub': "\u2AD8",
  'supedot': "\u2AC4",
  'suphsol': "\u27C9",
  'suphsub': "\u2AD7",
  'suplarr': "\u297B",
  'supmult': "\u2AC2",
  'supnE': "\u2ACC",
  'supsetneqq': "\u2ACC",
  'supne': "\u228B",
  'supsetneq': "\u228B",
  'supplus': "\u2AC0",
  'supsim': "\u2AC8",
  'supsub': "\u2AD4",
  'supsup': "\u2AD6",
  'swArr': "\u21D9",
  'swnwar': "\u292A",
  'szlig': "\xDF",
  'target': "\u2316",
  'tau': "\u03C4",
  'tcaron': "\u0165",
  'tcedil': "\u0163",
  'tcy': "\u0442",
  'telrec': "\u2315",
  'tfr': "\uD835\uDD31",
  'theta': "\u03B8",
  'thetasym': "\u03D1",
  'thetav': "\u03D1",
  'vartheta': "\u03D1",
  'thorn': "\xFE",
  'times': "\xD7",
  'timesbar': "\u2A31",
  'timesd': "\u2A30",
  'topbot': "\u2336",
  'topcir': "\u2AF1",
  'topf': "\uD835\uDD65",
  'topfork': "\u2ADA",
  'tprime': "\u2034",
  'triangle': "\u25B5",
  'utri': "\u25B5",
  'triangleq': "\u225C",
  'trie': "\u225C",
  'tridot': "\u25EC",
  'triminus': "\u2A3A",
  'triplus': "\u2A39",
  'trisb': "\u29CD",
  'tritime': "\u2A3B",
  'trpezium': "\u23E2",
  'tscr': "\uD835\uDCC9",
  'tscy': "\u0446",
  'tshcy': "\u045B",
  'tstrok': "\u0167",
  'uHar': "\u2963",
  'uacute': "\xFA",
  'ubrcy': "\u045E",
  'ubreve': "\u016D",
  'ucirc': "\xFB",
  'ucy': "\u0443",
  'udblac': "\u0171",
  'ufisht': "\u297E",
  'ufr': "\uD835\uDD32",
  'ugrave': "\xF9",
  'uhblk': "\u2580",
  'ulcorn': "\u231C",
  'ulcorner': "\u231C",
  'ulcrop': "\u230F",
  'ultri': "\u25F8",
  'umacr': "\u016B",
  'uogon': "\u0173",
  'uopf': "\uD835\uDD66",
  'upsi': "\u03C5",
  'upsilon': "\u03C5",
  'upuparrows': "\u21C8",
  'uuarr': "\u21C8",
  'urcorn': "\u231D",
  'urcorner': "\u231D",
  'urcrop': "\u230E",
  'uring': "\u016F",
  'urtri': "\u25F9",
  'uscr': "\uD835\uDCCA",
  'utdot': "\u22F0",
  'utilde': "\u0169",
  'uuml': "\xFC",
  'uwangle': "\u29A7",
  'vBar': "\u2AE8",
  'vBarv': "\u2AE9",
  'vangrt': "\u299C",
  'varsubsetneq': "\u228A\uFE00",
  'vsubne': "\u228A\uFE00",
  'varsubsetneqq': "\u2ACB\uFE00",
  'vsubnE': "\u2ACB\uFE00",
  'varsupsetneq': "\u228B\uFE00",
  'vsupne': "\u228B\uFE00",
  'varsupsetneqq': "\u2ACC\uFE00",
  'vsupnE': "\u2ACC\uFE00",
  'vcy': "\u0432",
  'veebar': "\u22BB",
  'veeeq': "\u225A",
  'vellip': "\u22EE",
  'vfr': "\uD835\uDD33",
  'vopf': "\uD835\uDD67",
  'vscr': "\uD835\uDCCB",
  'vzigzag': "\u299A",
  'wcirc': "\u0175",
  'wedbar': "\u2A5F",
  'wedgeq': "\u2259",
  'weierp': "\u2118",
  'wp': "\u2118",
  'wfr': "\uD835\uDD34",
  'wopf': "\uD835\uDD68",
  'wscr': "\uD835\uDCCC",
  'xfr': "\uD835\uDD35",
  'xi': "\u03BE",
  'xnis': "\u22FB",
  'xopf': "\uD835\uDD69",
  'xscr': "\uD835\uDCCD",
  'yacute': "\xFD",
  'yacy': "\u044F",
  'ycirc': "\u0177",
  'ycy': "\u044B",
  'yen': "\xA5",
  'yfr': "\uD835\uDD36",
  'yicy': "\u0457",
  'yopf': "\uD835\uDD6A",
  'yscr': "\uD835\uDCCE",
  'yucy': "\u044E",
  'yuml': "\xFF",
  'zacute': "\u017A",
  'zcaron': "\u017E",
  'zcy': "\u0437",
  'zdot': "\u017C",
  'zeta': "\u03B6",
  'zfr': "\uD835\uDD37",
  'zhcy': "\u0436",
  'zigrarr': "\u21DD",
  'zopf': "\uD835\uDD6B",
  'zscr': "\uD835\uDCCF",
  'zwj': "\u200D",
  'zwnj': "\u200C"
}; // The &ngsp; pseudo-entity is denoting a space. see:
// https://github.com/dart-lang/angular/blob/0bb611387d29d65b5af7f9d2515ab571fd3fbee4/_tests/test/compiler/preserve_whitespace_test.dart

var NGSP_UNICODE = "\uE500";
NAMED_ENTITIES['ngsp'] = NGSP_UNICODE;
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

var TokenError = /*#__PURE__*/function (_ParseError) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(TokenError, _ParseError);

  var _super72 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(TokenError);

  function TokenError(errorMsg, tokenType, span) {
    var _this114;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, TokenError);

    _this114 = _super72.call(this, span, errorMsg);
    _this114.tokenType = tokenType;
    return _this114;
  }

  return (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(TokenError);
}(ParseError);

var TokenizeResult = /*#__PURE__*/(0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(function TokenizeResult(tokens, errors, nonNormalizedIcuExpressions) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, TokenizeResult);

  this.tokens = tokens;
  this.errors = errors;
  this.nonNormalizedIcuExpressions = nonNormalizedIcuExpressions;
});

function tokenize(source, url, getTagDefinition) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var tokenizer = new _Tokenizer(new ParseSourceFile(source, url), getTagDefinition, options);
  tokenizer.tokenize();
  return new TokenizeResult(mergeTextTokens(tokenizer.tokens), tokenizer.errors, tokenizer.nonNormalizedIcuExpressions);
}

var _CR_OR_CRLF_REGEXP = /\r\n?/g;

function _unexpectedCharacterErrorMsg(charCode) {
  var char = charCode === $EOF ? 'EOF' : String.fromCharCode(charCode);
  return "Unexpected character \"".concat(char, "\"");
}

function _unknownEntityErrorMsg(entitySrc) {
  return "Unknown entity \"".concat(entitySrc, "\" - use the \"&#<decimal>;\" or  \"&#x<hex>;\" syntax");
}

function _unparsableEntityErrorMsg(type, entityStr) {
  return "Unable to parse entity \"".concat(entityStr, "\" - ").concat(type, " character reference entities must end with \";\"");
}

var CharacterReferenceType;

(function (CharacterReferenceType) {
  CharacterReferenceType["HEX"] = "hexadecimal";
  CharacterReferenceType["DEC"] = "decimal";
})(CharacterReferenceType || (CharacterReferenceType = {}));

var _ControlFlowError = /*#__PURE__*/(0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(function _ControlFlowError(error) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, _ControlFlowError);

  this.error = error;
}); // See https://www.w3.org/TR/html51/syntax.html#writing-html-documents


var _Tokenizer = /*#__PURE__*/function () {
  /**
   * @param _file The html source file being tokenized.
   * @param _getTagDefinition A function that will retrieve a tag definition for a given tag name.
   * @param options Configuration of the tokenization.
   */
  function _Tokenizer(_file, _getTagDefinition, options) {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, _Tokenizer);

    this._getTagDefinition = _getTagDefinition;
    this._currentTokenStart = null;
    this._currentTokenType = null;
    this._expansionCaseStack = [];
    this._inInterpolation = false;
    this.tokens = [];
    this.errors = [];
    this.nonNormalizedIcuExpressions = [];
    this._tokenizeIcu = options.tokenizeExpansionForms || false;
    this._interpolationConfig = options.interpolationConfig || DEFAULT_INTERPOLATION_CONFIG;
    this._leadingTriviaCodePoints = options.leadingTriviaChars && options.leadingTriviaChars.map(function (c) {
      return c.codePointAt(0) || 0;
    });
    var range = options.range || {
      endPos: _file.content.length,
      startPos: 0,
      startLine: 0,
      startCol: 0
    };
    this._cursor = options.escapedString ? new EscapedCharacterCursor(_file, range) : new PlainCharacterCursor(_file, range);
    this._preserveLineEndings = options.preserveLineEndings || false;
    this._escapedString = options.escapedString || false;
    this._i18nNormalizeLineEndingsInICUs = options.i18nNormalizeLineEndingsInICUs || false;

    try {
      this._cursor.init();
    } catch (e) {
      this.handleError(e);
    }
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(_Tokenizer, [{
    key: "_processCarriageReturns",
    value: function _processCarriageReturns(content) {
      if (this._preserveLineEndings) {
        return content;
      } // https://www.w3.org/TR/html51/syntax.html#preprocessing-the-input-stream
      // In order to keep the original position in the source, we can not
      // pre-process it.
      // Instead CRs are processed right before instantiating the tokens.


      return content.replace(_CR_OR_CRLF_REGEXP, '\n');
    }
  }, {
    key: "tokenize",
    value: function tokenize() {
      var _this115 = this;

      while (this._cursor.peek() !== $EOF) {
        var _start4 = this._cursor.clone();

        try {
          if (this._attemptCharCode($LT)) {
            if (this._attemptCharCode($BANG)) {
              if (this._attemptCharCode($LBRACKET)) {
                this._consumeCdata(_start4);
              } else if (this._attemptCharCode($MINUS)) {
                this._consumeComment(_start4);
              } else {
                this._consumeDocType(_start4);
              }
            } else if (this._attemptCharCode($SLASH)) {
              this._consumeTagClose(_start4);
            } else {
              this._consumeTagOpen(_start4);
            }
          } else if (!(this._tokenizeIcu && this._tokenizeExpansionForm())) {
            // In (possibly interpolated) text the end of the text is given by `isTextEnd()`, while
            // the premature end of an interpolation is given by the start of a new HTML element.
            this._consumeWithInterpolation(5
            /* TokenType.TEXT */
            , 8
            /* TokenType.INTERPOLATION */
            , function () {
              return _this115._isTextEnd();
            }, function () {
              return _this115._isTagStart();
            });
          }
        } catch (e) {
          this.handleError(e);
        }
      }

      this._beginToken(24
      /* TokenType.EOF */
      );

      this._endToken([]);
    }
    /**
     * @returns whether an ICU token has been created
     * @internal
     */

  }, {
    key: "_tokenizeExpansionForm",
    value: function _tokenizeExpansionForm() {
      if (this.isExpansionFormStart()) {
        this._consumeExpansionFormStart();

        return true;
      }

      if (isExpansionCaseStart(this._cursor.peek()) && this._isInExpansionForm()) {
        this._consumeExpansionCaseStart();

        return true;
      }

      if (this._cursor.peek() === $RBRACE) {
        if (this._isInExpansionCase()) {
          this._consumeExpansionCaseEnd();

          return true;
        }

        if (this._isInExpansionForm()) {
          this._consumeExpansionFormEnd();

          return true;
        }
      }

      return false;
    }
  }, {
    key: "_beginToken",
    value: function _beginToken(type) {
      var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._cursor.clone();
      this._currentTokenStart = start;
      this._currentTokenType = type;
    }
  }, {
    key: "_endToken",
    value: function _endToken(parts, end) {
      if (this._currentTokenStart === null) {
        throw new TokenError('Programming error - attempted to end a token when there was no start to the token', this._currentTokenType, this._cursor.getSpan(end));
      }

      if (this._currentTokenType === null) {
        throw new TokenError('Programming error - attempted to end a token which has no token type', null, this._cursor.getSpan(this._currentTokenStart));
      }

      var token = {
        type: this._currentTokenType,
        parts: parts,
        sourceSpan: (end !== null && end !== void 0 ? end : this._cursor).getSpan(this._currentTokenStart, this._leadingTriviaCodePoints)
      };
      this.tokens.push(token);
      this._currentTokenStart = null;
      this._currentTokenType = null;
      return token;
    }
  }, {
    key: "_createError",
    value: function _createError(msg, span) {
      if (this._isInExpansionForm()) {
        msg += " (Do you have an unescaped \"{\" in your template? Use \"{{ '{' }}\") to escape it.)";
      }

      var error = new TokenError(msg, this._currentTokenType, span);
      this._currentTokenStart = null;
      this._currentTokenType = null;
      return new _ControlFlowError(error);
    }
  }, {
    key: "handleError",
    value: function handleError(e) {
      if (e instanceof CursorError) {
        e = this._createError(e.msg, this._cursor.getSpan(e.cursor));
      }

      if (e instanceof _ControlFlowError) {
        this.errors.push(e.error);
      } else {
        throw e;
      }
    }
  }, {
    key: "_attemptCharCode",
    value: function _attemptCharCode(charCode) {
      if (this._cursor.peek() === charCode) {
        this._cursor.advance();

        return true;
      }

      return false;
    }
  }, {
    key: "_attemptCharCodeCaseInsensitive",
    value: function _attemptCharCodeCaseInsensitive(charCode) {
      if (compareCharCodeCaseInsensitive(this._cursor.peek(), charCode)) {
        this._cursor.advance();

        return true;
      }

      return false;
    }
  }, {
    key: "_requireCharCode",
    value: function _requireCharCode(charCode) {
      var location = this._cursor.clone();

      if (!this._attemptCharCode(charCode)) {
        throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(location));
      }
    }
  }, {
    key: "_attemptStr",
    value: function _attemptStr(chars) {
      var len = chars.length;

      if (this._cursor.charsLeft() < len) {
        return false;
      }

      var initialPosition = this._cursor.clone();

      for (var i = 0; i < len; i++) {
        if (!this._attemptCharCode(chars.charCodeAt(i))) {
          // If attempting to parse the string fails, we want to reset the parser
          // to where it was before the attempt
          this._cursor = initialPosition;
          return false;
        }
      }

      return true;
    }
  }, {
    key: "_attemptStrCaseInsensitive",
    value: function _attemptStrCaseInsensitive(chars) {
      for (var i = 0; i < chars.length; i++) {
        if (!this._attemptCharCodeCaseInsensitive(chars.charCodeAt(i))) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "_requireStr",
    value: function _requireStr(chars) {
      var location = this._cursor.clone();

      if (!this._attemptStr(chars)) {
        throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(location));
      }
    }
  }, {
    key: "_attemptCharCodeUntilFn",
    value: function _attemptCharCodeUntilFn(predicate) {
      while (!predicate(this._cursor.peek())) {
        this._cursor.advance();
      }
    }
  }, {
    key: "_requireCharCodeUntilFn",
    value: function _requireCharCodeUntilFn(predicate, len) {
      var start = this._cursor.clone();

      this._attemptCharCodeUntilFn(predicate);

      if (this._cursor.diff(start) < len) {
        throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(start));
      }
    }
  }, {
    key: "_attemptUntilChar",
    value: function _attemptUntilChar(char) {
      while (this._cursor.peek() !== char) {
        this._cursor.advance();
      }
    }
  }, {
    key: "_readChar",
    value: function _readChar() {
      // Don't rely upon reading directly from `_input` as the actual char value
      // may have been generated from an escape sequence.
      var char = String.fromCodePoint(this._cursor.peek());

      this._cursor.advance();

      return char;
    }
  }, {
    key: "_consumeEntity",
    value: function _consumeEntity(textTokenType) {
      this._beginToken(9
      /* TokenType.ENCODED_ENTITY */
      );

      var start = this._cursor.clone();

      this._cursor.advance();

      if (this._attemptCharCode($HASH)) {
        var isHex = this._attemptCharCode($x) || this._attemptCharCode($X);

        var codeStart = this._cursor.clone();

        this._attemptCharCodeUntilFn(isDigitEntityEnd);

        if (this._cursor.peek() != $SEMICOLON) {
          // Advance cursor to include the peeked character in the string provided to the error
          // message.
          this._cursor.advance();

          var entityType = isHex ? CharacterReferenceType.HEX : CharacterReferenceType.DEC;
          throw this._createError(_unparsableEntityErrorMsg(entityType, this._cursor.getChars(start)), this._cursor.getSpan());
        }

        var strNum = this._cursor.getChars(codeStart);

        this._cursor.advance();

        try {
          var charCode = parseInt(strNum, isHex ? 16 : 10);

          this._endToken([String.fromCharCode(charCode), this._cursor.getChars(start)]);
        } catch (_a) {
          throw this._createError(_unknownEntityErrorMsg(this._cursor.getChars(start)), this._cursor.getSpan());
        }
      } else {
        var nameStart = this._cursor.clone();

        this._attemptCharCodeUntilFn(isNamedEntityEnd);

        if (this._cursor.peek() != $SEMICOLON) {
          // No semicolon was found so abort the encoded entity token that was in progress, and treat
          // this as a text token
          this._beginToken(textTokenType, start);

          this._cursor = nameStart;

          this._endToken(['&']);
        } else {
          var name = this._cursor.getChars(nameStart);

          this._cursor.advance();

          var char = NAMED_ENTITIES[name];

          if (!char) {
            throw this._createError(_unknownEntityErrorMsg(name), this._cursor.getSpan(start));
          }

          this._endToken([char, "&".concat(name, ";")]);
        }
      }
    }
  }, {
    key: "_consumeRawText",
    value: function _consumeRawText(consumeEntities, endMarkerPredicate) {
      this._beginToken(consumeEntities ? 6
      /* TokenType.ESCAPABLE_RAW_TEXT */
      : 7
      /* TokenType.RAW_TEXT */
      );

      var parts = [];

      while (true) {
        var tagCloseStart = this._cursor.clone();

        var foundEndMarker = endMarkerPredicate();
        this._cursor = tagCloseStart;

        if (foundEndMarker) {
          break;
        }

        if (consumeEntities && this._cursor.peek() === $AMPERSAND) {
          this._endToken([this._processCarriageReturns(parts.join(''))]);

          parts.length = 0;

          this._consumeEntity(6
          /* TokenType.ESCAPABLE_RAW_TEXT */
          );

          this._beginToken(6
          /* TokenType.ESCAPABLE_RAW_TEXT */
          );
        } else {
          parts.push(this._readChar());
        }
      }

      this._endToken([this._processCarriageReturns(parts.join(''))]);
    }
  }, {
    key: "_consumeComment",
    value: function _consumeComment(start) {
      var _this116 = this;

      this._beginToken(10
      /* TokenType.COMMENT_START */
      , start);

      this._requireCharCode($MINUS);

      this._endToken([]);

      this._consumeRawText(false, function () {
        return _this116._attemptStr('-->');
      });

      this._beginToken(11
      /* TokenType.COMMENT_END */
      );

      this._requireStr('-->');

      this._endToken([]);
    }
  }, {
    key: "_consumeCdata",
    value: function _consumeCdata(start) {
      var _this117 = this;

      this._beginToken(12
      /* TokenType.CDATA_START */
      , start);

      this._requireStr('CDATA[');

      this._endToken([]);

      this._consumeRawText(false, function () {
        return _this117._attemptStr(']]>');
      });

      this._beginToken(13
      /* TokenType.CDATA_END */
      );

      this._requireStr(']]>');

      this._endToken([]);
    }
  }, {
    key: "_consumeDocType",
    value: function _consumeDocType(start) {
      this._beginToken(18
      /* TokenType.DOC_TYPE */
      , start);

      var contentStart = this._cursor.clone();

      this._attemptUntilChar($GT);

      var content = this._cursor.getChars(contentStart);

      this._cursor.advance();

      this._endToken([content]);
    }
  }, {
    key: "_consumePrefixAndName",
    value: function _consumePrefixAndName() {
      var nameOrPrefixStart = this._cursor.clone();

      var prefix = '';

      while (this._cursor.peek() !== $COLON && !isPrefixEnd(this._cursor.peek())) {
        this._cursor.advance();
      }

      var nameStart;

      if (this._cursor.peek() === $COLON) {
        prefix = this._cursor.getChars(nameOrPrefixStart);

        this._cursor.advance();

        nameStart = this._cursor.clone();
      } else {
        nameStart = nameOrPrefixStart;
      }

      this._requireCharCodeUntilFn(isNameEnd, prefix === '' ? 0 : 1);

      var name = this._cursor.getChars(nameStart);

      return [prefix, name];
    }
  }, {
    key: "_consumeTagOpen",
    value: function _consumeTagOpen(start) {
      var tagName;
      var prefix;
      var openTagToken;

      try {
        if (!isAsciiLetter(this._cursor.peek())) {
          throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(start));
        }

        openTagToken = this._consumeTagOpenStart(start);
        prefix = openTagToken.parts[0];
        tagName = openTagToken.parts[1];

        this._attemptCharCodeUntilFn(isNotWhitespace);

        while (this._cursor.peek() !== $SLASH && this._cursor.peek() !== $GT && this._cursor.peek() !== $LT && this._cursor.peek() !== $EOF) {
          this._consumeAttributeName();

          this._attemptCharCodeUntilFn(isNotWhitespace);

          if (this._attemptCharCode($EQ)) {
            this._attemptCharCodeUntilFn(isNotWhitespace);

            this._consumeAttributeValue();
          }

          this._attemptCharCodeUntilFn(isNotWhitespace);
        }

        this._consumeTagOpenEnd();
      } catch (e) {
        if (e instanceof _ControlFlowError) {
          if (openTagToken) {
            // We errored before we could close the opening tag, so it is incomplete.
            openTagToken.type = 4
            /* TokenType.INCOMPLETE_TAG_OPEN */
            ;
          } else {
            // When the start tag is invalid, assume we want a "<" as text.
            // Back to back text tokens are merged at the end.
            this._beginToken(5
            /* TokenType.TEXT */
            , start);

            this._endToken(['<']);
          }

          return;
        }

        throw e;
      }

      var contentTokenType = this._getTagDefinition(tagName).getContentType(prefix);

      if (contentTokenType === TagContentType.RAW_TEXT) {
        this._consumeRawTextWithTagClose(prefix, tagName, false);
      } else if (contentTokenType === TagContentType.ESCAPABLE_RAW_TEXT) {
        this._consumeRawTextWithTagClose(prefix, tagName, true);
      }
    }
  }, {
    key: "_consumeRawTextWithTagClose",
    value: function _consumeRawTextWithTagClose(prefix, tagName, consumeEntities) {
      var _this118 = this;

      this._consumeRawText(consumeEntities, function () {
        if (!_this118._attemptCharCode($LT)) return false;
        if (!_this118._attemptCharCode($SLASH)) return false;

        _this118._attemptCharCodeUntilFn(isNotWhitespace);

        if (!_this118._attemptStrCaseInsensitive(tagName)) return false;

        _this118._attemptCharCodeUntilFn(isNotWhitespace);

        return _this118._attemptCharCode($GT);
      });

      this._beginToken(3
      /* TokenType.TAG_CLOSE */
      );

      this._requireCharCodeUntilFn(function (code) {
        return code === $GT;
      }, 3);

      this._cursor.advance(); // Consume the `>`


      this._endToken([prefix, tagName]);
    }
  }, {
    key: "_consumeTagOpenStart",
    value: function _consumeTagOpenStart(start) {
      this._beginToken(0
      /* TokenType.TAG_OPEN_START */
      , start);

      var parts = this._consumePrefixAndName();

      return this._endToken(parts);
    }
  }, {
    key: "_consumeAttributeName",
    value: function _consumeAttributeName() {
      var attrNameStart = this._cursor.peek();

      if (attrNameStart === $SQ || attrNameStart === $DQ) {
        throw this._createError(_unexpectedCharacterErrorMsg(attrNameStart), this._cursor.getSpan());
      }

      this._beginToken(14
      /* TokenType.ATTR_NAME */
      );

      var prefixAndName = this._consumePrefixAndName();

      this._endToken(prefixAndName);
    }
  }, {
    key: "_consumeAttributeValue",
    value: function _consumeAttributeValue() {
      var _this119 = this;

      var value;

      if (this._cursor.peek() === $SQ || this._cursor.peek() === $DQ) {
        var quoteChar = this._cursor.peek();

        this._consumeQuote(quoteChar); // In an attribute then end of the attribute value and the premature end to an interpolation
        // are both triggered by the `quoteChar`.


        var endPredicate = function endPredicate() {
          return _this119._cursor.peek() === quoteChar;
        };

        this._consumeWithInterpolation(16
        /* TokenType.ATTR_VALUE_TEXT */
        , 17
        /* TokenType.ATTR_VALUE_INTERPOLATION */
        , endPredicate, endPredicate);

        this._consumeQuote(quoteChar);
      } else {
        var _endPredicate = function _endPredicate() {
          return isNameEnd(_this119._cursor.peek());
        };

        this._consumeWithInterpolation(16
        /* TokenType.ATTR_VALUE_TEXT */
        , 17
        /* TokenType.ATTR_VALUE_INTERPOLATION */
        , _endPredicate, _endPredicate);
      }
    }
  }, {
    key: "_consumeQuote",
    value: function _consumeQuote(quoteChar) {
      this._beginToken(15
      /* TokenType.ATTR_QUOTE */
      );

      this._requireCharCode(quoteChar);

      this._endToken([String.fromCodePoint(quoteChar)]);
    }
  }, {
    key: "_consumeTagOpenEnd",
    value: function _consumeTagOpenEnd() {
      var tokenType = this._attemptCharCode($SLASH) ? 2
      /* TokenType.TAG_OPEN_END_VOID */
      : 1
      /* TokenType.TAG_OPEN_END */
      ;

      this._beginToken(tokenType);

      this._requireCharCode($GT);

      this._endToken([]);
    }
  }, {
    key: "_consumeTagClose",
    value: function _consumeTagClose(start) {
      this._beginToken(3
      /* TokenType.TAG_CLOSE */
      , start);

      this._attemptCharCodeUntilFn(isNotWhitespace);

      var prefixAndName = this._consumePrefixAndName();

      this._attemptCharCodeUntilFn(isNotWhitespace);

      this._requireCharCode($GT);

      this._endToken(prefixAndName);
    }
  }, {
    key: "_consumeExpansionFormStart",
    value: function _consumeExpansionFormStart() {
      this._beginToken(19
      /* TokenType.EXPANSION_FORM_START */
      );

      this._requireCharCode($LBRACE);

      this._endToken([]);

      this._expansionCaseStack.push(19
      /* TokenType.EXPANSION_FORM_START */
      );

      this._beginToken(7
      /* TokenType.RAW_TEXT */
      );

      var condition = this._readUntil($COMMA);

      var normalizedCondition = this._processCarriageReturns(condition);

      if (this._i18nNormalizeLineEndingsInICUs) {
        // We explicitly want to normalize line endings for this text.
        this._endToken([normalizedCondition]);
      } else {
        // We are not normalizing line endings.
        var conditionToken = this._endToken([condition]);

        if (normalizedCondition !== condition) {
          this.nonNormalizedIcuExpressions.push(conditionToken);
        }
      }

      this._requireCharCode($COMMA);

      this._attemptCharCodeUntilFn(isNotWhitespace);

      this._beginToken(7
      /* TokenType.RAW_TEXT */
      );

      var type = this._readUntil($COMMA);

      this._endToken([type]);

      this._requireCharCode($COMMA);

      this._attemptCharCodeUntilFn(isNotWhitespace);
    }
  }, {
    key: "_consumeExpansionCaseStart",
    value: function _consumeExpansionCaseStart() {
      this._beginToken(20
      /* TokenType.EXPANSION_CASE_VALUE */
      );

      var value = this._readUntil($LBRACE).trim();

      this._endToken([value]);

      this._attemptCharCodeUntilFn(isNotWhitespace);

      this._beginToken(21
      /* TokenType.EXPANSION_CASE_EXP_START */
      );

      this._requireCharCode($LBRACE);

      this._endToken([]);

      this._attemptCharCodeUntilFn(isNotWhitespace);

      this._expansionCaseStack.push(21
      /* TokenType.EXPANSION_CASE_EXP_START */
      );
    }
  }, {
    key: "_consumeExpansionCaseEnd",
    value: function _consumeExpansionCaseEnd() {
      this._beginToken(22
      /* TokenType.EXPANSION_CASE_EXP_END */
      );

      this._requireCharCode($RBRACE);

      this._endToken([]);

      this._attemptCharCodeUntilFn(isNotWhitespace);

      this._expansionCaseStack.pop();
    }
  }, {
    key: "_consumeExpansionFormEnd",
    value: function _consumeExpansionFormEnd() {
      this._beginToken(23
      /* TokenType.EXPANSION_FORM_END */
      );

      this._requireCharCode($RBRACE);

      this._endToken([]);

      this._expansionCaseStack.pop();
    }
    /**
     * Consume a string that may contain interpolation expressions.
     *
     * The first token consumed will be of `tokenType` and then there will be alternating
     * `interpolationTokenType` and `tokenType` tokens until the `endPredicate()` returns true.
     *
     * If an interpolation token ends prematurely it will have no end marker in its `parts` array.
     *
     * @param textTokenType the kind of tokens to interleave around interpolation tokens.
     * @param interpolationTokenType the kind of tokens that contain interpolation.
     * @param endPredicate a function that should return true when we should stop consuming.
     * @param endInterpolation a function that should return true if there is a premature end to an
     *     interpolation expression - i.e. before we get to the normal interpolation closing marker.
     */

  }, {
    key: "_consumeWithInterpolation",
    value: function _consumeWithInterpolation(textTokenType, interpolationTokenType, endPredicate, endInterpolation) {
      this._beginToken(textTokenType);

      var parts = [];

      while (!endPredicate()) {
        var current = this._cursor.clone();

        if (this._interpolationConfig && this._attemptStr(this._interpolationConfig.start)) {
          this._endToken([this._processCarriageReturns(parts.join(''))], current);

          parts.length = 0;

          this._consumeInterpolation(interpolationTokenType, current, endInterpolation);

          this._beginToken(textTokenType);
        } else if (this._cursor.peek() === $AMPERSAND) {
          this._endToken([this._processCarriageReturns(parts.join(''))]);

          parts.length = 0;

          this._consumeEntity(textTokenType);

          this._beginToken(textTokenType);
        } else {
          parts.push(this._readChar());
        }
      } // It is possible that an interpolation was started but not ended inside this text token.
      // Make sure that we reset the state of the lexer correctly.


      this._inInterpolation = false;

      this._endToken([this._processCarriageReturns(parts.join(''))]);
    }
    /**
     * Consume a block of text that has been interpreted as an Angular interpolation.
     *
     * @param interpolationTokenType the type of the interpolation token to generate.
     * @param interpolationStart a cursor that points to the start of this interpolation.
     * @param prematureEndPredicate a function that should return true if the next characters indicate
     *     an end to the interpolation before its normal closing marker.
     */

  }, {
    key: "_consumeInterpolation",
    value: function _consumeInterpolation(interpolationTokenType, interpolationStart, prematureEndPredicate) {
      var parts = [];

      this._beginToken(interpolationTokenType, interpolationStart);

      parts.push(this._interpolationConfig.start); // Find the end of the interpolation, ignoring content inside quotes.

      var expressionStart = this._cursor.clone();

      var inQuote = null;
      var inComment = false;

      while (this._cursor.peek() !== $EOF && (prematureEndPredicate === null || !prematureEndPredicate())) {
        var current = this._cursor.clone();

        if (this._isTagStart()) {
          // We are starting what looks like an HTML element in the middle of this interpolation.
          // Reset the cursor to before the `<` character and end the interpolation token.
          // (This is actually wrong but here for backward compatibility).
          this._cursor = current;
          parts.push(this._getProcessedChars(expressionStart, current));

          this._endToken(parts);

          return;
        }

        if (inQuote === null) {
          if (this._attemptStr(this._interpolationConfig.end)) {
            // We are not in a string, and we hit the end interpolation marker
            parts.push(this._getProcessedChars(expressionStart, current));
            parts.push(this._interpolationConfig.end);

            this._endToken(parts);

            return;
          } else if (this._attemptStr('//')) {
            // Once we are in a comment we ignore any quotes
            inComment = true;
          }
        }

        var char = this._cursor.peek();

        this._cursor.advance();

        if (char === $BACKSLASH) {
          // Skip the next character because it was escaped.
          this._cursor.advance();
        } else if (char === inQuote) {
          // Exiting the current quoted string
          inQuote = null;
        } else if (!inComment && inQuote === null && isQuote(char)) {
          // Entering a new quoted string
          inQuote = char;
        }
      } // We hit EOF without finding a closing interpolation marker


      parts.push(this._getProcessedChars(expressionStart, this._cursor));

      this._endToken(parts);
    }
  }, {
    key: "_getProcessedChars",
    value: function _getProcessedChars(start, end) {
      return this._processCarriageReturns(end.getChars(start));
    }
  }, {
    key: "_isTextEnd",
    value: function _isTextEnd() {
      if (this._isTagStart() || this._cursor.peek() === $EOF) {
        return true;
      }

      if (this._tokenizeIcu && !this._inInterpolation) {
        if (this.isExpansionFormStart()) {
          // start of an expansion form
          return true;
        }

        if (this._cursor.peek() === $RBRACE && this._isInExpansionCase()) {
          // end of and expansion case
          return true;
        }
      }

      return false;
    }
    /**
     * Returns true if the current cursor is pointing to the start of a tag
     * (opening/closing/comments/cdata/etc).
     */

  }, {
    key: "_isTagStart",
    value: function _isTagStart() {
      if (this._cursor.peek() === $LT) {
        // We assume that `<` followed by whitespace is not the start of an HTML element.
        var tmp = this._cursor.clone();

        tmp.advance(); // If the next character is alphabetic, ! nor / then it is a tag start

        var code = tmp.peek();

        if ($a <= code && code <= $z || $A <= code && code <= $Z || code === $SLASH || code === $BANG) {
          return true;
        }
      }

      return false;
    }
  }, {
    key: "_readUntil",
    value: function _readUntil(char) {
      var start = this._cursor.clone();

      this._attemptUntilChar(char);

      return this._cursor.getChars(start);
    }
  }, {
    key: "_isInExpansionCase",
    value: function _isInExpansionCase() {
      return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === 21
      /* TokenType.EXPANSION_CASE_EXP_START */
      ;
    }
  }, {
    key: "_isInExpansionForm",
    value: function _isInExpansionForm() {
      return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === 19
      /* TokenType.EXPANSION_FORM_START */
      ;
    }
  }, {
    key: "isExpansionFormStart",
    value: function isExpansionFormStart() {
      if (this._cursor.peek() !== $LBRACE) {
        return false;
      }

      if (this._interpolationConfig) {
        var _start5 = this._cursor.clone();

        var isInterpolation = this._attemptStr(this._interpolationConfig.start);

        this._cursor = _start5;
        return !isInterpolation;
      }

      return true;
    }
  }]);

  return _Tokenizer;
}();

function isNotWhitespace(code) {
  return !isWhitespace(code) || code === $EOF;
}

function isNameEnd(code) {
  return isWhitespace(code) || code === $GT || code === $LT || code === $SLASH || code === $SQ || code === $DQ || code === $EQ || code === $EOF;
}

function isPrefixEnd(code) {
  return (code < $a || $z < code) && (code < $A || $Z < code) && (code < $0 || code > $9);
}

function isDigitEntityEnd(code) {
  return code === $SEMICOLON || code === $EOF || !isAsciiHexDigit(code);
}

function isNamedEntityEnd(code) {
  return code === $SEMICOLON || code === $EOF || !isAsciiLetter(code);
}

function isExpansionCaseStart(peek) {
  return peek !== $RBRACE;
}

function compareCharCodeCaseInsensitive(code1, code2) {
  return toUpperCaseCharCode(code1) === toUpperCaseCharCode(code2);
}

function toUpperCaseCharCode(code) {
  return code >= $a && code <= $z ? code - $a + $A : code;
}

function mergeTextTokens(srcTokens) {
  var dstTokens = [];
  var lastDstToken = undefined;

  for (var i = 0; i < srcTokens.length; i++) {
    var token = srcTokens[i];

    if (lastDstToken && lastDstToken.type === 5
    /* TokenType.TEXT */
    && token.type === 5
    /* TokenType.TEXT */
    || lastDstToken && lastDstToken.type === 16
    /* TokenType.ATTR_VALUE_TEXT */
    && token.type === 16
    /* TokenType.ATTR_VALUE_TEXT */
    ) {
      lastDstToken.parts[0] += token.parts[0];
      lastDstToken.sourceSpan.end = token.sourceSpan.end;
    } else {
      lastDstToken = token;
      dstTokens.push(lastDstToken);
    }
  }

  return dstTokens;
}

var PlainCharacterCursor = /*#__PURE__*/function () {
  function PlainCharacterCursor(fileOrCursor, range) {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, PlainCharacterCursor);

    if (fileOrCursor instanceof PlainCharacterCursor) {
      this.file = fileOrCursor.file;
      this.input = fileOrCursor.input;
      this.end = fileOrCursor.end;
      var state = fileOrCursor.state; // Note: avoid using `{...fileOrCursor.state}` here as that has a severe performance penalty.
      // In ES5 bundles the object spread operator is translated into the `__assign` helper, which
      // is not optimized by VMs as efficiently as a raw object literal. Since this constructor is
      // called in tight loops, this difference matters.

      this.state = {
        peek: state.peek,
        offset: state.offset,
        line: state.line,
        column: state.column
      };
    } else {
      if (!range) {
        throw new Error('Programming error: the range argument must be provided with a file argument.');
      }

      this.file = fileOrCursor;
      this.input = fileOrCursor.content;
      this.end = range.endPos;
      this.state = {
        peek: -1,
        offset: range.startPos,
        line: range.startLine,
        column: range.startCol
      };
    }
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(PlainCharacterCursor, [{
    key: "clone",
    value: function clone() {
      return new PlainCharacterCursor(this);
    }
  }, {
    key: "peek",
    value: function peek() {
      return this.state.peek;
    }
  }, {
    key: "charsLeft",
    value: function charsLeft() {
      return this.end - this.state.offset;
    }
  }, {
    key: "diff",
    value: function diff(other) {
      return this.state.offset - other.state.offset;
    }
  }, {
    key: "advance",
    value: function advance() {
      this.advanceState(this.state);
    }
  }, {
    key: "init",
    value: function init() {
      this.updatePeek(this.state);
    }
  }, {
    key: "getSpan",
    value: function getSpan(start, leadingTriviaCodePoints) {
      start = start || this;
      var fullStart = start;

      if (leadingTriviaCodePoints) {
        while (this.diff(start) > 0 && leadingTriviaCodePoints.indexOf(start.peek()) !== -1) {
          if (fullStart === start) {
            start = start.clone();
          }

          start.advance();
        }
      }

      var startLocation = this.locationFromCursor(start);
      var endLocation = this.locationFromCursor(this);
      var fullStartLocation = fullStart !== start ? this.locationFromCursor(fullStart) : startLocation;
      return new ParseSourceSpan(startLocation, endLocation, fullStartLocation);
    }
  }, {
    key: "getChars",
    value: function getChars(start) {
      return this.input.substring(start.state.offset, this.state.offset);
    }
  }, {
    key: "charAt",
    value: function charAt(pos) {
      return this.input.charCodeAt(pos);
    }
  }, {
    key: "advanceState",
    value: function advanceState(state) {
      if (state.offset >= this.end) {
        this.state = state;
        throw new CursorError('Unexpected character "EOF"', this);
      }

      var currentChar = this.charAt(state.offset);

      if (currentChar === $LF) {
        state.line++;
        state.column = 0;
      } else if (!isNewLine(currentChar)) {
        state.column++;
      }

      state.offset++;
      this.updatePeek(state);
    }
  }, {
    key: "updatePeek",
    value: function updatePeek(state) {
      state.peek = state.offset >= this.end ? $EOF : this.charAt(state.offset);
    }
  }, {
    key: "locationFromCursor",
    value: function locationFromCursor(cursor) {
      return new ParseLocation(cursor.file, cursor.state.offset, cursor.state.line, cursor.state.column);
    }
  }]);

  return PlainCharacterCursor;
}();

var EscapedCharacterCursor = /*#__PURE__*/function (_PlainCharacterCursor) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(EscapedCharacterCursor, _PlainCharacterCursor);

  var _super73 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(EscapedCharacterCursor);

  function EscapedCharacterCursor(fileOrCursor, range) {
    var _this120;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, EscapedCharacterCursor);

    if (fileOrCursor instanceof EscapedCharacterCursor) {
      _this120 = _super73.call(this, fileOrCursor);
      _this120.internalState = Object.assign({}, fileOrCursor.internalState);
    } else {
      _this120 = _super73.call(this, fileOrCursor, range);
      _this120.internalState = _this120.state;
    }

    return (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_possibleConstructorReturn_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_this120);
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(EscapedCharacterCursor, [{
    key: "advance",
    value: function advance() {
      this.state = this.internalState;

      (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_5__["default"])((0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_6__["default"])(EscapedCharacterCursor.prototype), "advance", this).call(this);

      this.processEscapeSequence();
    }
  }, {
    key: "init",
    value: function init() {
      (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_5__["default"])((0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_6__["default"])(EscapedCharacterCursor.prototype), "init", this).call(this);

      this.processEscapeSequence();
    }
  }, {
    key: "clone",
    value: function clone() {
      return new EscapedCharacterCursor(this);
    }
  }, {
    key: "getChars",
    value: function getChars(start) {
      var cursor = start.clone();
      var chars = '';

      while (cursor.internalState.offset < this.internalState.offset) {
        chars += String.fromCodePoint(cursor.peek());
        cursor.advance();
      }

      return chars;
    }
    /**
     * Process the escape sequence that starts at the current position in the text.
     *
     * This method is called to ensure that `peek` has the unescaped value of escape sequences.
     */

  }, {
    key: "processEscapeSequence",
    value: function processEscapeSequence() {
      var _this121 = this;

      var peek = function peek() {
        return _this121.internalState.peek;
      };

      if (peek() === $BACKSLASH) {
        // We have hit an escape sequence so we need the internal state to become independent
        // of the external state.
        this.internalState = Object.assign({}, this.state); // Move past the backslash

        this.advanceState(this.internalState); // First check for standard control char sequences

        if (peek() === $n) {
          this.state.peek = $LF;
        } else if (peek() === $r) {
          this.state.peek = $CR;
        } else if (peek() === $v) {
          this.state.peek = $VTAB;
        } else if (peek() === $t) {
          this.state.peek = $TAB;
        } else if (peek() === $b) {
          this.state.peek = $BSPACE;
        } else if (peek() === $f) {
          this.state.peek = $FF;
        } // Now consider more complex sequences
        else if (peek() === $u) {
          // Unicode code-point sequence
          this.advanceState(this.internalState); // advance past the `u` char

          if (peek() === $LBRACE) {
            // Variable length Unicode, e.g. `\x{123}`
            this.advanceState(this.internalState); // advance past the `{` char
            // Advance past the variable number of hex digits until we hit a `}` char

            var digitStart = this.clone();
            var length = 0;

            while (peek() !== $RBRACE) {
              this.advanceState(this.internalState);
              length++;
            }

            this.state.peek = this.decodeHexDigits(digitStart, length);
          } else {
            // Fixed length Unicode, e.g. `\u1234`
            var _digitStart = this.clone();

            this.advanceState(this.internalState);
            this.advanceState(this.internalState);
            this.advanceState(this.internalState);
            this.state.peek = this.decodeHexDigits(_digitStart, 4);
          }
        } else if (peek() === $x) {
          // Hex char code, e.g. `\x2F`
          this.advanceState(this.internalState); // advance past the `x` char

          var _digitStart2 = this.clone();

          this.advanceState(this.internalState);
          this.state.peek = this.decodeHexDigits(_digitStart2, 2);
        } else if (isOctalDigit(peek())) {
          // Octal char code, e.g. `\012`,
          var octal = '';
          var _length = 0;
          var previous = this.clone();

          while (isOctalDigit(peek()) && _length < 3) {
            previous = this.clone();
            octal += String.fromCodePoint(peek());
            this.advanceState(this.internalState);
            _length++;
          }

          this.state.peek = parseInt(octal, 8); // Backup one char

          this.internalState = previous.internalState;
        } else if (isNewLine(this.internalState.peek)) {
          // Line continuation `\` followed by a new line
          this.advanceState(this.internalState); // advance over the newline

          this.state = this.internalState;
        } else {
          // If none of the `if` blocks were executed then we just have an escaped normal character.
          // In that case we just, effectively, skip the backslash from the character.
          this.state.peek = this.internalState.peek;
        }
      }
    }
  }, {
    key: "decodeHexDigits",
    value: function decodeHexDigits(start, length) {
      var hex = this.input.slice(start.internalState.offset, start.internalState.offset + length);
      var charCode = parseInt(hex, 16);

      if (!isNaN(charCode)) {
        return charCode;
      } else {
        start.state = start.internalState;
        throw new CursorError('Invalid hexadecimal escape sequence', start);
      }
    }
  }]);

  return EscapedCharacterCursor;
}(PlainCharacterCursor);

var CursorError = /*#__PURE__*/(0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(function CursorError(msg, cursor) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, CursorError);

  this.msg = msg;
  this.cursor = cursor;
});
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */


var TreeError = /*#__PURE__*/function (_ParseError2) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(TreeError, _ParseError2);

  var _super74 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(TreeError);

  function TreeError(elementName, span, msg) {
    var _this122;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, TreeError);

    _this122 = _super74.call(this, span, msg);
    _this122.elementName = elementName;
    return _this122;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(TreeError, null, [{
    key: "create",
    value: function create(elementName, span, msg) {
      return new TreeError(elementName, span, msg);
    }
  }]);

  return TreeError;
}(ParseError);

var ParseTreeResult = /*#__PURE__*/(0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(function ParseTreeResult(rootNodes, errors) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, ParseTreeResult);

  this.rootNodes = rootNodes;
  this.errors = errors;
});

var Parser = /*#__PURE__*/function () {
  function Parser(getTagDefinition) {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, Parser);

    this.getTagDefinition = getTagDefinition;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(Parser, [{
    key: "parse",
    value: function parse(source, url, options) {
      var tokenizeResult = tokenize(source, url, this.getTagDefinition, options);
      var parser = new _TreeBuilder(tokenizeResult.tokens, this.getTagDefinition);
      parser.build();
      return new ParseTreeResult(parser.rootNodes, tokenizeResult.errors.concat(parser.errors));
    }
  }]);

  return Parser;
}();

var _TreeBuilder = /*#__PURE__*/function () {
  function _TreeBuilder(tokens, getTagDefinition) {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, _TreeBuilder);

    this.tokens = tokens;
    this.getTagDefinition = getTagDefinition;
    this._index = -1;
    this._elementStack = [];
    this.rootNodes = [];
    this.errors = [];

    this._advance();
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(_TreeBuilder, [{
    key: "build",
    value: function build() {
      while (this._peek.type !== 24
      /* TokenType.EOF */
      ) {
        if (this._peek.type === 0
        /* TokenType.TAG_OPEN_START */
        || this._peek.type === 4
        /* TokenType.INCOMPLETE_TAG_OPEN */
        ) {
          this._consumeStartTag(this._advance());
        } else if (this._peek.type === 3
        /* TokenType.TAG_CLOSE */
        ) {
          this._consumeEndTag(this._advance());
        } else if (this._peek.type === 12
        /* TokenType.CDATA_START */
        ) {
          this._closeVoidElement();

          this._consumeCdata(this._advance());
        } else if (this._peek.type === 10
        /* TokenType.COMMENT_START */
        ) {
          this._closeVoidElement();

          this._consumeComment(this._advance());
        } else if (this._peek.type === 5
        /* TokenType.TEXT */
        || this._peek.type === 7
        /* TokenType.RAW_TEXT */
        || this._peek.type === 6
        /* TokenType.ESCAPABLE_RAW_TEXT */
        ) {
          this._closeVoidElement();

          this._consumeText(this._advance());
        } else if (this._peek.type === 19
        /* TokenType.EXPANSION_FORM_START */
        ) {
          this._consumeExpansion(this._advance());
        } else {
          // Skip all other tokens...
          this._advance();
        }
      }
    }
  }, {
    key: "_advance",
    value: function _advance() {
      var prev = this._peek;

      if (this._index < this.tokens.length - 1) {
        // Note: there is always an EOF token at the end
        this._index++;
      }

      this._peek = this.tokens[this._index];
      return prev;
    }
  }, {
    key: "_advanceIf",
    value: function _advanceIf(type) {
      if (this._peek.type === type) {
        return this._advance();
      }

      return null;
    }
  }, {
    key: "_consumeCdata",
    value: function _consumeCdata(_startToken) {
      this._consumeText(this._advance());

      this._advanceIf(13
      /* TokenType.CDATA_END */
      );
    }
  }, {
    key: "_consumeComment",
    value: function _consumeComment(token) {
      var text = this._advanceIf(7
      /* TokenType.RAW_TEXT */
      );

      this._advanceIf(11
      /* TokenType.COMMENT_END */
      );

      var value = text != null ? text.parts[0].trim() : null;

      this._addToParent(new Comment(value, token.sourceSpan));
    }
  }, {
    key: "_consumeExpansion",
    value: function _consumeExpansion(token) {
      var switchValue = this._advance();

      var type = this._advance();

      var cases = []; // read =

      while (this._peek.type === 20
      /* TokenType.EXPANSION_CASE_VALUE */
      ) {
        var expCase = this._parseExpansionCase();

        if (!expCase) return; // error

        cases.push(expCase);
      } // read the final }


      if (this._peek.type !== 23
      /* TokenType.EXPANSION_FORM_END */
      ) {
        this.errors.push(TreeError.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '}'."));
        return;
      }

      var sourceSpan = new ParseSourceSpan(token.sourceSpan.start, this._peek.sourceSpan.end, token.sourceSpan.fullStart);

      this._addToParent(new Expansion(switchValue.parts[0], type.parts[0], cases, sourceSpan, switchValue.sourceSpan));

      this._advance();
    }
  }, {
    key: "_parseExpansionCase",
    value: function _parseExpansionCase() {
      var value = this._advance(); // read {


      if (this._peek.type !== 21
      /* TokenType.EXPANSION_CASE_EXP_START */
      ) {
        this.errors.push(TreeError.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '{'."));
        return null;
      } // read until }


      var start = this._advance();

      var exp = this._collectExpansionExpTokens(start);

      if (!exp) return null;

      var end = this._advance();

      exp.push({
        type: 24
        /* TokenType.EOF */
        ,
        parts: [],
        sourceSpan: end.sourceSpan
      }); // parse everything in between { and }

      var expansionCaseParser = new _TreeBuilder(exp, this.getTagDefinition);
      expansionCaseParser.build();

      if (expansionCaseParser.errors.length > 0) {
        this.errors = this.errors.concat(expansionCaseParser.errors);
        return null;
      }

      var sourceSpan = new ParseSourceSpan(value.sourceSpan.start, end.sourceSpan.end, value.sourceSpan.fullStart);
      var expSourceSpan = new ParseSourceSpan(start.sourceSpan.start, end.sourceSpan.end, start.sourceSpan.fullStart);
      return new ExpansionCase(value.parts[0], expansionCaseParser.rootNodes, sourceSpan, value.sourceSpan, expSourceSpan);
    }
  }, {
    key: "_collectExpansionExpTokens",
    value: function _collectExpansionExpTokens(start) {
      var exp = [];
      var expansionFormStack = [21
      /* TokenType.EXPANSION_CASE_EXP_START */
      ];

      while (true) {
        if (this._peek.type === 19
        /* TokenType.EXPANSION_FORM_START */
        || this._peek.type === 21
        /* TokenType.EXPANSION_CASE_EXP_START */
        ) {
          expansionFormStack.push(this._peek.type);
        }

        if (this._peek.type === 22
        /* TokenType.EXPANSION_CASE_EXP_END */
        ) {
          if (lastOnStack(expansionFormStack, 21
          /* TokenType.EXPANSION_CASE_EXP_START */
          )) {
            expansionFormStack.pop();
            if (expansionFormStack.length === 0) return exp;
          } else {
            this.errors.push(TreeError.create(null, start.sourceSpan, "Invalid ICU message. Missing '}'."));
            return null;
          }
        }

        if (this._peek.type === 23
        /* TokenType.EXPANSION_FORM_END */
        ) {
          if (lastOnStack(expansionFormStack, 19
          /* TokenType.EXPANSION_FORM_START */
          )) {
            expansionFormStack.pop();
          } else {
            this.errors.push(TreeError.create(null, start.sourceSpan, "Invalid ICU message. Missing '}'."));
            return null;
          }
        }

        if (this._peek.type === 24
        /* TokenType.EOF */
        ) {
          this.errors.push(TreeError.create(null, start.sourceSpan, "Invalid ICU message. Missing '}'."));
          return null;
        }

        exp.push(this._advance());
      }
    }
  }, {
    key: "_consumeText",
    value: function _consumeText(token) {
      var tokens = [token];
      var startSpan = token.sourceSpan;
      var text = token.parts[0];

      if (text.length > 0 && text[0] === '\n') {
        var parent = this._getParentElement();

        if (parent != null && parent.children.length === 0 && this.getTagDefinition(parent.name).ignoreFirstLf) {
          text = text.substring(1);
          tokens[0] = {
            type: token.type,
            sourceSpan: token.sourceSpan,
            parts: [text]
          };
        }
      }

      while (this._peek.type === 8
      /* TokenType.INTERPOLATION */
      || this._peek.type === 5
      /* TokenType.TEXT */
      || this._peek.type === 9
      /* TokenType.ENCODED_ENTITY */
      ) {
        token = this._advance();
        tokens.push(token);

        if (token.type === 8
        /* TokenType.INTERPOLATION */
        ) {
          // For backward compatibility we decode HTML entities that appear in interpolation
          // expressions. This is arguably a bug, but it could be a considerable breaking change to
          // fix it. It should be addressed in a larger project to refactor the entire parser/lexer
          // chain after View Engine has been removed.
          text += token.parts.join('').replace(/&([^;]+);/g, decodeEntity);
        } else if (token.type === 9
        /* TokenType.ENCODED_ENTITY */
        ) {
          text += token.parts[0];
        } else {
          text += token.parts.join('');
        }
      }

      if (text.length > 0) {
        var endSpan = token.sourceSpan;

        this._addToParent(new Text(text, new ParseSourceSpan(startSpan.start, endSpan.end, startSpan.fullStart, startSpan.details), tokens));
      }
    }
  }, {
    key: "_closeVoidElement",
    value: function _closeVoidElement() {
      var el = this._getParentElement();

      if (el && this.getTagDefinition(el.name).isVoid) {
        this._elementStack.pop();
      }
    }
  }, {
    key: "_consumeStartTag",
    value: function _consumeStartTag(startTagToken) {
      var _startTagToken$parts = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_slicedToArray_js__WEBPACK_IMPORTED_MODULE_3__["default"])(startTagToken.parts, 2),
          prefix = _startTagToken$parts[0],
          name = _startTagToken$parts[1];

      var attrs = [];

      while (this._peek.type === 14
      /* TokenType.ATTR_NAME */
      ) {
        attrs.push(this._consumeAttr(this._advance()));
      }

      var fullName = this._getElementFullName(prefix, name, this._getParentElement());

      var selfClosing = false; // Note: There could have been a tokenizer error
      // so that we don't get a token for the end tag...

      if (this._peek.type === 2
      /* TokenType.TAG_OPEN_END_VOID */
      ) {
        this._advance();

        selfClosing = true;
        var tagDef = this.getTagDefinition(fullName);

        if (!(tagDef.canSelfClose || getNsPrefix(fullName) !== null || tagDef.isVoid)) {
          this.errors.push(TreeError.create(fullName, startTagToken.sourceSpan, "Only void and foreign elements can be self closed \"".concat(startTagToken.parts[1], "\"")));
        }
      } else if (this._peek.type === 1
      /* TokenType.TAG_OPEN_END */
      ) {
        this._advance();

        selfClosing = false;
      }

      var end = this._peek.sourceSpan.fullStart;
      var span = new ParseSourceSpan(startTagToken.sourceSpan.start, end, startTagToken.sourceSpan.fullStart); // Create a separate `startSpan` because `span` will be modified when there is an `end` span.

      var startSpan = new ParseSourceSpan(startTagToken.sourceSpan.start, end, startTagToken.sourceSpan.fullStart);
      var el = new Element(fullName, attrs, [], span, startSpan, undefined);

      this._pushElement(el);

      if (selfClosing) {
        // Elements that are self-closed have their `endSourceSpan` set to the full span, as the
        // element start tag also represents the end tag.
        this._popElement(fullName, span);
      } else if (startTagToken.type === 4
      /* TokenType.INCOMPLETE_TAG_OPEN */
      ) {
        // We already know the opening tag is not complete, so it is unlikely it has a corresponding
        // close tag. Let's optimistically parse it as a full element and emit an error.
        this._popElement(fullName, null);

        this.errors.push(TreeError.create(fullName, span, "Opening tag \"".concat(fullName, "\" not terminated.")));
      }
    }
  }, {
    key: "_pushElement",
    value: function _pushElement(el) {
      var parentEl = this._getParentElement();

      if (parentEl && this.getTagDefinition(parentEl.name).isClosedByChild(el.name)) {
        this._elementStack.pop();
      }

      this._addToParent(el);

      this._elementStack.push(el);
    }
  }, {
    key: "_consumeEndTag",
    value: function _consumeEndTag(endTagToken) {
      var fullName = this._getElementFullName(endTagToken.parts[0], endTagToken.parts[1], this._getParentElement());

      if (this.getTagDefinition(fullName).isVoid) {
        this.errors.push(TreeError.create(fullName, endTagToken.sourceSpan, "Void elements do not have end tags \"".concat(endTagToken.parts[1], "\"")));
      } else if (!this._popElement(fullName, endTagToken.sourceSpan)) {
        var errMsg = "Unexpected closing tag \"".concat(fullName, "\". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags");
        this.errors.push(TreeError.create(fullName, endTagToken.sourceSpan, errMsg));
      }
    }
    /**
     * Closes the nearest element with the tag name `fullName` in the parse tree.
     * `endSourceSpan` is the span of the closing tag, or null if the element does
     * not have a closing tag (for example, this happens when an incomplete
     * opening tag is recovered).
     */

  }, {
    key: "_popElement",
    value: function _popElement(fullName, endSourceSpan) {
      var unexpectedCloseTagDetected = false;

      for (var stackIndex = this._elementStack.length - 1; stackIndex >= 0; stackIndex--) {
        var el = this._elementStack[stackIndex];

        if (el.name === fullName) {
          // Record the parse span with the element that is being closed. Any elements that are
          // removed from the element stack at this point are closed implicitly, so they won't get
          // an end source span (as there is no explicit closing element).
          el.endSourceSpan = endSourceSpan;
          el.sourceSpan.end = endSourceSpan !== null ? endSourceSpan.end : el.sourceSpan.end;

          this._elementStack.splice(stackIndex, this._elementStack.length - stackIndex);

          return !unexpectedCloseTagDetected;
        }

        if (!this.getTagDefinition(el.name).closedByParent) {
          // Note that we encountered an unexpected close tag but continue processing the element
          // stack so we can assign an `endSourceSpan` if there is a corresponding start tag for this
          // end tag in the stack.
          unexpectedCloseTagDetected = true;
        }
      }

      return false;
    }
  }, {
    key: "_consumeAttr",
    value: function _consumeAttr(attrName) {
      var fullName = mergeNsAndName(attrName.parts[0], attrName.parts[1]);
      var attrEnd = attrName.sourceSpan.end; // Consume any quote

      if (this._peek.type === 15
      /* TokenType.ATTR_QUOTE */
      ) {
        this._advance();
      } // Consume the attribute value


      var value = '';
      var valueTokens = [];
      var valueStartSpan = undefined;
      var valueEnd = undefined; // NOTE: We need to use a new variable `nextTokenType` here to hide the actual type of
      // `_peek.type` from TS. Otherwise TS will narrow the type of `_peek.type` preventing it from
      // being able to consider `ATTR_VALUE_INTERPOLATION` as an option. This is because TS is not
      // able to see that `_advance()` will actually mutate `_peek`.

      var nextTokenType = this._peek.type;

      if (nextTokenType === 16
      /* TokenType.ATTR_VALUE_TEXT */
      ) {
        valueStartSpan = this._peek.sourceSpan;
        valueEnd = this._peek.sourceSpan.end;

        while (this._peek.type === 16
        /* TokenType.ATTR_VALUE_TEXT */
        || this._peek.type === 17
        /* TokenType.ATTR_VALUE_INTERPOLATION */
        || this._peek.type === 9
        /* TokenType.ENCODED_ENTITY */
        ) {
          var valueToken = this._advance();

          valueTokens.push(valueToken);

          if (valueToken.type === 17
          /* TokenType.ATTR_VALUE_INTERPOLATION */
          ) {
            // For backward compatibility we decode HTML entities that appear in interpolation
            // expressions. This is arguably a bug, but it could be a considerable breaking change to
            // fix it. It should be addressed in a larger project to refactor the entire parser/lexer
            // chain after View Engine has been removed.
            value += valueToken.parts.join('').replace(/&([^;]+);/g, decodeEntity);
          } else if (valueToken.type === 9
          /* TokenType.ENCODED_ENTITY */
          ) {
            value += valueToken.parts[0];
          } else {
            value += valueToken.parts.join('');
          }

          valueEnd = attrEnd = valueToken.sourceSpan.end;
        }
      } // Consume any quote


      if (this._peek.type === 15
      /* TokenType.ATTR_QUOTE */
      ) {
        var quoteToken = this._advance();

        attrEnd = quoteToken.sourceSpan.end;
      }

      var valueSpan = valueStartSpan && valueEnd && new ParseSourceSpan(valueStartSpan.start, valueEnd, valueStartSpan.fullStart);
      return new Attribute(fullName, value, new ParseSourceSpan(attrName.sourceSpan.start, attrEnd, attrName.sourceSpan.fullStart), attrName.sourceSpan, valueSpan, valueTokens.length > 0 ? valueTokens : undefined, undefined);
    }
  }, {
    key: "_getParentElement",
    value: function _getParentElement() {
      return this._elementStack.length > 0 ? this._elementStack[this._elementStack.length - 1] : null;
    }
  }, {
    key: "_addToParent",
    value: function _addToParent(node) {
      var parent = this._getParentElement();

      if (parent != null) {
        parent.children.push(node);
      } else {
        this.rootNodes.push(node);
      }
    }
  }, {
    key: "_getElementFullName",
    value: function _getElementFullName(prefix, localName, parentElement) {
      if (prefix === '') {
        prefix = this.getTagDefinition(localName).implicitNamespacePrefix || '';

        if (prefix === '' && parentElement != null) {
          var parentTagName = splitNsName(parentElement.name)[1];
          var parentTagDefinition = this.getTagDefinition(parentTagName);

          if (!parentTagDefinition.preventNamespaceInheritance) {
            prefix = getNsPrefix(parentElement.name);
          }
        }
      }

      return mergeNsAndName(prefix, localName);
    }
  }]);

  return _TreeBuilder;
}();

function lastOnStack(stack, element) {
  return stack.length > 0 && stack[stack.length - 1] === element;
}
/**
 * Decode the `entity` string, which we believe is the contents of an HTML entity.
 *
 * If the string is not actually a valid/known entity then just return the original `match` string.
 */


function decodeEntity(match, entity) {
  if (NAMED_ENTITIES[entity] !== undefined) {
    return NAMED_ENTITIES[entity] || match;
  }

  if (/^#x[a-f0-9]+$/i.test(entity)) {
    return String.fromCodePoint(parseInt(entity.slice(2), 16));
  }

  if (/^#\d+$/.test(entity)) {
    return String.fromCodePoint(parseInt(entity.slice(1), 10));
  }

  return match;
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */


var HtmlParser = /*#__PURE__*/function (_Parser) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(HtmlParser, _Parser);

  var _super75 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(HtmlParser);

  function HtmlParser() {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, HtmlParser);

    return _super75.call(this, getHtmlTagDefinition);
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(HtmlParser, [{
    key: "parse",
    value: function parse(source, url, options) {
      return (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_5__["default"])((0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_6__["default"])(HtmlParser.prototype), "parse", this).call(this, source, url, options);
    }
  }]);

  return HtmlParser;
}(Parser);
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */


var PRESERVE_WS_ATTR_NAME = 'ngPreserveWhitespaces';
var SKIP_WS_TRIM_TAGS = new Set(['pre', 'template', 'textarea', 'script', 'style']); // Equivalent to \s with \u00a0 (non-breaking space) excluded.
// Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp

var WS_CHARS = " \f\n\r\t\x0B\u1680\u180E\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF";
var NO_WS_REGEXP = new RegExp("[^".concat(WS_CHARS, "]"));
var WS_REPLACE_REGEXP = new RegExp("[".concat(WS_CHARS, "]{2,}"), 'g');

function hasPreserveWhitespacesAttr(attrs) {
  return attrs.some(function (attr) {
    return attr.name === PRESERVE_WS_ATTR_NAME;
  });
}
/**
 * Angular Dart introduced &ngsp; as a placeholder for non-removable space, see:
 * https://github.com/dart-lang/angular/blob/0bb611387d29d65b5af7f9d2515ab571fd3fbee4/_tests/test/compiler/preserve_whitespace_test.dart#L25-L32
 * In Angular Dart &ngsp; is converted to the 0xE500 PUA (Private Use Areas) unicode character
 * and later on replaced by a space. We are re-implementing the same idea here.
 */


function replaceNgsp(value) {
  // lexer is replacing the &ngsp; pseudo-entity with NGSP_UNICODE
  return value.replace(new RegExp(NGSP_UNICODE, 'g'), ' ');
}
/**
 * This visitor can walk HTML parse tree and remove / trim text nodes using the following rules:
 * - consider spaces, tabs and new lines as whitespace characters;
 * - drop text nodes consisting of whitespace characters only;
 * - for all other text nodes replace consecutive whitespace characters with one space;
 * - convert &ngsp; pseudo-entity to a single space;
 *
 * Removal and trimming of whitespaces have positive performance impact (less code to generate
 * while compiling templates, faster view creation). At the same time it can be "destructive"
 * in some cases (whitespaces can influence layout). Because of the potential of breaking layout
 * this visitor is not activated by default in Angular 5 and people need to explicitly opt-in for
 * whitespace removal. The default option for whitespace removal will be revisited in Angular 6
 * and might be changed to "on" by default.
 */


var WhitespaceVisitor = /*#__PURE__*/function () {
  function WhitespaceVisitor() {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, WhitespaceVisitor);
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(WhitespaceVisitor, [{
    key: "visitElement",
    value: function visitElement(element, context) {
      if (SKIP_WS_TRIM_TAGS.has(element.name) || hasPreserveWhitespacesAttr(element.attrs)) {
        // don't descent into elements where we need to preserve whitespaces
        // but still visit all attributes to eliminate one used as a market to preserve WS
        return new Element(element.name, visitAll(this, element.attrs), element.children, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);
      }

      return new Element(element.name, element.attrs, visitAllWithSiblings(this, element.children), element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);
    }
  }, {
    key: "visitAttribute",
    value: function visitAttribute(attribute, context) {
      return attribute.name !== PRESERVE_WS_ATTR_NAME ? attribute : null;
    }
  }, {
    key: "visitText",
    value: function visitText(text, context) {
      var isNotBlank = text.value.match(NO_WS_REGEXP);
      var hasExpansionSibling = context && (context.prev instanceof Expansion || context.next instanceof Expansion);

      if (isNotBlank || hasExpansionSibling) {
        // Process the whitespace in the tokens of this Text node
        var tokens = text.tokens.map(function (token) {
          return token.type === 5
          /* TokenType.TEXT */
          ? createWhitespaceProcessedTextToken(token) : token;
        }); // Process the whitespace of the value of this Text node

        var value = processWhitespace(text.value);
        return new Text(value, text.sourceSpan, tokens, text.i18n);
      }

      return null;
    }
  }, {
    key: "visitComment",
    value: function visitComment(comment, context) {
      return comment;
    }
  }, {
    key: "visitExpansion",
    value: function visitExpansion(expansion, context) {
      return expansion;
    }
  }, {
    key: "visitExpansionCase",
    value: function visitExpansionCase(expansionCase, context) {
      return expansionCase;
    }
  }]);

  return WhitespaceVisitor;
}();

function createWhitespaceProcessedTextToken(_ref7) {
  var type = _ref7.type,
      parts = _ref7.parts,
      sourceSpan = _ref7.sourceSpan;
  return {
    type: type,
    parts: [processWhitespace(parts[0])],
    sourceSpan: sourceSpan
  };
}

function processWhitespace(text) {
  return replaceNgsp(text).replace(WS_REPLACE_REGEXP, ' ');
}

function removeWhitespaces(htmlAstWithErrors) {
  return new ParseTreeResult(visitAll(new WhitespaceVisitor(), htmlAstWithErrors.rootNodes), htmlAstWithErrors.errors);
}

function visitAllWithSiblings(visitor, nodes) {
  var result = [];
  nodes.forEach(function (ast, i) {
    var context = {
      prev: nodes[i - 1],
      next: nodes[i + 1]
    };
    var astResult = ast.visit(visitor, context);

    if (astResult) {
      result.push(astResult);
    }
  });
  return result;
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */


function mapEntry(key, value) {
  return {
    key: key,
    value: value,
    quoted: false
  };
}

function mapLiteral(obj) {
  var quoted = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  return literalMap(Object.keys(obj).map(function (key) {
    return {
      key: key,
      quoted: quoted,
      value: obj[key]
    };
  }));
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
// =================================================================================================
// =================================================================================================
// =========== S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P  ===========
// =================================================================================================
// =================================================================================================
//
//        DO NOT EDIT THIS LIST OF SECURITY SENSITIVE PROPERTIES WITHOUT A SECURITY REVIEW!
//                               Reach out to mprobst for details.
//
// =================================================================================================

/** Map from tagName|propertyName to SecurityContext. Properties applying to all tags use '*'. */


var _SECURITY_SCHEMA;

function SECURITY_SCHEMA() {
  if (!_SECURITY_SCHEMA) {
    _SECURITY_SCHEMA = {}; // Case is insignificant below, all element and attribute names are lower-cased for lookup.

    registerContext(SecurityContext.HTML, ['iframe|srcdoc', '*|innerHTML', '*|outerHTML']);
    registerContext(SecurityContext.STYLE, ['*|style']); // NB: no SCRIPT contexts here, they are never allowed due to the parser stripping them.

    registerContext(SecurityContext.URL, ['*|formAction', 'area|href', 'area|ping', 'audio|src', 'a|href', 'a|ping', 'blockquote|cite', 'body|background', 'del|cite', 'form|action', 'img|src', 'img|srcset', 'input|src', 'ins|cite', 'q|cite', 'source|src', 'source|srcset', 'track|src', 'video|poster', 'video|src']);
    registerContext(SecurityContext.RESOURCE_URL, ['applet|code', 'applet|codebase', 'base|href', 'embed|src', 'frame|src', 'head|profile', 'html|manifest', 'iframe|src', 'link|href', 'media|src', 'object|codebase', 'object|data', 'script|src']);
  }

  return _SECURITY_SCHEMA;
}

function registerContext(ctx, specs) {
  var _iterator12 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper_js__WEBPACK_IMPORTED_MODULE_9__["default"])(specs),
      _step12;

  try {
    for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
      var spec = _step12.value;
      _SECURITY_SCHEMA[spec.toLowerCase()] = ctx;
    }
  } catch (err) {
    _iterator12.e(err);
  } finally {
    _iterator12.f();
  }
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */


var ElementSchemaRegistry = /*#__PURE__*/(0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(function ElementSchemaRegistry() {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, ElementSchemaRegistry);
});
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */


var EVENT = 'event';
var BOOLEAN = 'boolean';
var NUMBER = 'number';
var STRING = 'string';
var OBJECT = 'object';
/**
 * This array represents the DOM schema. It encodes inheritance, properties, and events.
 *
 * ## Overview
 *
 * Each line represents one kind of element. The `element_inheritance` and properties are joined
 * using `element_inheritance|properties` syntax.
 *
 * ## Element Inheritance
 *
 * The `element_inheritance` can be further subdivided as `element1,element2,...^parentElement`.
 * Here the individual elements are separated by `,` (commas). Every element in the list
 * has identical properties.
 *
 * An `element` may inherit additional properties from `parentElement` If no `^parentElement` is
 * specified then `""` (blank) element is assumed.
 *
 * NOTE: The blank element inherits from root `[Element]` element, the super element of all
 * elements.
 *
 * NOTE an element prefix such as `:svg:` has no special meaning to the schema.
 *
 * ## Properties
 *
 * Each element has a set of properties separated by `,` (commas). Each property can be prefixed
 * by a special character designating its type:
 *
 * - (no prefix): property is a string.
 * - `*`: property represents an event.
 * - `!`: property is a boolean.
 * - `#`: property is a number.
 * - `%`: property is an object.
 *
 * ## Query
 *
 * The class creates an internal squas representation which allows to easily answer the query of
 * if a given property exist on a given element.
 *
 * NOTE: We don't yet support querying for types or events.
 * NOTE: This schema is auto extracted from `schema_extractor.ts` located in the test folder,
 *       see dom_element_schema_registry_spec.ts
 */
// =================================================================================================
// =================================================================================================
// =========== S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P  ===========
// =================================================================================================
// =================================================================================================
//
//                       DO NOT EDIT THIS DOM SCHEMA WITHOUT A SECURITY REVIEW!
//
// Newly added properties must be security reviewed and assigned an appropriate SecurityContext in
// dom_security_schema.ts. Reach out to mprobst & rjamet for details.
//
// =================================================================================================

var SCHEMA = ['[Element]|textContent,%classList,className,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*copy,*cut,*paste,*search,*selectstart,*webkitfullscreenchange,*webkitfullscreenerror,*wheel,outerHTML,#scrollLeft,#scrollTop,slot' +
/* added manually to avoid breaking changes */
',*message,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored', '[HTMLElement]^[Element]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,outerText,!spellcheck,%style,#tabIndex,title,!translate', 'abbr,address,article,aside,b,bdi,bdo,cite,code,dd,dfn,dt,em,figcaption,figure,footer,header,i,kbd,main,mark,nav,noscript,rb,rp,rt,rtc,ruby,s,samp,section,small,strong,sub,sup,u,var,wbr^[HTMLElement]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,outerText,!spellcheck,%style,#tabIndex,title,!translate', 'media^[HTMLElement]|!autoplay,!controls,%controlsList,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,*waitingforkey,#playbackRate,preload,src,%srcObject,#volume', ':svg:^[HTMLElement]|*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,%style,#tabIndex', ':svg:graphics^:svg:|', ':svg:animation^:svg:|*begin,*end,*repeat', ':svg:geometry^:svg:|', ':svg:componentTransferFunction^:svg:|', ':svg:gradient^:svg:|', ':svg:textContent^:svg:graphics|', ':svg:textPositioning^:svg:textContent|', 'a^[HTMLElement]|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,referrerPolicy,rel,rev,search,shape,target,text,type,username', 'area^[HTMLElement]|alt,coords,download,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,referrerPolicy,rel,search,shape,target,username', 'audio^media|', 'br^[HTMLElement]|clear', 'base^[HTMLElement]|href,target', 'body^[HTMLElement]|aLink,background,bgColor,link,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink', 'button^[HTMLElement]|!autofocus,!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value', 'canvas^[HTMLElement]|#height,#width', 'content^[HTMLElement]|select', 'dl^[HTMLElement]|!compact', 'datalist^[HTMLElement]|', 'details^[HTMLElement]|!open', 'dialog^[HTMLElement]|!open,returnValue', 'dir^[HTMLElement]|!compact', 'div^[HTMLElement]|align', 'embed^[HTMLElement]|align,height,name,src,type,width', 'fieldset^[HTMLElement]|!disabled,name', 'font^[HTMLElement]|color,face,size', 'form^[HTMLElement]|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target', 'frame^[HTMLElement]|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src', 'frameset^[HTMLElement]|cols,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows', 'hr^[HTMLElement]|align,color,!noShade,size,width', 'head^[HTMLElement]|', 'h1,h2,h3,h4,h5,h6^[HTMLElement]|align', 'html^[HTMLElement]|version', 'iframe^[HTMLElement]|align,!allowFullscreen,frameBorder,height,longDesc,marginHeight,marginWidth,name,referrerPolicy,%sandbox,scrolling,src,srcdoc,width', 'img^[HTMLElement]|align,alt,border,%crossOrigin,#height,#hspace,!isMap,longDesc,lowsrc,name,referrerPolicy,sizes,src,srcset,useMap,#vspace,#width', 'input^[HTMLElement]|accept,align,alt,autocapitalize,autocomplete,!autofocus,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width', 'li^[HTMLElement]|type,#value', 'label^[HTMLElement]|htmlFor', 'legend^[HTMLElement]|align', 'link^[HTMLElement]|as,charset,%crossOrigin,!disabled,href,hreflang,integrity,media,referrerPolicy,rel,%relList,rev,%sizes,target,type', 'map^[HTMLElement]|name', 'marquee^[HTMLElement]|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width', 'menu^[HTMLElement]|!compact', 'meta^[HTMLElement]|content,httpEquiv,name,scheme', 'meter^[HTMLElement]|#high,#low,#max,#min,#optimum,#value', 'ins,del^[HTMLElement]|cite,dateTime', 'ol^[HTMLElement]|!compact,!reversed,#start,type', 'object^[HTMLElement]|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width', 'optgroup^[HTMLElement]|!disabled,label', 'option^[HTMLElement]|!defaultSelected,!disabled,label,!selected,text,value', 'output^[HTMLElement]|defaultValue,%htmlFor,name,value', 'p^[HTMLElement]|align', 'param^[HTMLElement]|name,type,value,valueType', 'picture^[HTMLElement]|', 'pre^[HTMLElement]|#width', 'progress^[HTMLElement]|#max,#value', 'q,blockquote,cite^[HTMLElement]|', 'script^[HTMLElement]|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,src,text,type', 'select^[HTMLElement]|autocomplete,!autofocus,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value', 'shadow^[HTMLElement]|', 'slot^[HTMLElement]|name', 'source^[HTMLElement]|media,sizes,src,srcset,type', 'span^[HTMLElement]|', 'style^[HTMLElement]|!disabled,media,type', 'caption^[HTMLElement]|align', 'th,td^[HTMLElement]|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width', 'col,colgroup^[HTMLElement]|align,ch,chOff,#span,vAlign,width', 'table^[HTMLElement]|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width', 'tr^[HTMLElement]|align,bgColor,ch,chOff,vAlign', 'tfoot,thead,tbody^[HTMLElement]|align,ch,chOff,vAlign', 'template^[HTMLElement]|', 'textarea^[HTMLElement]|autocapitalize,autocomplete,!autofocus,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap', 'title^[HTMLElement]|text', 'track^[HTMLElement]|!default,kind,label,src,srclang', 'ul^[HTMLElement]|!compact,type', 'unknown^[HTMLElement]|', 'video^media|#height,poster,#width', ':svg:a^:svg:graphics|', ':svg:animate^:svg:animation|', ':svg:animateMotion^:svg:animation|', ':svg:animateTransform^:svg:animation|', ':svg:circle^:svg:geometry|', ':svg:clipPath^:svg:graphics|', ':svg:defs^:svg:graphics|', ':svg:desc^:svg:|', ':svg:discard^:svg:|', ':svg:ellipse^:svg:geometry|', ':svg:feBlend^:svg:|', ':svg:feColorMatrix^:svg:|', ':svg:feComponentTransfer^:svg:|', ':svg:feComposite^:svg:|', ':svg:feConvolveMatrix^:svg:|', ':svg:feDiffuseLighting^:svg:|', ':svg:feDisplacementMap^:svg:|', ':svg:feDistantLight^:svg:|', ':svg:feDropShadow^:svg:|', ':svg:feFlood^:svg:|', ':svg:feFuncA^:svg:componentTransferFunction|', ':svg:feFuncB^:svg:componentTransferFunction|', ':svg:feFuncG^:svg:componentTransferFunction|', ':svg:feFuncR^:svg:componentTransferFunction|', ':svg:feGaussianBlur^:svg:|', ':svg:feImage^:svg:|', ':svg:feMerge^:svg:|', ':svg:feMergeNode^:svg:|', ':svg:feMorphology^:svg:|', ':svg:feOffset^:svg:|', ':svg:fePointLight^:svg:|', ':svg:feSpecularLighting^:svg:|', ':svg:feSpotLight^:svg:|', ':svg:feTile^:svg:|', ':svg:feTurbulence^:svg:|', ':svg:filter^:svg:|', ':svg:foreignObject^:svg:graphics|', ':svg:g^:svg:graphics|', ':svg:image^:svg:graphics|', ':svg:line^:svg:geometry|', ':svg:linearGradient^:svg:gradient|', ':svg:mpath^:svg:|', ':svg:marker^:svg:|', ':svg:mask^:svg:|', ':svg:metadata^:svg:|', ':svg:path^:svg:geometry|', ':svg:pattern^:svg:|', ':svg:polygon^:svg:geometry|', ':svg:polyline^:svg:geometry|', ':svg:radialGradient^:svg:gradient|', ':svg:rect^:svg:geometry|', ':svg:svg^:svg:graphics|#currentScale,#zoomAndPan', ':svg:script^:svg:|type', ':svg:set^:svg:animation|', ':svg:stop^:svg:|', ':svg:style^:svg:|!disabled,media,title,type', ':svg:switch^:svg:graphics|', ':svg:symbol^:svg:|', ':svg:tspan^:svg:textPositioning|', ':svg:text^:svg:textPositioning|', ':svg:textPath^:svg:textContent|', ':svg:title^:svg:|', ':svg:use^:svg:graphics|', ':svg:view^:svg:|#zoomAndPan', 'data^[HTMLElement]|value', 'keygen^[HTMLElement]|!autofocus,challenge,!disabled,form,keytype,name', 'menuitem^[HTMLElement]|type,label,icon,!disabled,!checked,radiogroup,!default', 'summary^[HTMLElement]|', 'time^[HTMLElement]|dateTime', ':svg:cursor^:svg:|'];
var _ATTR_TO_PROP = {
  'class': 'className',
  'for': 'htmlFor',
  'formaction': 'formAction',
  'innerHtml': 'innerHTML',
  'readonly': 'readOnly',
  'tabindex': 'tabIndex'
}; // Invert _ATTR_TO_PROP.

var _PROP_TO_ATTR = Object.keys(_ATTR_TO_PROP).reduce(function (inverted, attr) {
  inverted[_ATTR_TO_PROP[attr]] = attr;
  return inverted;
}, {});

var DomElementSchemaRegistry = /*#__PURE__*/function (_ElementSchemaRegistr) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(DomElementSchemaRegistry, _ElementSchemaRegistr);

  var _super76 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(DomElementSchemaRegistry);

  function DomElementSchemaRegistry() {
    var _this123;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, DomElementSchemaRegistry);

    _this123 = _super76.call(this);
    _this123._schema = {}; // We don't allow binding to events for security reasons. Allowing event bindings would almost
    // certainly introduce bad XSS vulnerabilities. Instead, we store events in a separate schema.

    _this123._eventSchema = {};
    SCHEMA.forEach(function (encodedType) {
      var type = {};
      var events = new Set();

      var _encodedType$split = encodedType.split('|'),
          _encodedType$split2 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_slicedToArray_js__WEBPACK_IMPORTED_MODULE_3__["default"])(_encodedType$split, 2),
          strType = _encodedType$split2[0],
          strProperties = _encodedType$split2[1];

      var properties = strProperties.split(',');

      var _strType$split = strType.split('^'),
          _strType$split2 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_slicedToArray_js__WEBPACK_IMPORTED_MODULE_3__["default"])(_strType$split, 2),
          typeNames = _strType$split2[0],
          superName = _strType$split2[1];

      typeNames.split(',').forEach(function (tag) {
        _this123._schema[tag.toLowerCase()] = type;
        _this123._eventSchema[tag.toLowerCase()] = events;
      });

      var superType = superName && _this123._schema[superName.toLowerCase()];

      if (superType) {
        Object.keys(superType).forEach(function (prop) {
          type[prop] = superType[prop];
        });

        var _iterator13 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper_js__WEBPACK_IMPORTED_MODULE_9__["default"])(_this123._eventSchema[superName.toLowerCase()]),
            _step13;

        try {
          for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
            var superEvent = _step13.value;
            events.add(superEvent);
          }
        } catch (err) {
          _iterator13.e(err);
        } finally {
          _iterator13.f();
        }
      }

      properties.forEach(function (property) {
        if (property.length > 0) {
          switch (property[0]) {
            case '*':
              events.add(property.substring(1));
              break;

            case '!':
              type[property.substring(1)] = BOOLEAN;
              break;

            case '#':
              type[property.substring(1)] = NUMBER;
              break;

            case '%':
              type[property.substring(1)] = OBJECT;
              break;

            default:
              type[property] = STRING;
          }
        }
      });
    });
    return _this123;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(DomElementSchemaRegistry, [{
    key: "hasProperty",
    value: function hasProperty(tagName, propName, schemaMetas) {
      if (schemaMetas.some(function (schema) {
        return schema.name === NO_ERRORS_SCHEMA.name;
      })) {
        return true;
      }

      if (tagName.indexOf('-') > -1) {
        if (isNgContainer(tagName) || isNgContent(tagName)) {
          return false;
        }

        if (schemaMetas.some(function (schema) {
          return schema.name === CUSTOM_ELEMENTS_SCHEMA.name;
        })) {
          // Can't tell now as we don't know which properties a custom element will get
          // once it is instantiated
          return true;
        }
      }

      var elementProperties = this._schema[tagName.toLowerCase()] || this._schema['unknown'];

      return !!elementProperties[propName];
    }
  }, {
    key: "hasElement",
    value: function hasElement(tagName, schemaMetas) {
      if (schemaMetas.some(function (schema) {
        return schema.name === NO_ERRORS_SCHEMA.name;
      })) {
        return true;
      }

      if (tagName.indexOf('-') > -1) {
        if (isNgContainer(tagName) || isNgContent(tagName)) {
          return true;
        }

        if (schemaMetas.some(function (schema) {
          return schema.name === CUSTOM_ELEMENTS_SCHEMA.name;
        })) {
          // Allow any custom elements
          return true;
        }
      }

      return !!this._schema[tagName.toLowerCase()];
    }
    /**
     * securityContext returns the security context for the given property on the given DOM tag.
     *
     * Tag and property name are statically known and cannot change at runtime, i.e. it is not
     * possible to bind a value into a changing attribute or tag name.
     *
     * The filtering is based on a list of allowed tags|attributes. All attributes in the schema
     * above are assumed to have the 'NONE' security context, i.e. that they are safe inert
     * string values. Only specific well known attack vectors are assigned their appropriate context.
     */

  }, {
    key: "securityContext",
    value: function securityContext(tagName, propName, isAttribute) {
      if (isAttribute) {
        // NB: For security purposes, use the mapped property name, not the attribute name.
        propName = this.getMappedPropName(propName);
      } // Make sure comparisons are case insensitive, so that case differences between attribute and
      // property names do not have a security impact.


      tagName = tagName.toLowerCase();
      propName = propName.toLowerCase();
      var ctx = SECURITY_SCHEMA()[tagName + '|' + propName];

      if (ctx) {
        return ctx;
      }

      ctx = SECURITY_SCHEMA()['*|' + propName];
      return ctx ? ctx : SecurityContext.NONE;
    }
  }, {
    key: "getMappedPropName",
    value: function getMappedPropName(propName) {
      return _ATTR_TO_PROP[propName] || propName;
    }
  }, {
    key: "getDefaultComponentElementName",
    value: function getDefaultComponentElementName() {
      return 'ng-component';
    }
  }, {
    key: "validateProperty",
    value: function validateProperty(name) {
      if (name.toLowerCase().startsWith('on')) {
        var msg = "Binding to event property '".concat(name, "' is disallowed for security reasons, ") + "please use (".concat(name.slice(2), ")=...") + "\nIf '".concat(name, "' is a directive input, make sure the directive is imported by the") + " current module.";
        return {
          error: true,
          msg: msg
        };
      } else {
        return {
          error: false
        };
      }
    }
  }, {
    key: "validateAttribute",
    value: function validateAttribute(name) {
      if (name.toLowerCase().startsWith('on')) {
        var msg = "Binding to event attribute '".concat(name, "' is disallowed for security reasons, ") + "please use (".concat(name.slice(2), ")=...");
        return {
          error: true,
          msg: msg
        };
      } else {
        return {
          error: false
        };
      }
    }
  }, {
    key: "allKnownElementNames",
    value: function allKnownElementNames() {
      return Object.keys(this._schema);
    }
  }, {
    key: "allKnownAttributesOfElement",
    value: function allKnownAttributesOfElement(tagName) {
      var elementProperties = this._schema[tagName.toLowerCase()] || this._schema['unknown']; // Convert properties to attributes.


      return Object.keys(elementProperties).map(function (prop) {
        var _a;

        return (_a = _PROP_TO_ATTR[prop]) !== null && _a !== void 0 ? _a : prop;
      });
    }
  }, {
    key: "allKnownEventsOfElement",
    value: function allKnownEventsOfElement(tagName) {
      var _a;

      return Array.from((_a = this._eventSchema[tagName.toLowerCase()]) !== null && _a !== void 0 ? _a : []);
    }
  }, {
    key: "normalizeAnimationStyleProperty",
    value: function normalizeAnimationStyleProperty(propName) {
      return dashCaseToCamelCase(propName);
    }
  }, {
    key: "normalizeAnimationStyleValue",
    value: function normalizeAnimationStyleValue(camelCaseProp, userProvidedProp, val) {
      var unit = '';
      var strVal = val.toString().trim();
      var errorMsg = null;

      if (_isPixelDimensionStyle(camelCaseProp) && val !== 0 && val !== '0') {
        if (typeof val === 'number') {
          unit = 'px';
        } else {
          var valAndSuffixMatch = val.match(/^[+-]?[\d\.]+([a-z]*)$/);

          if (valAndSuffixMatch && valAndSuffixMatch[1].length == 0) {
            errorMsg = "Please provide a CSS unit value for ".concat(userProvidedProp, ":").concat(val);
          }
        }
      }

      return {
        error: errorMsg,
        value: strVal + unit
      };
    }
  }]);

  return DomElementSchemaRegistry;
}(ElementSchemaRegistry);

function _isPixelDimensionStyle(prop) {
  switch (prop) {
    case 'width':
    case 'height':
    case 'minWidth':
    case 'minHeight':
    case 'maxWidth':
    case 'maxHeight':
    case 'left':
    case 'top':
    case 'bottom':
    case 'right':
    case 'fontSize':
    case 'outlineWidth':
    case 'outlineOffset':
    case 'paddingTop':
    case 'paddingLeft':
    case 'paddingBottom':
    case 'paddingRight':
    case 'marginTop':
    case 'marginLeft':
    case 'marginBottom':
    case 'marginRight':
    case 'borderRadius':
    case 'borderWidth':
    case 'borderTopWidth':
    case 'borderLeftWidth':
    case 'borderRightWidth':
    case 'borderBottomWidth':
    case 'textIndent':
      return true;

    default:
      return false;
  }
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * Set of tagName|propertyName corresponding to Trusted Types sinks. Properties applying to all
 * tags use '*'.
 *
 * Extracted from, and should be kept in sync with
 * https://w3c.github.io/webappsec-trusted-types/dist/spec/#integrations
 */


var TRUSTED_TYPES_SINKS = new Set([// NOTE: All strings in this set *must* be lowercase!
// TrustedHTML
'iframe|srcdoc', '*|innerhtml', '*|outerhtml', // NB: no TrustedScript here, as the corresponding tags are stripped by the compiler.
// TrustedScriptURL
'embed|src', 'object|codebase', 'object|data']);
/**
 * isTrustedTypesSink returns true if the given property on the given DOM tag is a Trusted Types
 * sink. In that case, use `ElementSchemaRegistry.securityContext` to determine which particular
 * Trusted Type is required for values passed to the sink:
 * - SecurityContext.HTML corresponds to TrustedHTML
 * - SecurityContext.RESOURCE_URL corresponds to TrustedScriptURL
 */

function isTrustedTypesSink(tagName, propName) {
  // Make sure comparisons are case insensitive, so that case differences between attribute and
  // property names do not have a security impact.
  tagName = tagName.toLowerCase();
  propName = propName.toLowerCase();
  return TRUSTED_TYPES_SINKS.has(tagName + '|' + propName) || TRUSTED_TYPES_SINKS.has('*|' + propName);
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */


var PROPERTY_PARTS_SEPARATOR = '.';
var ATTRIBUTE_PREFIX = 'attr';
var CLASS_PREFIX = 'class';
var STYLE_PREFIX = 'style';
var TEMPLATE_ATTR_PREFIX$1 = '*';
var ANIMATE_PROP_PREFIX = 'animate-';
/**
 * Parses bindings in templates and in the directive host area.
 */

var BindingParser = /*#__PURE__*/function () {
  function BindingParser(_exprParser, _interpolationConfig, _schemaRegistry, errors) {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, BindingParser);

    this._exprParser = _exprParser;
    this._interpolationConfig = _interpolationConfig;
    this._schemaRegistry = _schemaRegistry;
    this.errors = errors;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(BindingParser, [{
    key: "interpolationConfig",
    get: function get() {
      return this._interpolationConfig;
    }
  }, {
    key: "createBoundHostProperties",
    value: function createBoundHostProperties(properties, sourceSpan) {
      var boundProps = [];

      for (var _i6 = 0, _Object$keys = Object.keys(properties); _i6 < _Object$keys.length; _i6++) {
        var propName = _Object$keys[_i6];
        var expression = properties[propName];

        if (typeof expression === 'string') {
          this.parsePropertyBinding(propName, expression, true, sourceSpan, sourceSpan.start.offset, undefined, [], // Use the `sourceSpan` for  `keySpan`. This isn't really accurate, but neither is the
          // sourceSpan, as it represents the sourceSpan of the host itself rather than the
          // source of the host binding (which doesn't exist in the template). Regardless,
          // neither of these values are used in Ivy but are only here to satisfy the function
          // signature. This should likely be refactored in the future so that `sourceSpan`
          // isn't being used inaccurately.
          boundProps, sourceSpan);
        } else {
          this._reportError("Value of the host property binding \"".concat(propName, "\" needs to be a string representing an expression but got \"").concat(expression, "\" (").concat(typeof expression, ")"), sourceSpan);
        }
      }

      return boundProps;
    }
  }, {
    key: "createDirectiveHostEventAsts",
    value: function createDirectiveHostEventAsts(hostListeners, sourceSpan) {
      var targetEvents = [];

      for (var _i7 = 0, _Object$keys2 = Object.keys(hostListeners); _i7 < _Object$keys2.length; _i7++) {
        var propName = _Object$keys2[_i7];
        var expression = hostListeners[propName];

        if (typeof expression === 'string') {
          // Use the `sourceSpan` for  `keySpan` and `handlerSpan`. This isn't really accurate, but
          // neither is the `sourceSpan`, as it represents the `sourceSpan` of the host itself
          // rather than the source of the host binding (which doesn't exist in the template).
          // Regardless, neither of these values are used in Ivy but are only here to satisfy the
          // function signature. This should likely be refactored in the future so that `sourceSpan`
          // isn't being used inaccurately.
          this.parseEvent(propName, expression,
          /* isAssignmentEvent */
          false, sourceSpan, sourceSpan, [], targetEvents, sourceSpan);
        } else {
          this._reportError("Value of the host listener \"".concat(propName, "\" needs to be a string representing an expression but got \"").concat(expression, "\" (").concat(typeof expression, ")"), sourceSpan);
        }
      }

      return targetEvents;
    }
  }, {
    key: "parseInterpolation",
    value: function parseInterpolation(value, sourceSpan, interpolatedTokens) {
      var sourceInfo = sourceSpan.start.toString();
      var absoluteOffset = sourceSpan.fullStart.offset;

      try {
        var ast = this._exprParser.parseInterpolation(value, sourceInfo, absoluteOffset, interpolatedTokens, this._interpolationConfig);

        if (ast) this._reportExpressionParserErrors(ast.errors, sourceSpan);
        return ast;
      } catch (e) {
        this._reportError("".concat(e), sourceSpan);

        return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);
      }
    }
    /**
     * Similar to `parseInterpolation`, but treats the provided string as a single expression
     * element that would normally appear within the interpolation prefix and suffix (`{{` and `}}`).
     * This is used for parsing the switch expression in ICUs.
     */

  }, {
    key: "parseInterpolationExpression",
    value: function parseInterpolationExpression(expression, sourceSpan) {
      var sourceInfo = sourceSpan.start.toString();
      var absoluteOffset = sourceSpan.start.offset;

      try {
        var ast = this._exprParser.parseInterpolationExpression(expression, sourceInfo, absoluteOffset);

        if (ast) this._reportExpressionParserErrors(ast.errors, sourceSpan);
        return ast;
      } catch (e) {
        this._reportError("".concat(e), sourceSpan);

        return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);
      }
    }
    /**
     * Parses the bindings in a microsyntax expression, and converts them to
     * `ParsedProperty` or `ParsedVariable`.
     *
     * @param tplKey template binding name
     * @param tplValue template binding value
     * @param sourceSpan span of template binding relative to entire the template
     * @param absoluteValueOffset start of the tplValue relative to the entire template
     * @param targetMatchableAttrs potential attributes to match in the template
     * @param targetProps target property bindings in the template
     * @param targetVars target variables in the template
     */

  }, {
    key: "parseInlineTemplateBinding",
    value: function parseInlineTemplateBinding(tplKey, tplValue, sourceSpan, absoluteValueOffset, targetMatchableAttrs, targetProps, targetVars, isIvyAst) {
      var absoluteKeyOffset = sourceSpan.start.offset + TEMPLATE_ATTR_PREFIX$1.length;

      var bindings = this._parseTemplateBindings(tplKey, tplValue, sourceSpan, absoluteKeyOffset, absoluteValueOffset);

      var _iterator14 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper_js__WEBPACK_IMPORTED_MODULE_9__["default"])(bindings),
          _step14;

      try {
        for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
          var binding = _step14.value;
          // sourceSpan is for the entire HTML attribute. bindingSpan is for a particular
          // binding within the microsyntax expression so it's more narrow than sourceSpan.
          var bindingSpan = moveParseSourceSpan(sourceSpan, binding.sourceSpan);
          var key = binding.key.source;
          var keySpan = moveParseSourceSpan(sourceSpan, binding.key.span);

          if (binding instanceof VariableBinding) {
            var value = binding.value ? binding.value.source : '$implicit';
            var valueSpan = binding.value ? moveParseSourceSpan(sourceSpan, binding.value.span) : undefined;
            targetVars.push(new ParsedVariable(key, value, bindingSpan, keySpan, valueSpan));
          } else if (binding.value) {
            var srcSpan = isIvyAst ? bindingSpan : sourceSpan;

            var _valueSpan = moveParseSourceSpan(sourceSpan, binding.value.ast.sourceSpan);

            this._parsePropertyAst(key, binding.value, srcSpan, keySpan, _valueSpan, targetMatchableAttrs, targetProps);
          } else {
            targetMatchableAttrs.push([key, ''
            /* value */
            ]); // Since this is a literal attribute with no RHS, source span should be
            // just the key span.

            this.parseLiteralAttr(key, null
            /* value */
            , keySpan, absoluteValueOffset, undefined
            /* valueSpan */
            , targetMatchableAttrs, targetProps, keySpan);
          }
        }
      } catch (err) {
        _iterator14.e(err);
      } finally {
        _iterator14.f();
      }
    }
    /**
     * Parses the bindings in a microsyntax expression, e.g.
     * ```
     *    <tag *tplKey="let value1 = prop; let value2 = localVar">
     * ```
     *
     * @param tplKey template binding name
     * @param tplValue template binding value
     * @param sourceSpan span of template binding relative to entire the template
     * @param absoluteKeyOffset start of the `tplKey`
     * @param absoluteValueOffset start of the `tplValue`
     */

  }, {
    key: "_parseTemplateBindings",
    value: function _parseTemplateBindings(tplKey, tplValue, sourceSpan, absoluteKeyOffset, absoluteValueOffset) {
      var _this124 = this;

      var sourceInfo = sourceSpan.start.toString();

      try {
        var bindingsResult = this._exprParser.parseTemplateBindings(tplKey, tplValue, sourceInfo, absoluteKeyOffset, absoluteValueOffset);

        this._reportExpressionParserErrors(bindingsResult.errors, sourceSpan);

        bindingsResult.warnings.forEach(function (warning) {
          _this124._reportError(warning, sourceSpan, ParseErrorLevel.WARNING);
        });
        return bindingsResult.templateBindings;
      } catch (e) {
        this._reportError("".concat(e), sourceSpan);

        return [];
      }
    }
  }, {
    key: "parseLiteralAttr",
    value: function parseLiteralAttr(name, value, sourceSpan, absoluteOffset, valueSpan, targetMatchableAttrs, targetProps, keySpan) {
      if (isAnimationLabel(name)) {
        name = name.substring(1);

        if (keySpan !== undefined) {
          keySpan = moveParseSourceSpan(keySpan, new AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset));
        }

        if (value) {
          this._reportError("Assigning animation triggers via @prop=\"exp\" attributes with an expression is invalid." + " Use property bindings (e.g. [@prop]=\"exp\") or use an attribute without a value (e.g. @prop) instead.", sourceSpan, ParseErrorLevel.ERROR);
        }

        this._parseAnimation(name, value, sourceSpan, absoluteOffset, keySpan, valueSpan, targetMatchableAttrs, targetProps);
      } else {
        targetProps.push(new ParsedProperty(name, this._exprParser.wrapLiteralPrimitive(value, '', absoluteOffset), ParsedPropertyType.LITERAL_ATTR, sourceSpan, keySpan, valueSpan));
      }
    }
  }, {
    key: "parsePropertyBinding",
    value: function parsePropertyBinding(name, expression, isHost, sourceSpan, absoluteOffset, valueSpan, targetMatchableAttrs, targetProps, keySpan) {
      if (name.length === 0) {
        this._reportError("Property name is missing in binding", sourceSpan);
      }

      var isAnimationProp = false;

      if (name.startsWith(ANIMATE_PROP_PREFIX)) {
        isAnimationProp = true;
        name = name.substring(ANIMATE_PROP_PREFIX.length);

        if (keySpan !== undefined) {
          keySpan = moveParseSourceSpan(keySpan, new AbsoluteSourceSpan(keySpan.start.offset + ANIMATE_PROP_PREFIX.length, keySpan.end.offset));
        }
      } else if (isAnimationLabel(name)) {
        isAnimationProp = true;
        name = name.substring(1);

        if (keySpan !== undefined) {
          keySpan = moveParseSourceSpan(keySpan, new AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset));
        }
      }

      if (isAnimationProp) {
        this._parseAnimation(name, expression, sourceSpan, absoluteOffset, keySpan, valueSpan, targetMatchableAttrs, targetProps);
      } else {
        this._parsePropertyAst(name, this._parseBinding(expression, isHost, valueSpan || sourceSpan, absoluteOffset), sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps);
      }
    }
  }, {
    key: "parsePropertyInterpolation",
    value: function parsePropertyInterpolation(name, value, sourceSpan, valueSpan, targetMatchableAttrs, targetProps, keySpan, interpolatedTokens) {
      var expr = this.parseInterpolation(value, valueSpan || sourceSpan, interpolatedTokens);

      if (expr) {
        this._parsePropertyAst(name, expr, sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps);

        return true;
      }

      return false;
    }
  }, {
    key: "_parsePropertyAst",
    value: function _parsePropertyAst(name, ast, sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps) {
      targetMatchableAttrs.push([name, ast.source]);
      targetProps.push(new ParsedProperty(name, ast, ParsedPropertyType.DEFAULT, sourceSpan, keySpan, valueSpan));
    }
  }, {
    key: "_parseAnimation",
    value: function _parseAnimation(name, expression, sourceSpan, absoluteOffset, keySpan, valueSpan, targetMatchableAttrs, targetProps) {
      if (name.length === 0) {
        this._reportError('Animation trigger is missing', sourceSpan);
      } // This will occur when a @trigger is not paired with an expression.
      // For animations it is valid to not have an expression since */void
      // states will be applied by angular when the element is attached/detached


      var ast = this._parseBinding(expression || 'undefined', false, valueSpan || sourceSpan, absoluteOffset);

      targetMatchableAttrs.push([name, ast.source]);
      targetProps.push(new ParsedProperty(name, ast, ParsedPropertyType.ANIMATION, sourceSpan, keySpan, valueSpan));
    }
  }, {
    key: "_parseBinding",
    value: function _parseBinding(value, isHostBinding, sourceSpan, absoluteOffset) {
      var sourceInfo = (sourceSpan && sourceSpan.start || '(unknown)').toString();

      try {
        var ast = isHostBinding ? this._exprParser.parseSimpleBinding(value, sourceInfo, absoluteOffset, this._interpolationConfig) : this._exprParser.parseBinding(value, sourceInfo, absoluteOffset, this._interpolationConfig);
        if (ast) this._reportExpressionParserErrors(ast.errors, sourceSpan);
        return ast;
      } catch (e) {
        this._reportError("".concat(e), sourceSpan);

        return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);
      }
    }
  }, {
    key: "createBoundElementProperty",
    value: function createBoundElementProperty(elementSelector, boundProp) {
      var skipValidation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var mapPropertyName = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

      if (boundProp.isAnimation) {
        return new BoundElementProperty(boundProp.name, 4
        /* BindingType.Animation */
        , SecurityContext.NONE, boundProp.expression, null, boundProp.sourceSpan, boundProp.keySpan, boundProp.valueSpan);
      }

      var unit = null;
      var bindingType = undefined;
      var boundPropertyName = null;
      var parts = boundProp.name.split(PROPERTY_PARTS_SEPARATOR);
      var securityContexts = undefined; // Check for special cases (prefix style, attr, class)

      if (parts.length > 1) {
        if (parts[0] == ATTRIBUTE_PREFIX) {
          boundPropertyName = parts.slice(1).join(PROPERTY_PARTS_SEPARATOR);

          if (!skipValidation) {
            this._validatePropertyOrAttributeName(boundPropertyName, boundProp.sourceSpan, true);
          }

          securityContexts = _calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, boundPropertyName, true);
          var nsSeparatorIdx = boundPropertyName.indexOf(':');

          if (nsSeparatorIdx > -1) {
            var ns = boundPropertyName.substring(0, nsSeparatorIdx);
            var name = boundPropertyName.substring(nsSeparatorIdx + 1);
            boundPropertyName = mergeNsAndName(ns, name);
          }

          bindingType = 1
          /* BindingType.Attribute */
          ;
        } else if (parts[0] == CLASS_PREFIX) {
          boundPropertyName = parts[1];
          bindingType = 2
          /* BindingType.Class */
          ;
          securityContexts = [SecurityContext.NONE];
        } else if (parts[0] == STYLE_PREFIX) {
          unit = parts.length > 2 ? parts[2] : null;
          boundPropertyName = parts[1];
          bindingType = 3
          /* BindingType.Style */
          ;
          securityContexts = [SecurityContext.STYLE];
        }
      } // If not a special case, use the full property name


      if (boundPropertyName === null) {
        var mappedPropName = this._schemaRegistry.getMappedPropName(boundProp.name);

        boundPropertyName = mapPropertyName ? mappedPropName : boundProp.name;
        securityContexts = _calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, mappedPropName, false);
        bindingType = 0
        /* BindingType.Property */
        ;

        if (!skipValidation) {
          this._validatePropertyOrAttributeName(mappedPropName, boundProp.sourceSpan, false);
        }
      }

      return new BoundElementProperty(boundPropertyName, bindingType, securityContexts[0], boundProp.expression, unit, boundProp.sourceSpan, boundProp.keySpan, boundProp.valueSpan);
    } // TODO: keySpan should be required but was made optional to avoid changing VE parser.

  }, {
    key: "parseEvent",
    value: function parseEvent(name, expression, isAssignmentEvent, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents, keySpan) {
      if (name.length === 0) {
        this._reportError("Event name is missing in binding", sourceSpan);
      }

      if (isAnimationLabel(name)) {
        name = name.slice(1);

        if (keySpan !== undefined) {
          keySpan = moveParseSourceSpan(keySpan, new AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset));
        }

        this._parseAnimationEvent(name, expression, isAssignmentEvent, sourceSpan, handlerSpan, targetEvents, keySpan);
      } else {
        this._parseRegularEvent(name, expression, isAssignmentEvent, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents, keySpan);
      }
    }
  }, {
    key: "calcPossibleSecurityContexts",
    value: function calcPossibleSecurityContexts(selector, propName, isAttribute) {
      var prop = this._schemaRegistry.getMappedPropName(propName);

      return _calcPossibleSecurityContexts(this._schemaRegistry, selector, prop, isAttribute);
    }
  }, {
    key: "_parseAnimationEvent",
    value: function _parseAnimationEvent(name, expression, isAssignmentEvent, sourceSpan, handlerSpan, targetEvents, keySpan) {
      var matches = splitAtPeriod(name, [name, '']);
      var eventName = matches[0];
      var phase = matches[1].toLowerCase();

      var ast = this._parseAction(expression, isAssignmentEvent, handlerSpan);

      targetEvents.push(new ParsedEvent(eventName, phase, 1
      /* ParsedEventType.Animation */
      , ast, sourceSpan, handlerSpan, keySpan));

      if (eventName.length === 0) {
        this._reportError("Animation event name is missing in binding", sourceSpan);
      }

      if (phase) {
        if (phase !== 'start' && phase !== 'done') {
          this._reportError("The provided animation output phase value \"".concat(phase, "\" for \"@").concat(eventName, "\" is not supported (use start or done)"), sourceSpan);
        }
      } else {
        this._reportError("The animation trigger output event (@".concat(eventName, ") is missing its phase value name (start or done are currently supported)"), sourceSpan);
      }
    }
  }, {
    key: "_parseRegularEvent",
    value: function _parseRegularEvent(name, expression, isAssignmentEvent, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents, keySpan) {
      // long format: 'target: eventName'
      var _splitAtColon3 = splitAtColon(name, [null, name]),
          _splitAtColon4 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_slicedToArray_js__WEBPACK_IMPORTED_MODULE_3__["default"])(_splitAtColon3, 2),
          target = _splitAtColon4[0],
          eventName = _splitAtColon4[1];

      var ast = this._parseAction(expression, isAssignmentEvent, handlerSpan);

      targetMatchableAttrs.push([name, ast.source]);
      targetEvents.push(new ParsedEvent(eventName, target, 0
      /* ParsedEventType.Regular */
      , ast, sourceSpan, handlerSpan, keySpan)); // Don't detect directives for event names for now,
      // so don't add the event name to the matchableAttrs
    }
  }, {
    key: "_parseAction",
    value: function _parseAction(value, isAssignmentEvent, sourceSpan) {
      var sourceInfo = (sourceSpan && sourceSpan.start || '(unknown').toString();
      var absoluteOffset = sourceSpan && sourceSpan.start ? sourceSpan.start.offset : 0;

      try {
        var ast = this._exprParser.parseAction(value, isAssignmentEvent, sourceInfo, absoluteOffset, this._interpolationConfig);

        if (ast) {
          this._reportExpressionParserErrors(ast.errors, sourceSpan);
        }

        if (!ast || ast.ast instanceof EmptyExpr) {
          this._reportError("Empty expressions are not allowed", sourceSpan);

          return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);
        }

        return ast;
      } catch (e) {
        this._reportError("".concat(e), sourceSpan);

        return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);
      }
    }
  }, {
    key: "_reportError",
    value: function _reportError(message, sourceSpan) {
      var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ParseErrorLevel.ERROR;
      this.errors.push(new ParseError(sourceSpan, message, level));
    }
  }, {
    key: "_reportExpressionParserErrors",
    value: function _reportExpressionParserErrors(errors, sourceSpan) {
      var _iterator15 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper_js__WEBPACK_IMPORTED_MODULE_9__["default"])(errors),
          _step15;

      try {
        for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
          var _error = _step15.value;

          this._reportError(_error.message, sourceSpan);
        }
      } catch (err) {
        _iterator15.e(err);
      } finally {
        _iterator15.f();
      }
    }
    /**
     * @param propName the name of the property / attribute
     * @param sourceSpan
     * @param isAttr true when binding to an attribute
     */

  }, {
    key: "_validatePropertyOrAttributeName",
    value: function _validatePropertyOrAttributeName(propName, sourceSpan, isAttr) {
      var report = isAttr ? this._schemaRegistry.validateAttribute(propName) : this._schemaRegistry.validateProperty(propName);

      if (report.error) {
        this._reportError(report.msg, sourceSpan, ParseErrorLevel.ERROR);
      }
    }
  }]);

  return BindingParser;
}();

var PipeCollector = /*#__PURE__*/function (_RecursiveAstVisitor2) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(PipeCollector, _RecursiveAstVisitor2);

  var _super77 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(PipeCollector);

  function PipeCollector() {
    var _this125;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, PipeCollector);

    _this125 = _super77.apply(this, arguments);
    _this125.pipes = new Map();
    return _this125;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(PipeCollector, [{
    key: "visitPipe",
    value: function visitPipe(ast, context) {
      this.pipes.set(ast.name, ast);
      ast.exp.visit(this);
      this.visitAll(ast.args, context);
      return null;
    }
  }]);

  return PipeCollector;
}(RecursiveAstVisitor);

function isAnimationLabel(name) {
  return name[0] == '@';
}

function _calcPossibleSecurityContexts(registry, selector, propName, isAttribute) {
  var ctxs = [];
  CssSelector.parse(selector).forEach(function (selector) {
    var elementNames = selector.element ? [selector.element] : registry.allKnownElementNames();
    var notElementNames = new Set(selector.notSelectors.filter(function (selector) {
      return selector.isElementSelector();
    }).map(function (selector) {
      return selector.element;
    }));
    var possibleElementNames = elementNames.filter(function (elementName) {
      return !notElementNames.has(elementName);
    });
    ctxs.push.apply(ctxs, (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(possibleElementNames.map(function (elementName) {
      return registry.securityContext(elementName, propName, isAttribute);
    })));
  });
  return ctxs.length === 0 ? [SecurityContext.NONE] : Array.from(new Set(ctxs)).sort();
}
/**
 * Compute a new ParseSourceSpan based off an original `sourceSpan` by using
 * absolute offsets from the specified `absoluteSpan`.
 *
 * @param sourceSpan original source span
 * @param absoluteSpan absolute source span to move to
 */


function moveParseSourceSpan(sourceSpan, absoluteSpan) {
  // The difference of two absolute offsets provide the relative offset
  var startDiff = absoluteSpan.start - sourceSpan.start.offset;
  var endDiff = absoluteSpan.end - sourceSpan.end.offset;
  return new ParseSourceSpan(sourceSpan.start.moveBy(startDiff), sourceSpan.end.moveBy(endDiff), sourceSpan.fullStart.moveBy(startDiff), sourceSpan.details);
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
// Some of the code comes from WebComponents.JS
// https://github.com/webcomponents/webcomponentsjs/blob/master/src/HTMLImports/path.js


function isStyleUrlResolvable(url) {
  if (url == null || url.length === 0 || url[0] == '/') return false;
  var schemeMatch = url.match(URL_WITH_SCHEMA_REGEXP);
  return schemeMatch === null || schemeMatch[1] == 'package' || schemeMatch[1] == 'asset';
}

var URL_WITH_SCHEMA_REGEXP = /^([^:/?#]+):/;
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

var NG_CONTENT_SELECT_ATTR$1 = 'select';
var LINK_ELEMENT = 'link';
var LINK_STYLE_REL_ATTR = 'rel';
var LINK_STYLE_HREF_ATTR = 'href';
var LINK_STYLE_REL_VALUE = 'stylesheet';
var STYLE_ELEMENT = 'style';
var SCRIPT_ELEMENT = 'script';
var NG_NON_BINDABLE_ATTR = 'ngNonBindable';
var NG_PROJECT_AS = 'ngProjectAs';

function preparseElement(ast) {
  var selectAttr = null;
  var hrefAttr = null;
  var relAttr = null;
  var nonBindable = false;
  var projectAs = '';
  ast.attrs.forEach(function (attr) {
    var lcAttrName = attr.name.toLowerCase();

    if (lcAttrName == NG_CONTENT_SELECT_ATTR$1) {
      selectAttr = attr.value;
    } else if (lcAttrName == LINK_STYLE_HREF_ATTR) {
      hrefAttr = attr.value;
    } else if (lcAttrName == LINK_STYLE_REL_ATTR) {
      relAttr = attr.value;
    } else if (attr.name == NG_NON_BINDABLE_ATTR) {
      nonBindable = true;
    } else if (attr.name == NG_PROJECT_AS) {
      if (attr.value.length > 0) {
        projectAs = attr.value;
      }
    }
  });
  selectAttr = normalizeNgContentSelect(selectAttr);
  var nodeName = ast.name.toLowerCase();
  var type = PreparsedElementType.OTHER;

  if (isNgContent(nodeName)) {
    type = PreparsedElementType.NG_CONTENT;
  } else if (nodeName == STYLE_ELEMENT) {
    type = PreparsedElementType.STYLE;
  } else if (nodeName == SCRIPT_ELEMENT) {
    type = PreparsedElementType.SCRIPT;
  } else if (nodeName == LINK_ELEMENT && relAttr == LINK_STYLE_REL_VALUE) {
    type = PreparsedElementType.STYLESHEET;
  }

  return new PreparsedElement(type, selectAttr, hrefAttr, nonBindable, projectAs);
}

var PreparsedElementType;

(function (PreparsedElementType) {
  PreparsedElementType[PreparsedElementType["NG_CONTENT"] = 0] = "NG_CONTENT";
  PreparsedElementType[PreparsedElementType["STYLE"] = 1] = "STYLE";
  PreparsedElementType[PreparsedElementType["STYLESHEET"] = 2] = "STYLESHEET";
  PreparsedElementType[PreparsedElementType["SCRIPT"] = 3] = "SCRIPT";
  PreparsedElementType[PreparsedElementType["OTHER"] = 4] = "OTHER";
})(PreparsedElementType || (PreparsedElementType = {}));

var PreparsedElement = /*#__PURE__*/(0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(function PreparsedElement(type, selectAttr, hrefAttr, nonBindable, projectAs) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, PreparsedElement);

  this.type = type;
  this.selectAttr = selectAttr;
  this.hrefAttr = hrefAttr;
  this.nonBindable = nonBindable;
  this.projectAs = projectAs;
});

function normalizeNgContentSelect(selectAttr) {
  if (selectAttr === null || selectAttr.length === 0) {
    return '*';
  }

  return selectAttr;
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */


var BIND_NAME_REGEXP = /^(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@))(.*)$/; // Group 1 = "bind-"

var KW_BIND_IDX = 1; // Group 2 = "let-"

var KW_LET_IDX = 2; // Group 3 = "ref-/#"

var KW_REF_IDX = 3; // Group 4 = "on-"

var KW_ON_IDX = 4; // Group 5 = "bindon-"

var KW_BINDON_IDX = 5; // Group 6 = "@"

var KW_AT_IDX = 6; // Group 7 = the identifier after "bind-", "let-", "ref-/#", "on-", "bindon-" or "@"

var IDENT_KW_IDX = 7;
var BINDING_DELIMS = {
  BANANA_BOX: {
    start: '[(',
    end: ')]'
  },
  PROPERTY: {
    start: '[',
    end: ']'
  },
  EVENT: {
    start: '(',
    end: ')'
  }
};
var TEMPLATE_ATTR_PREFIX = '*';

function htmlAstToRender3Ast(htmlNodes, bindingParser, options) {
  var transformer = new HtmlAstToIvyAst(bindingParser, options);
  var ivyNodes = visitAll(transformer, htmlNodes); // Errors might originate in either the binding parser or the html to ivy transformer

  var allErrors = bindingParser.errors.concat(transformer.errors);
  var result = {
    nodes: ivyNodes,
    errors: allErrors,
    styleUrls: transformer.styleUrls,
    styles: transformer.styles,
    ngContentSelectors: transformer.ngContentSelectors
  };

  if (options.collectCommentNodes) {
    result.commentNodes = transformer.commentNodes;
  }

  return result;
}

var HtmlAstToIvyAst = /*#__PURE__*/function () {
  function HtmlAstToIvyAst(bindingParser, options) {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, HtmlAstToIvyAst);

    this.bindingParser = bindingParser;
    this.options = options;
    this.errors = [];
    this.styles = [];
    this.styleUrls = [];
    this.ngContentSelectors = []; // This array will be populated if `Render3ParseOptions['collectCommentNodes']` is true

    this.commentNodes = [];
    this.inI18nBlock = false;
  } // HTML visitor


  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(HtmlAstToIvyAst, [{
    key: "visitElement",
    value: function visitElement(element) {
      var _this126 = this;

      var isI18nRootElement = isI18nRootNode(element.i18n);

      if (isI18nRootElement) {
        if (this.inI18nBlock) {
          this.reportError('Cannot mark an element as translatable inside of a translatable section. Please remove the nested i18n marker.', element.sourceSpan);
        }

        this.inI18nBlock = true;
      }

      var preparsedElement = preparseElement(element);

      if (preparsedElement.type === PreparsedElementType.SCRIPT) {
        return null;
      } else if (preparsedElement.type === PreparsedElementType.STYLE) {
        var contents = textContents(element);

        if (contents !== null) {
          this.styles.push(contents);
        }

        return null;
      } else if (preparsedElement.type === PreparsedElementType.STYLESHEET && isStyleUrlResolvable(preparsedElement.hrefAttr)) {
        this.styleUrls.push(preparsedElement.hrefAttr);
        return null;
      } // Whether the element is a `<ng-template>`


      var isTemplateElement = isNgTemplate(element.name);
      var parsedProperties = [];
      var boundEvents = [];
      var variables = [];
      var references = [];
      var attributes = [];
      var i18nAttrsMeta = {};
      var templateParsedProperties = [];
      var templateVariables = []; // Whether the element has any *-attribute

      var elementHasInlineTemplate = false;

      var _iterator16 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper_js__WEBPACK_IMPORTED_MODULE_9__["default"])(element.attrs),
          _step16;

      try {
        for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {
          var attribute = _step16.value;
          var hasBinding = false;
          var normalizedName = normalizeAttributeName(attribute.name); // `*attr` defines template bindings

          var isTemplateBinding = false;

          if (attribute.i18n) {
            i18nAttrsMeta[attribute.name] = attribute.i18n;
          }

          if (normalizedName.startsWith(TEMPLATE_ATTR_PREFIX)) {
            // *-attributes
            if (elementHasInlineTemplate) {
              this.reportError("Can't have multiple template bindings on one element. Use only one attribute prefixed with *", attribute.sourceSpan);
            }

            isTemplateBinding = true;
            elementHasInlineTemplate = true;
            var templateValue = attribute.value;
            var templateKey = normalizedName.substring(TEMPLATE_ATTR_PREFIX.length);
            var parsedVariables = [];
            var absoluteValueOffset = attribute.valueSpan ? attribute.valueSpan.start.offset : // If there is no value span the attribute does not have a value, like `attr` in
            //`<div attr></div>`. In this case, point to one character beyond the last character of
            // the attribute name.
            attribute.sourceSpan.start.offset + attribute.name.length;
            this.bindingParser.parseInlineTemplateBinding(templateKey, templateValue, attribute.sourceSpan, absoluteValueOffset, [], templateParsedProperties, parsedVariables, true
            /* isIvyAst */
            );
            templateVariables.push.apply(templateVariables, (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(parsedVariables.map(function (v) {
              return new Variable(v.name, v.value, v.sourceSpan, v.keySpan, v.valueSpan);
            })));
          } else {
            // Check for variables, events, property bindings, interpolation
            hasBinding = this.parseAttribute(isTemplateElement, attribute, [], parsedProperties, boundEvents, variables, references);
          }

          if (!hasBinding && !isTemplateBinding) {
            // don't include the bindings as attributes as well in the AST
            attributes.push(this.visitAttribute(attribute));
          }
        }
      } catch (err) {
        _iterator16.e(err);
      } finally {
        _iterator16.f();
      }

      var children = visitAll(preparsedElement.nonBindable ? NON_BINDABLE_VISITOR : this, element.children);
      var parsedElement;

      if (preparsedElement.type === PreparsedElementType.NG_CONTENT) {
        // `<ng-content>`
        if (element.children && !element.children.every(function (node) {
          return isEmptyTextNode(node) || isCommentNode(node);
        })) {
          this.reportError("<ng-content> element cannot have content.", element.sourceSpan);
        }

        var selector = preparsedElement.selectAttr;
        var attrs = element.attrs.map(function (attr) {
          return _this126.visitAttribute(attr);
        });
        parsedElement = new Content(selector, attrs, element.sourceSpan, element.i18n);
        this.ngContentSelectors.push(selector);
      } else if (isTemplateElement) {
        // `<ng-template>`
        var _attrs = this.extractAttributes(element.name, parsedProperties, i18nAttrsMeta);

        parsedElement = new Template(element.name, attributes, _attrs.bound, boundEvents, [
          /* no template attributes */
        ], children, references, variables, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);
      } else {
        var _attrs2 = this.extractAttributes(element.name, parsedProperties, i18nAttrsMeta);

        parsedElement = new Element$1(element.name, attributes, _attrs2.bound, boundEvents, children, references, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);
      }

      if (elementHasInlineTemplate) {
        // If this node is an inline-template (e.g. has *ngFor) then we need to create a template
        // node that contains this node.
        // Moreover, if the node is an element, then we need to hoist its attributes to the template
        // node for matching against content projection selectors.
        var _attrs3 = this.extractAttributes('ng-template', templateParsedProperties, i18nAttrsMeta);

        var templateAttrs = [];

        _attrs3.literal.forEach(function (attr) {
          return templateAttrs.push(attr);
        });

        _attrs3.bound.forEach(function (attr) {
          return templateAttrs.push(attr);
        });

        var hoistedAttrs = parsedElement instanceof Element$1 ? {
          attributes: parsedElement.attributes,
          inputs: parsedElement.inputs,
          outputs: parsedElement.outputs
        } : {
          attributes: [],
          inputs: [],
          outputs: []
        }; // For <ng-template>s with structural directives on them, avoid passing i18n information to
        // the wrapping template to prevent unnecessary i18n instructions from being generated. The
        // necessary i18n meta information will be extracted from child elements.

        var i18n = isTemplateElement && isI18nRootElement ? undefined : element.i18n;
        var name = parsedElement instanceof Template ? null : parsedElement.name;
        parsedElement = new Template(name, hoistedAttrs.attributes, hoistedAttrs.inputs, hoistedAttrs.outputs, templateAttrs, [parsedElement], [
          /* no references */
        ], templateVariables, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, i18n);
      }

      if (isI18nRootElement) {
        this.inI18nBlock = false;
      }

      return parsedElement;
    }
  }, {
    key: "visitAttribute",
    value: function visitAttribute(attribute) {
      return new TextAttribute(attribute.name, attribute.value, attribute.sourceSpan, attribute.keySpan, attribute.valueSpan, attribute.i18n);
    }
  }, {
    key: "visitText",
    value: function visitText(text) {
      return this._visitTextWithInterpolation(text.value, text.sourceSpan, text.tokens, text.i18n);
    }
  }, {
    key: "visitExpansion",
    value: function visitExpansion(expansion) {
      var _this127 = this;

      if (!expansion.i18n) {
        // do not generate Icu in case it was created
        // outside of i18n block in a template
        return null;
      }

      if (!isI18nRootNode(expansion.i18n)) {
        throw new Error("Invalid type \"".concat(expansion.i18n.constructor, "\" for \"i18n\" property of ").concat(expansion.sourceSpan.toString(), ". Expected a \"Message\""));
      }

      var message = expansion.i18n;
      var vars = {};
      var placeholders = {}; // extract VARs from ICUs - we process them separately while
      // assembling resulting message via goog.getMsg function, since
      // we need to pass them to top-level goog.getMsg call

      Object.keys(message.placeholders).forEach(function (key) {
        var value = message.placeholders[key];

        if (key.startsWith(I18N_ICU_VAR_PREFIX)) {
          // Currently when the `plural` or `select` keywords in an ICU contain trailing spaces (e.g.
          // `{count, select , ...}`), these spaces are also included into the key names in ICU vars
          // (e.g. "VAR_SELECT "). These trailing spaces are not desirable, since they will later be
          // converted into `_` symbols while normalizing placeholder names, which might lead to
          // mismatches at runtime (i.e. placeholder will not be replaced with the correct value).
          var formattedKey = key.trim();

          var ast = _this127.bindingParser.parseInterpolationExpression(value.text, value.sourceSpan);

          vars[formattedKey] = new BoundText(ast, value.sourceSpan);
        } else {
          placeholders[key] = _this127._visitTextWithInterpolation(value.text, value.sourceSpan, null);
        }
      });
      return new Icu$1(vars, placeholders, expansion.sourceSpan, message);
    }
  }, {
    key: "visitExpansionCase",
    value: function visitExpansionCase(expansionCase) {
      return null;
    }
  }, {
    key: "visitComment",
    value: function visitComment(comment) {
      if (this.options.collectCommentNodes) {
        this.commentNodes.push(new Comment$1(comment.value || '', comment.sourceSpan));
      }

      return null;
    } // convert view engine `ParsedProperty` to a format suitable for IVY

  }, {
    key: "extractAttributes",
    value: function extractAttributes(elementName, properties, i18nPropsMeta) {
      var _this128 = this;

      var bound = [];
      var literal = [];
      properties.forEach(function (prop) {
        var i18n = i18nPropsMeta[prop.name];

        if (prop.isLiteral) {
          literal.push(new TextAttribute(prop.name, prop.expression.source || '', prop.sourceSpan, prop.keySpan, prop.valueSpan, i18n));
        } else {
          // Note that validation is skipped and property mapping is disabled
          // due to the fact that we need to make sure a given prop is not an
          // input of a directive and directive matching happens at runtime.
          var bep = _this128.bindingParser.createBoundElementProperty(elementName, prop,
          /* skipValidation */
          true,
          /* mapPropertyName */
          false);

          bound.push(BoundAttribute.fromBoundElementProperty(bep, i18n));
        }
      });
      return {
        bound: bound,
        literal: literal
      };
    }
  }, {
    key: "parseAttribute",
    value: function parseAttribute(isTemplateElement, attribute, matchableAttributes, parsedProperties, boundEvents, variables, references) {
      var _a;

      var name = normalizeAttributeName(attribute.name);
      var value = attribute.value;
      var srcSpan = attribute.sourceSpan;
      var absoluteOffset = attribute.valueSpan ? attribute.valueSpan.start.offset : srcSpan.start.offset;

      function createKeySpan(srcSpan, prefix, identifier) {
        // We need to adjust the start location for the keySpan to account for the removed 'data-'
        // prefix from `normalizeAttributeName`.
        var normalizationAdjustment = attribute.name.length - name.length;
        var keySpanStart = srcSpan.start.moveBy(prefix.length + normalizationAdjustment);
        var keySpanEnd = keySpanStart.moveBy(identifier.length);
        return new ParseSourceSpan(keySpanStart, keySpanEnd, keySpanStart, identifier);
      }

      var bindParts = name.match(BIND_NAME_REGEXP);

      if (bindParts) {
        if (bindParts[KW_BIND_IDX] != null) {
          var identifier = bindParts[IDENT_KW_IDX];

          var _keySpan = createKeySpan(srcSpan, bindParts[KW_BIND_IDX], identifier);

          this.bindingParser.parsePropertyBinding(identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, _keySpan);
        } else if (bindParts[KW_LET_IDX]) {
          if (isTemplateElement) {
            var _identifier = bindParts[IDENT_KW_IDX];

            var _keySpan2 = createKeySpan(srcSpan, bindParts[KW_LET_IDX], _identifier);

            this.parseVariable(_identifier, value, srcSpan, _keySpan2, attribute.valueSpan, variables);
          } else {
            this.reportError("\"let-\" is only supported on ng-template elements.", srcSpan);
          }
        } else if (bindParts[KW_REF_IDX]) {
          var _identifier2 = bindParts[IDENT_KW_IDX];

          var _keySpan3 = createKeySpan(srcSpan, bindParts[KW_REF_IDX], _identifier2);

          this.parseReference(_identifier2, value, srcSpan, _keySpan3, attribute.valueSpan, references);
        } else if (bindParts[KW_ON_IDX]) {
          var events = [];
          var _identifier3 = bindParts[IDENT_KW_IDX];

          var _keySpan4 = createKeySpan(srcSpan, bindParts[KW_ON_IDX], _identifier3);

          this.bindingParser.parseEvent(_identifier3, value,
          /* isAssignmentEvent */
          false, srcSpan, attribute.valueSpan || srcSpan, matchableAttributes, events, _keySpan4);
          addEvents(events, boundEvents);
        } else if (bindParts[KW_BINDON_IDX]) {
          var _identifier4 = bindParts[IDENT_KW_IDX];

          var _keySpan5 = createKeySpan(srcSpan, bindParts[KW_BINDON_IDX], _identifier4);

          this.bindingParser.parsePropertyBinding(_identifier4, value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, _keySpan5);
          this.parseAssignmentEvent(_identifier4, value, srcSpan, attribute.valueSpan, matchableAttributes, boundEvents, _keySpan5);
        } else if (bindParts[KW_AT_IDX]) {
          var _keySpan6 = createKeySpan(srcSpan, '', name);

          this.bindingParser.parseLiteralAttr(name, value, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, _keySpan6);
        }

        return true;
      } // We didn't see a kw-prefixed property binding, but we have not yet checked
      // for the []/()/[()] syntax.


      var delims = null;

      if (name.startsWith(BINDING_DELIMS.BANANA_BOX.start)) {
        delims = BINDING_DELIMS.BANANA_BOX;
      } else if (name.startsWith(BINDING_DELIMS.PROPERTY.start)) {
        delims = BINDING_DELIMS.PROPERTY;
      } else if (name.startsWith(BINDING_DELIMS.EVENT.start)) {
        delims = BINDING_DELIMS.EVENT;
      }

      if (delims !== null && // NOTE: older versions of the parser would match a start/end delimited
      // binding iff the property name was terminated by the ending delimiter
      // and the identifier in the binding was non-empty.
      // TODO(ayazhafiz): update this to handle malformed bindings.
      name.endsWith(delims.end) && name.length > delims.start.length + delims.end.length) {
        var _identifier5 = name.substring(delims.start.length, name.length - delims.end.length);

        var _keySpan7 = createKeySpan(srcSpan, delims.start, _identifier5);

        if (delims.start === BINDING_DELIMS.BANANA_BOX.start) {
          this.bindingParser.parsePropertyBinding(_identifier5, value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, _keySpan7);
          this.parseAssignmentEvent(_identifier5, value, srcSpan, attribute.valueSpan, matchableAttributes, boundEvents, _keySpan7);
        } else if (delims.start === BINDING_DELIMS.PROPERTY.start) {
          this.bindingParser.parsePropertyBinding(_identifier5, value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, _keySpan7);
        } else {
          var _events = [];
          this.bindingParser.parseEvent(_identifier5, value,
          /* isAssignmentEvent */
          false, srcSpan, attribute.valueSpan || srcSpan, matchableAttributes, _events, _keySpan7);
          addEvents(_events, boundEvents);
        }

        return true;
      } // No explicit binding found.


      var keySpan = createKeySpan(srcSpan, ''
      /* prefix */
      , name);
      var hasBinding = this.bindingParser.parsePropertyInterpolation(name, value, srcSpan, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan, (_a = attribute.valueTokens) !== null && _a !== void 0 ? _a : null);
      return hasBinding;
    }
  }, {
    key: "_visitTextWithInterpolation",
    value: function _visitTextWithInterpolation(value, sourceSpan, interpolatedTokens, i18n) {
      var valueNoNgsp = replaceNgsp(value);
      var expr = this.bindingParser.parseInterpolation(valueNoNgsp, sourceSpan, interpolatedTokens);
      return expr ? new BoundText(expr, sourceSpan, i18n) : new Text$3(valueNoNgsp, sourceSpan);
    }
  }, {
    key: "parseVariable",
    value: function parseVariable(identifier, value, sourceSpan, keySpan, valueSpan, variables) {
      if (identifier.indexOf('-') > -1) {
        this.reportError("\"-\" is not allowed in variable names", sourceSpan);
      } else if (identifier.length === 0) {
        this.reportError("Variable does not have a name", sourceSpan);
      }

      variables.push(new Variable(identifier, value, sourceSpan, keySpan, valueSpan));
    }
  }, {
    key: "parseReference",
    value: function parseReference(identifier, value, sourceSpan, keySpan, valueSpan, references) {
      if (identifier.indexOf('-') > -1) {
        this.reportError("\"-\" is not allowed in reference names", sourceSpan);
      } else if (identifier.length === 0) {
        this.reportError("Reference does not have a name", sourceSpan);
      } else if (references.some(function (reference) {
        return reference.name === identifier;
      })) {
        this.reportError("Reference \"#".concat(identifier, "\" is defined more than once"), sourceSpan);
      }

      references.push(new Reference(identifier, value, sourceSpan, keySpan, valueSpan));
    }
  }, {
    key: "parseAssignmentEvent",
    value: function parseAssignmentEvent(name, expression, sourceSpan, valueSpan, targetMatchableAttrs, boundEvents, keySpan) {
      var events = [];
      this.bindingParser.parseEvent("".concat(name, "Change"), "".concat(expression, " =$event"),
      /* isAssignmentEvent */
      true, sourceSpan, valueSpan || sourceSpan, targetMatchableAttrs, events, keySpan);
      addEvents(events, boundEvents);
    }
  }, {
    key: "reportError",
    value: function reportError(message, sourceSpan) {
      var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ParseErrorLevel.ERROR;
      this.errors.push(new ParseError(sourceSpan, message, level));
    }
  }]);

  return HtmlAstToIvyAst;
}();

var NonBindableVisitor = /*#__PURE__*/function () {
  function NonBindableVisitor() {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, NonBindableVisitor);
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(NonBindableVisitor, [{
    key: "visitElement",
    value: function visitElement(ast) {
      var preparsedElement = preparseElement(ast);

      if (preparsedElement.type === PreparsedElementType.SCRIPT || preparsedElement.type === PreparsedElementType.STYLE || preparsedElement.type === PreparsedElementType.STYLESHEET) {
        // Skipping <script> for security reasons
        // Skipping <style> and stylesheets as we already processed them
        // in the StyleCompiler
        return null;
      }

      var children = visitAll(this, ast.children, null);
      return new Element$1(ast.name, visitAll(this, ast.attrs),
      /* inputs */
      [],
      /* outputs */
      [], children,
      /* references */
      [], ast.sourceSpan, ast.startSourceSpan, ast.endSourceSpan);
    }
  }, {
    key: "visitComment",
    value: function visitComment(comment) {
      return null;
    }
  }, {
    key: "visitAttribute",
    value: function visitAttribute(attribute) {
      return new TextAttribute(attribute.name, attribute.value, attribute.sourceSpan, attribute.keySpan, attribute.valueSpan, attribute.i18n);
    }
  }, {
    key: "visitText",
    value: function visitText(text) {
      return new Text$3(text.value, text.sourceSpan);
    }
  }, {
    key: "visitExpansion",
    value: function visitExpansion(expansion) {
      return null;
    }
  }, {
    key: "visitExpansionCase",
    value: function visitExpansionCase(expansionCase) {
      return null;
    }
  }]);

  return NonBindableVisitor;
}();

var NON_BINDABLE_VISITOR = new NonBindableVisitor();

function normalizeAttributeName(attrName) {
  return /^data-/i.test(attrName) ? attrName.substring(5) : attrName;
}

function addEvents(events, boundEvents) {
  boundEvents.push.apply(boundEvents, (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(events.map(function (e) {
    return BoundEvent.fromParsedEvent(e);
  })));
}

function isEmptyTextNode(node) {
  return node instanceof Text && node.value.trim().length == 0;
}

function isCommentNode(node) {
  return node instanceof Comment;
}

function textContents(node) {
  if (node.children.length !== 1 || !(node.children[0] instanceof Text)) {
    return null;
  } else {
    return node.children[0].value;
  }
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */


var TagType;

(function (TagType) {
  TagType[TagType["ELEMENT"] = 0] = "ELEMENT";
  TagType[TagType["TEMPLATE"] = 1] = "TEMPLATE";
})(TagType || (TagType = {}));
/**
 * Generates an object that is used as a shared state between parent and all child contexts.
 */


function setupRegistry() {
  return {
    getUniqueId: getSeqNumberGenerator(),
    icus: new Map()
  };
}
/**
 * I18nContext is a helper class which keeps track of all i18n-related aspects
 * (accumulates placeholders, bindings, etc) between i18nStart and i18nEnd instructions.
 *
 * When we enter a nested template, the top-level context is being passed down
 * to the nested component, which uses this context to generate a child instance
 * of I18nContext class (to handle nested template) and at the end, reconciles it back
 * with the parent context.
 *
 * @param index Instruction index of i18nStart, which initiates this context
 * @param ref Reference to a translation const that represents the content if thus context
 * @param level Nestng level defined for child contexts
 * @param templateIndex Instruction index of a template which this context belongs to
 * @param meta Meta information (id, meaning, description, etc) associated with this context
 */


var I18nContext = /*#__PURE__*/function () {
  function I18nContext(index, ref) {
    var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var templateIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var meta = arguments.length > 4 ? arguments[4] : undefined;
    var registry = arguments.length > 5 ? arguments[5] : undefined;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, I18nContext);

    this.index = index;
    this.ref = ref;
    this.level = level;
    this.templateIndex = templateIndex;
    this.meta = meta;
    this.registry = registry;
    this.bindings = new Set();
    this.placeholders = new Map();
    this.isEmitted = false;
    this._unresolvedCtxCount = 0;
    this._registry = registry || setupRegistry();
    this.id = this._registry.getUniqueId();
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(I18nContext, [{
    key: "appendTag",
    value: function appendTag(type, node, index, closed) {
      if (node.isVoid && closed) {
        return; // ignore "close" for void tags
      }

      var ph = node.isVoid || !closed ? node.startName : node.closeName;
      var content = {
        type: type,
        index: index,
        ctx: this.id,
        isVoid: node.isVoid,
        closed: closed
      };
      updatePlaceholderMap(this.placeholders, ph, content);
    }
  }, {
    key: "icus",
    get: function get() {
      return this._registry.icus;
    }
  }, {
    key: "isRoot",
    get: function get() {
      return this.level === 0;
    }
  }, {
    key: "isResolved",
    get: function get() {
      return this._unresolvedCtxCount === 0;
    }
  }, {
    key: "getSerializedPlaceholders",
    value: function getSerializedPlaceholders() {
      var result = new Map();
      this.placeholders.forEach(function (values, key) {
        return result.set(key, values.map(serializePlaceholderValue));
      });
      return result;
    } // public API to accumulate i18n-related content

  }, {
    key: "appendBinding",
    value: function appendBinding(binding) {
      this.bindings.add(binding);
    }
  }, {
    key: "appendIcu",
    value: function appendIcu(name, ref) {
      updatePlaceholderMap(this._registry.icus, name, ref);
    }
  }, {
    key: "appendBoundText",
    value: function appendBoundText(node) {
      var _this129 = this;

      var phs = assembleBoundTextPlaceholders(node, this.bindings.size, this.id);
      phs.forEach(function (values, key) {
        return updatePlaceholderMap.apply(void 0, [_this129.placeholders, key].concat((0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(values)));
      });
    }
  }, {
    key: "appendTemplate",
    value: function appendTemplate(node, index) {
      // add open and close tags at the same time,
      // since we process nested templates separately
      this.appendTag(TagType.TEMPLATE, node, index, false);
      this.appendTag(TagType.TEMPLATE, node, index, true);
      this._unresolvedCtxCount++;
    }
  }, {
    key: "appendElement",
    value: function appendElement(node, index, closed) {
      this.appendTag(TagType.ELEMENT, node, index, closed);
    }
  }, {
    key: "appendProjection",
    value: function appendProjection(node, index) {
      // Add open and close tags at the same time, since `<ng-content>` has no content,
      // so when we come across `<ng-content>` we can register both open and close tags.
      // Note: runtime i18n logic doesn't distinguish `<ng-content>` tag placeholders and
      // regular element tag placeholders, so we generate element placeholders for both types.
      this.appendTag(TagType.ELEMENT, node, index, false);
      this.appendTag(TagType.ELEMENT, node, index, true);
    }
    /**
     * Generates an instance of a child context based on the root one,
     * when we enter a nested template within I18n section.
     *
     * @param index Instruction index of corresponding i18nStart, which initiates this context
     * @param templateIndex Instruction index of a template which this context belongs to
     * @param meta Meta information (id, meaning, description, etc) associated with this context
     *
     * @returns I18nContext instance
     */

  }, {
    key: "forkChildContext",
    value: function forkChildContext(index, templateIndex, meta) {
      return new I18nContext(index, this.ref, this.level + 1, templateIndex, meta, this._registry);
    }
    /**
     * Reconciles child context into parent one once the end of the i18n block is reached (i18nEnd).
     *
     * @param context Child I18nContext instance to be reconciled with parent context.
     */

  }, {
    key: "reconcileChildContext",
    value: function reconcileChildContext(context) {
      var _this130 = this;

      // set the right context id for open and close
      // template tags, so we can use it as sub-block ids
      ['start', 'close'].forEach(function (op) {
        var key = context.meta["".concat(op, "Name")];
        var phs = _this130.placeholders.get(key) || [];
        var tag = phs.find(findTemplateFn(_this130.id, context.templateIndex));

        if (tag) {
          tag.ctx = context.id;
        }
      }); // reconcile placeholders

      var childPhs = context.placeholders;
      childPhs.forEach(function (values, key) {
        var phs = _this130.placeholders.get(key);

        if (!phs) {
          _this130.placeholders.set(key, values);

          return;
        } // try to find matching template...


        var tmplIdx = phs.findIndex(findTemplateFn(context.id, context.templateIndex));

        if (tmplIdx >= 0) {
          // ... if found - replace it with nested template content
          var isCloseTag = key.startsWith('CLOSE');
          var isTemplateTag = key.endsWith('NG-TEMPLATE');

          if (isTemplateTag) {
            // current template's content is placed before or after
            // parent template tag, depending on the open/close atrribute
            phs.splice.apply(phs, [tmplIdx + (isCloseTag ? 0 : 1), 0].concat((0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(values)));
          } else {
            var idx = isCloseTag ? values.length - 1 : 0;
            values[idx].tmpl = phs[tmplIdx];
            phs.splice.apply(phs, [tmplIdx, 1].concat((0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(values)));
          }
        } else {
          // ... otherwise just append content to placeholder value
          phs.push.apply(phs, (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(values));
        }

        _this130.placeholders.set(key, phs);
      });
      this._unresolvedCtxCount--;
    }
  }]);

  return I18nContext;
}(); //
// Helper methods
//


function wrap(symbol, index, contextId, closed) {
  var state = closed ? '/' : '';
  return wrapI18nPlaceholder("".concat(state).concat(symbol).concat(index), contextId);
}

function wrapTag(symbol, _ref8, closed) {
  var index = _ref8.index,
      ctx = _ref8.ctx,
      isVoid = _ref8.isVoid;
  return isVoid ? wrap(symbol, index, ctx) + wrap(symbol, index, ctx, true) : wrap(symbol, index, ctx, closed);
}

function findTemplateFn(ctx, templateIndex) {
  return function (token) {
    return typeof token === 'object' && token.type === TagType.TEMPLATE && token.index === templateIndex && token.ctx === ctx;
  };
}

function serializePlaceholderValue(value) {
  var element = function element(data, closed) {
    return wrapTag('#', data, closed);
  };

  var template = function template(data, closed) {
    return wrapTag('*', data, closed);
  };

  var projection = function projection(data, closed) {
    return wrapTag('!', data, closed);
  };

  switch (value.type) {
    case TagType.ELEMENT:
      // close element tag
      if (value.closed) {
        return element(value, true) + (value.tmpl ? template(value.tmpl, true) : '');
      } // open element tag that also initiates a template


      if (value.tmpl) {
        return template(value.tmpl) + element(value) + (value.isVoid ? template(value.tmpl, true) : '');
      }

      return element(value);

    case TagType.TEMPLATE:
      return template(value, value.closed);

    default:
      return value;
  }
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */


var IcuSerializerVisitor = /*#__PURE__*/function () {
  function IcuSerializerVisitor() {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, IcuSerializerVisitor);
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(IcuSerializerVisitor, [{
    key: "visitText",
    value: function visitText(text) {
      return text.value;
    }
  }, {
    key: "visitContainer",
    value: function visitContainer(container) {
      var _this131 = this;

      return container.children.map(function (child) {
        return child.visit(_this131);
      }).join('');
    }
  }, {
    key: "visitIcu",
    value: function visitIcu(icu) {
      var _this132 = this;

      var strCases = Object.keys(icu.cases).map(function (k) {
        return "".concat(k, " {").concat(icu.cases[k].visit(_this132), "}");
      });
      var result = "{".concat(icu.expressionPlaceholder, ", ").concat(icu.type, ", ").concat(strCases.join(' '), "}");
      return result;
    }
  }, {
    key: "visitTagPlaceholder",
    value: function visitTagPlaceholder(ph) {
      var _this133 = this;

      return ph.isVoid ? this.formatPh(ph.startName) : "".concat(this.formatPh(ph.startName)).concat(ph.children.map(function (child) {
        return child.visit(_this133);
      }).join('')).concat(this.formatPh(ph.closeName));
    }
  }, {
    key: "visitPlaceholder",
    value: function visitPlaceholder(ph) {
      return this.formatPh(ph.name);
    }
  }, {
    key: "visitIcuPlaceholder",
    value: function visitIcuPlaceholder(ph, context) {
      return this.formatPh(ph.name);
    }
  }, {
    key: "formatPh",
    value: function formatPh(value) {
      return "{".concat(formatI18nPlaceholderName(value,
      /* useCamelCase */
      false), "}");
    }
  }]);

  return IcuSerializerVisitor;
}();

var serializer = new IcuSerializerVisitor();

function serializeIcuNode(icu) {
  return icu.visit(serializer);
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */


var TAG_TO_PLACEHOLDER_NAMES = {
  'A': 'LINK',
  'B': 'BOLD_TEXT',
  'BR': 'LINE_BREAK',
  'EM': 'EMPHASISED_TEXT',
  'H1': 'HEADING_LEVEL1',
  'H2': 'HEADING_LEVEL2',
  'H3': 'HEADING_LEVEL3',
  'H4': 'HEADING_LEVEL4',
  'H5': 'HEADING_LEVEL5',
  'H6': 'HEADING_LEVEL6',
  'HR': 'HORIZONTAL_RULE',
  'I': 'ITALIC_TEXT',
  'LI': 'LIST_ITEM',
  'LINK': 'MEDIA_LINK',
  'OL': 'ORDERED_LIST',
  'P': 'PARAGRAPH',
  'Q': 'QUOTATION',
  'S': 'STRIKETHROUGH_TEXT',
  'SMALL': 'SMALL_TEXT',
  'SUB': 'SUBSTRIPT',
  'SUP': 'SUPERSCRIPT',
  'TBODY': 'TABLE_BODY',
  'TD': 'TABLE_CELL',
  'TFOOT': 'TABLE_FOOTER',
  'TH': 'TABLE_HEADER_CELL',
  'THEAD': 'TABLE_HEADER',
  'TR': 'TABLE_ROW',
  'TT': 'MONOSPACED_TEXT',
  'U': 'UNDERLINED_TEXT',
  'UL': 'UNORDERED_LIST'
};
/**
 * Creates unique names for placeholder with different content.
 *
 * Returns the same placeholder name when the content is identical.
 */

var PlaceholderRegistry = /*#__PURE__*/function () {
  function PlaceholderRegistry() {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, PlaceholderRegistry);

    // Count the occurrence of the base name top generate a unique name
    this._placeHolderNameCounts = {}; // Maps signature to placeholder names

    this._signatureToName = {};
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(PlaceholderRegistry, [{
    key: "getStartTagPlaceholderName",
    value: function getStartTagPlaceholderName(tag, attrs, isVoid) {
      var signature = this._hashTag(tag, attrs, isVoid);

      if (this._signatureToName[signature]) {
        return this._signatureToName[signature];
      }

      var upperTag = tag.toUpperCase();
      var baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || "TAG_".concat(upperTag);

      var name = this._generateUniqueName(isVoid ? baseName : "START_".concat(baseName));

      this._signatureToName[signature] = name;
      return name;
    }
  }, {
    key: "getCloseTagPlaceholderName",
    value: function getCloseTagPlaceholderName(tag) {
      var signature = this._hashClosingTag(tag);

      if (this._signatureToName[signature]) {
        return this._signatureToName[signature];
      }

      var upperTag = tag.toUpperCase();
      var baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || "TAG_".concat(upperTag);

      var name = this._generateUniqueName("CLOSE_".concat(baseName));

      this._signatureToName[signature] = name;
      return name;
    }
  }, {
    key: "getPlaceholderName",
    value: function getPlaceholderName(name, content) {
      var upperName = name.toUpperCase();
      var signature = "PH: ".concat(upperName, "=").concat(content);

      if (this._signatureToName[signature]) {
        return this._signatureToName[signature];
      }

      var uniqueName = this._generateUniqueName(upperName);

      this._signatureToName[signature] = uniqueName;
      return uniqueName;
    }
  }, {
    key: "getUniquePlaceholder",
    value: function getUniquePlaceholder(name) {
      return this._generateUniqueName(name.toUpperCase());
    } // Generate a hash for a tag - does not take attribute order into account

  }, {
    key: "_hashTag",
    value: function _hashTag(tag, attrs, isVoid) {
      var start = "<".concat(tag);
      var strAttrs = Object.keys(attrs).sort().map(function (name) {
        return " ".concat(name, "=").concat(attrs[name]);
      }).join('');
      var end = isVoid ? '/>' : "></".concat(tag, ">");
      return start + strAttrs + end;
    }
  }, {
    key: "_hashClosingTag",
    value: function _hashClosingTag(tag) {
      return this._hashTag("/".concat(tag), {}, false);
    }
  }, {
    key: "_generateUniqueName",
    value: function _generateUniqueName(base) {
      var seen = this._placeHolderNameCounts.hasOwnProperty(base);

      if (!seen) {
        this._placeHolderNameCounts[base] = 1;
        return base;
      }

      var id = this._placeHolderNameCounts[base];
      this._placeHolderNameCounts[base] = id + 1;
      return "".concat(base, "_").concat(id);
    }
  }]);

  return PlaceholderRegistry;
}();
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */


var _expParser = new Parser$1(new Lexer());
/**
 * Returns a function converting html nodes to an i18n Message given an interpolationConfig
 */


function createI18nMessageFactory(interpolationConfig) {
  var visitor = new _I18nVisitor(_expParser, interpolationConfig);
  return function (nodes, meaning, description, customId, visitNodeFn) {
    return visitor.toI18nMessage(nodes, meaning, description, customId, visitNodeFn);
  };
}

function noopVisitNodeFn(_html, i18n) {
  return i18n;
}

var _I18nVisitor = /*#__PURE__*/function () {
  function _I18nVisitor(_expressionParser, _interpolationConfig) {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, _I18nVisitor);

    this._expressionParser = _expressionParser;
    this._interpolationConfig = _interpolationConfig;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(_I18nVisitor, [{
    key: "toI18nMessage",
    value: function toI18nMessage(nodes) {
      var meaning = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      var description = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
      var customId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
      var visitNodeFn = arguments.length > 4 ? arguments[4] : undefined;
      var context = {
        isIcu: nodes.length == 1 && nodes[0] instanceof Expansion,
        icuDepth: 0,
        placeholderRegistry: new PlaceholderRegistry(),
        placeholderToContent: {},
        placeholderToMessage: {},
        visitNodeFn: visitNodeFn || noopVisitNodeFn
      };
      var i18nodes = visitAll(this, nodes, context);
      return new Message(i18nodes, context.placeholderToContent, context.placeholderToMessage, meaning, description, customId);
    }
  }, {
    key: "visitElement",
    value: function visitElement(el, context) {
      var _a;

      var children = visitAll(this, el.children, context);
      var attrs = {};
      el.attrs.forEach(function (attr) {
        // Do not visit the attributes, translatable ones are top-level ASTs
        attrs[attr.name] = attr.value;
      });
      var isVoid = getHtmlTagDefinition(el.name).isVoid;
      var startPhName = context.placeholderRegistry.getStartTagPlaceholderName(el.name, attrs, isVoid);
      context.placeholderToContent[startPhName] = {
        text: el.startSourceSpan.toString(),
        sourceSpan: el.startSourceSpan
      };
      var closePhName = '';

      if (!isVoid) {
        closePhName = context.placeholderRegistry.getCloseTagPlaceholderName(el.name);
        context.placeholderToContent[closePhName] = {
          text: "</".concat(el.name, ">"),
          sourceSpan: (_a = el.endSourceSpan) !== null && _a !== void 0 ? _a : el.sourceSpan
        };
      }

      var node = new TagPlaceholder(el.name, attrs, startPhName, closePhName, children, isVoid, el.sourceSpan, el.startSourceSpan, el.endSourceSpan);
      return context.visitNodeFn(el, node);
    }
  }, {
    key: "visitAttribute",
    value: function visitAttribute(attribute, context) {
      var node = attribute.valueTokens === undefined || attribute.valueTokens.length === 1 ? new Text$2(attribute.value, attribute.valueSpan || attribute.sourceSpan) : this._visitTextWithInterpolation(attribute.valueTokens, attribute.valueSpan || attribute.sourceSpan, context, attribute.i18n);
      return context.visitNodeFn(attribute, node);
    }
  }, {
    key: "visitText",
    value: function visitText(text, context) {
      var node = text.tokens.length === 1 ? new Text$2(text.value, text.sourceSpan) : this._visitTextWithInterpolation(text.tokens, text.sourceSpan, context, text.i18n);
      return context.visitNodeFn(text, node);
    }
  }, {
    key: "visitComment",
    value: function visitComment(comment, context) {
      return null;
    }
  }, {
    key: "visitExpansion",
    value: function visitExpansion(icu, context) {
      var _this134 = this;

      context.icuDepth++;
      var i18nIcuCases = {};
      var i18nIcu = new Icu(icu.switchValue, icu.type, i18nIcuCases, icu.sourceSpan);
      icu.cases.forEach(function (caze) {
        i18nIcuCases[caze.value] = new Container(caze.expression.map(function (node) {
          return node.visit(_this134, context);
        }), caze.expSourceSpan);
      });
      context.icuDepth--;

      if (context.isIcu || context.icuDepth > 0) {
        // Returns an ICU node when:
        // - the message (vs a part of the message) is an ICU message, or
        // - the ICU message is nested.
        var expPh = context.placeholderRegistry.getUniquePlaceholder("VAR_".concat(icu.type));
        i18nIcu.expressionPlaceholder = expPh;
        context.placeholderToContent[expPh] = {
          text: icu.switchValue,
          sourceSpan: icu.switchValueSourceSpan
        };
        return context.visitNodeFn(icu, i18nIcu);
      } // Else returns a placeholder
      // ICU placeholders should not be replaced with their original content but with the their
      // translations.
      // TODO(vicb): add a html.Node -> i18n.Message cache to avoid having to re-create the msg


      var phName = context.placeholderRegistry.getPlaceholderName('ICU', icu.sourceSpan.toString());
      context.placeholderToMessage[phName] = this.toI18nMessage([icu], '', '', '', undefined);
      var node = new IcuPlaceholder(i18nIcu, phName, icu.sourceSpan);
      return context.visitNodeFn(icu, node);
    }
  }, {
    key: "visitExpansionCase",
    value: function visitExpansionCase(_icuCase, _context) {
      throw new Error('Unreachable code');
    }
    /**
     * Convert, text and interpolated tokens up into text and placeholder pieces.
     *
     * @param tokens The text and interpolated tokens.
     * @param sourceSpan The span of the whole of the `text` string.
     * @param context The current context of the visitor, used to compute and store placeholders.
     * @param previousI18n Any i18n metadata associated with this `text` from a previous pass.
     */

  }, {
    key: "_visitTextWithInterpolation",
    value: function _visitTextWithInterpolation(tokens, sourceSpan, context, previousI18n) {
      // Return a sequence of `Text` and `Placeholder` nodes grouped in a `Container`.
      var nodes = []; // We will only create a container if there are actually interpolations,
      // so this flag tracks that.

      var hasInterpolation = false;

      var _iterator17 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper_js__WEBPACK_IMPORTED_MODULE_9__["default"])(tokens),
          _step17;

      try {
        for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {
          var token = _step17.value;

          switch (token.type) {
            case 8
            /* TokenType.INTERPOLATION */
            :
            case 17
            /* TokenType.ATTR_VALUE_INTERPOLATION */
            :
              hasInterpolation = true;
              var expression = token.parts[1];
              var baseName = extractPlaceholderName(expression) || 'INTERPOLATION';
              var phName = context.placeholderRegistry.getPlaceholderName(baseName, expression);
              context.placeholderToContent[phName] = {
                text: token.parts.join(''),
                sourceSpan: token.sourceSpan
              };
              nodes.push(new Placeholder(expression, phName, token.sourceSpan));
              break;

            default:
              if (token.parts[0].length > 0) {
                // This token is text or an encoded entity.
                // If it is following on from a previous text node then merge it into that node
                // Otherwise, if it is following an interpolation, then add a new node.
                var previous = nodes[nodes.length - 1];

                if (previous instanceof Text$2) {
                  previous.value += token.parts[0];
                  previous.sourceSpan = new ParseSourceSpan(previous.sourceSpan.start, token.sourceSpan.end, previous.sourceSpan.fullStart, previous.sourceSpan.details);
                } else {
                  nodes.push(new Text$2(token.parts[0], token.sourceSpan));
                }
              }

              break;
          }
        }
      } catch (err) {
        _iterator17.e(err);
      } finally {
        _iterator17.f();
      }

      if (hasInterpolation) {
        // Whitespace removal may have invalidated the interpolation source-spans.
        reusePreviousSourceSpans(nodes, previousI18n);
        return new Container(nodes, sourceSpan);
      } else {
        return nodes[0];
      }
    }
  }]);

  return _I18nVisitor;
}();
/**
 * Re-use the source-spans from `previousI18n` metadata for the `nodes`.
 *
 * Whitespace removal can invalidate the source-spans of interpolation nodes, so we
 * reuse the source-span stored from a previous pass before the whitespace was removed.
 *
 * @param nodes The `Text` and `Placeholder` nodes to be processed.
 * @param previousI18n Any i18n metadata for these `nodes` stored from a previous pass.
 */


function reusePreviousSourceSpans(nodes, previousI18n) {
  if (previousI18n instanceof Message) {
    // The `previousI18n` is an i18n `Message`, so we are processing an `Attribute` with i18n
    // metadata. The `Message` should consist only of a single `Container` that contains the
    // parts (`Text` and `Placeholder`) to process.
    assertSingleContainerMessage(previousI18n);
    previousI18n = previousI18n.nodes[0];
  }

  if (previousI18n instanceof Container) {
    // The `previousI18n` is a `Container`, which means that this is a second i18n extraction pass
    // after whitespace has been removed from the AST nodes.
    assertEquivalentNodes(previousI18n.children, nodes); // Reuse the source-spans from the first pass.

    for (var i = 0; i < nodes.length; i++) {
      nodes[i].sourceSpan = previousI18n.children[i].sourceSpan;
    }
  }
}
/**
 * Asserts that the `message` contains exactly one `Container` node.
 */


function assertSingleContainerMessage(message) {
  var nodes = message.nodes;

  if (nodes.length !== 1 || !(nodes[0] instanceof Container)) {
    throw new Error('Unexpected previous i18n message - expected it to consist of only a single `Container` node.');
  }
}
/**
 * Asserts that the `previousNodes` and `node` collections have the same number of elements and
 * corresponding elements have the same node type.
 */


function assertEquivalentNodes(previousNodes, nodes) {
  if (previousNodes.length !== nodes.length) {
    throw new Error('The number of i18n message children changed between first and second pass.');
  }

  if (previousNodes.some(function (node, i) {
    return nodes[i].constructor !== node.constructor;
  })) {
    throw new Error('The types of the i18n message children changed between first and second pass.');
  }
}

var _CUSTOM_PH_EXP = /\/\/[\s\S]*i18n[\s\S]*\([\s\S]*ph[\s\S]*=[\s\S]*("|')([\s\S]*?)\1[\s\S]*\)/g;

function extractPlaceholderName(input) {
  return input.split(_CUSTOM_PH_EXP)[2];
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * An i18n error.
 */


var I18nError = /*#__PURE__*/function (_ParseError3) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(I18nError, _ParseError3);

  var _super78 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(I18nError);

  function I18nError(span, msg) {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, I18nError);

    return _super78.call(this, span, msg);
  }

  return (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(I18nError);
}(ParseError);
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */


var setI18nRefs = function setI18nRefs(htmlNode, i18nNode) {
  if (htmlNode instanceof NodeWithI18n) {
    if (i18nNode instanceof IcuPlaceholder && htmlNode.i18n instanceof Message) {
      // This html node represents an ICU but this is a second processing pass, and the legacy id
      // was computed in the previous pass and stored in the `i18n` property as a message.
      // We are about to wipe out that property so capture the previous message to be reused when
      // generating the message for this ICU later. See `_generateI18nMessage()`.
      i18nNode.previousMessage = htmlNode.i18n;
    }

    htmlNode.i18n = i18nNode;
  }

  return i18nNode;
};
/**
 * This visitor walks over HTML parse tree and converts information stored in
 * i18n-related attributes ("i18n" and "i18n-*") into i18n meta object that is
 * stored with other element's and attribute's information.
 */


var I18nMetaVisitor = /*#__PURE__*/function () {
  function I18nMetaVisitor() {
    var interpolationConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_INTERPOLATION_CONFIG;
    var keepI18nAttrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var enableI18nLegacyMessageIdFormat = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, I18nMetaVisitor);

    this.interpolationConfig = interpolationConfig;
    this.keepI18nAttrs = keepI18nAttrs;
    this.enableI18nLegacyMessageIdFormat = enableI18nLegacyMessageIdFormat; // whether visited nodes contain i18n information

    this.hasI18nMeta = false;
    this._errors = []; // i18n message generation factory

    this._createI18nMessage = createI18nMessageFactory(this.interpolationConfig);
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(I18nMetaVisitor, [{
    key: "_generateI18nMessage",
    value: function _generateI18nMessage(nodes) {
      var meta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      var visitNodeFn = arguments.length > 2 ? arguments[2] : undefined;

      var _this$_parseMetadata = this._parseMetadata(meta),
          meaning = _this$_parseMetadata.meaning,
          description = _this$_parseMetadata.description,
          customId = _this$_parseMetadata.customId;

      var message = this._createI18nMessage(nodes, meaning, description, customId, visitNodeFn);

      this._setMessageId(message, meta);

      this._setLegacyIds(message, meta);

      return message;
    }
  }, {
    key: "visitAllWithErrors",
    value: function visitAllWithErrors(nodes) {
      var _this135 = this;

      var result = nodes.map(function (node) {
        return node.visit(_this135, null);
      });
      return new ParseTreeResult(result, this._errors);
    }
  }, {
    key: "visitElement",
    value: function visitElement(element) {
      var message = undefined;

      if (hasI18nAttrs(element)) {
        this.hasI18nMeta = true;
        var attrs = [];
        var attrsMeta = {};

        var _iterator18 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper_js__WEBPACK_IMPORTED_MODULE_9__["default"])(element.attrs),
            _step18;

        try {
          for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {
            var _attr = _step18.value;

            if (_attr.name === I18N_ATTR) {
              // root 'i18n' node attribute
              var i18n = element.i18n || _attr.value;
              message = this._generateI18nMessage(element.children, i18n, setI18nRefs);

              if (message.nodes.length === 0) {
                // Ignore the message if it is empty.
                message = undefined;
              } // Store the message on the element


              element.i18n = message;
            } else if (_attr.name.startsWith(I18N_ATTR_PREFIX)) {
              // 'i18n-*' attributes
              var name = _attr.name.slice(I18N_ATTR_PREFIX.length);

              if (isTrustedTypesSink(element.name, name)) {
                this._reportError(_attr, "Translating attribute '".concat(name, "' is disallowed for security reasons."));
              } else {
                attrsMeta[name] = _attr.value;
              }
            } else {
              // non-i18n attributes
              attrs.push(_attr);
            }
          } // set i18n meta for attributes

        } catch (err) {
          _iterator18.e(err);
        } finally {
          _iterator18.f();
        }

        if (Object.keys(attrsMeta).length) {
          var _iterator19 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper_js__WEBPACK_IMPORTED_MODULE_9__["default"])(attrs),
              _step19;

          try {
            for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {
              var attr = _step19.value;
              var meta = attrsMeta[attr.name]; // do not create translation for empty attributes

              if (meta !== undefined && attr.value) {
                attr.i18n = this._generateI18nMessage([attr], attr.i18n || meta);
              }
            }
          } catch (err) {
            _iterator19.e(err);
          } finally {
            _iterator19.f();
          }
        }

        if (!this.keepI18nAttrs) {
          // update element's attributes,
          // keeping only non-i18n related ones
          element.attrs = attrs;
        }
      }

      visitAll(this, element.children, message);
      return element;
    }
  }, {
    key: "visitExpansion",
    value: function visitExpansion(expansion, currentMessage) {
      var message;
      var meta = expansion.i18n;
      this.hasI18nMeta = true;

      if (meta instanceof IcuPlaceholder) {
        // set ICU placeholder name (e.g. "ICU_1"),
        // generated while processing root element contents,
        // so we can reference it when we output translation
        var name = meta.name;
        message = this._generateI18nMessage([expansion], meta);
        var icu = icuFromI18nMessage(message);
        icu.name = name;

        if (currentMessage !== null) {
          // Also update the placeholderToMessage map with this new message
          currentMessage.placeholderToMessage[name] = message;
        }
      } else {
        // ICU is a top level message, try to use metadata from container element if provided via
        // `context` argument. Note: context may not be available for standalone ICUs (without
        // wrapping element), so fallback to ICU metadata in this case.
        message = this._generateI18nMessage([expansion], currentMessage || meta);
      }

      expansion.i18n = message;
      return expansion;
    }
  }, {
    key: "visitText",
    value: function visitText(text) {
      return text;
    }
  }, {
    key: "visitAttribute",
    value: function visitAttribute(attribute) {
      return attribute;
    }
  }, {
    key: "visitComment",
    value: function visitComment(comment) {
      return comment;
    }
  }, {
    key: "visitExpansionCase",
    value: function visitExpansionCase(expansionCase) {
      return expansionCase;
    }
    /**
     * Parse the general form `meta` passed into extract the explicit metadata needed to create a
     * `Message`.
     *
     * There are three possibilities for the `meta` variable
     * 1) a string from an `i18n` template attribute: parse it to extract the metadata values.
     * 2) a `Message` from a previous processing pass: reuse the metadata values in the message.
     * 4) other: ignore this and just process the message metadata as normal
     *
     * @param meta the bucket that holds information about the message
     * @returns the parsed metadata.
     */

  }, {
    key: "_parseMetadata",
    value: function _parseMetadata(meta) {
      return typeof meta === 'string' ? parseI18nMeta(meta) : meta instanceof Message ? meta : {};
    }
    /**
     * Generate (or restore) message id if not specified already.
     */

  }, {
    key: "_setMessageId",
    value: function _setMessageId(message, meta) {
      if (!message.id) {
        message.id = meta instanceof Message && meta.id || decimalDigest(message);
      }
    }
    /**
     * Update the `message` with a `legacyId` if necessary.
     *
     * @param message the message whose legacy id should be set
     * @param meta information about the message being processed
     */

  }, {
    key: "_setLegacyIds",
    value: function _setLegacyIds(message, meta) {
      if (this.enableI18nLegacyMessageIdFormat) {
        message.legacyIds = [computeDigest(message), computeDecimalDigest(message)];
      } else if (typeof meta !== 'string') {
        // This occurs if we are doing the 2nd pass after whitespace removal (see `parseTemplate()` in
        // `packages/compiler/src/render3/view/template.ts`).
        // In that case we want to reuse the legacy message generated in the 1st pass (see
        // `setI18nRefs()`).
        var previousMessage = meta instanceof Message ? meta : meta instanceof IcuPlaceholder ? meta.previousMessage : undefined;
        message.legacyIds = previousMessage ? previousMessage.legacyIds : [];
      }
    }
  }, {
    key: "_reportError",
    value: function _reportError(node, msg) {
      this._errors.push(new I18nError(node.sourceSpan, msg));
    }
  }]);

  return I18nMetaVisitor;
}();
/** I18n separators for metadata **/


var I18N_MEANING_SEPARATOR = '|';
var I18N_ID_SEPARATOR = '@@';
/**
 * Parses i18n metas like:
 *  - "@@id",
 *  - "description[@@id]",
 *  - "meaning|description[@@id]"
 * and returns an object with parsed output.
 *
 * @param meta String that represents i18n meta
 * @returns Object with id, meaning and description fields
 */

function parseI18nMeta() {
  var meta = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var customId;
  var meaning;
  var description;
  meta = meta.trim();

  if (meta) {
    var idIndex = meta.indexOf(I18N_ID_SEPARATOR);
    var descIndex = meta.indexOf(I18N_MEANING_SEPARATOR);
    var meaningAndDesc;

    var _ref9 = idIndex > -1 ? [meta.slice(0, idIndex), meta.slice(idIndex + 2)] : [meta, ''];

    var _ref10 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_slicedToArray_js__WEBPACK_IMPORTED_MODULE_3__["default"])(_ref9, 2);

    meaningAndDesc = _ref10[0];
    customId = _ref10[1];

    var _ref11 = descIndex > -1 ? [meaningAndDesc.slice(0, descIndex), meaningAndDesc.slice(descIndex + 1)] : ['', meaningAndDesc];

    var _ref12 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_slicedToArray_js__WEBPACK_IMPORTED_MODULE_3__["default"])(_ref11, 2);

    meaning = _ref12[0];
    description = _ref12[1];
  }

  return {
    customId: customId,
    meaning: meaning,
    description: description
  };
} // Converts i18n meta information for a message (id, description, meaning)
// to a JsDoc statement formatted as expected by the Closure compiler.


function i18nMetaToJSDoc(meta) {
  var tags = [];

  if (meta.description) {
    tags.push({
      tagName: "desc"
      /* o.JSDocTagName.Desc */
      ,
      text: meta.description
    });
  } else {
    // Suppress the JSCompiler warning that a `@desc` was not given for this message.
    tags.push({
      tagName: "suppress"
      /* o.JSDocTagName.Suppress */
      ,
      text: '{msgDescriptions}'
    });
  }

  if (meta.meaning) {
    tags.push({
      tagName: "meaning"
      /* o.JSDocTagName.Meaning */
      ,
      text: meta.meaning
    });
  }

  return jsDocComment(tags);
}
/** Closure uses `goog.getMsg(message)` to lookup translations */


var GOOG_GET_MSG = 'goog.getMsg';
/**
 * Generates a `goog.getMsg()` statement and reassignment. The template:
 *
 * ```html
 * <div i18n>Sent from {{ sender }} to <span class="receiver">{{ receiver }}</span></div>
 * ```
 *
 * Generates:
 *
 * ```typescript
 * const MSG_FOO = goog.getMsg(
 *   // Message template.
 *   'Sent from {$interpolation} to {$startTagSpan}{$interpolation_1}{$closeTagSpan}.',
 *   // Placeholder values, set to magic strings which get replaced by the Angular runtime.
 *   {
 *     'interpolation': '\uFFFD0\uFFFD',
 *     'startTagSpan': '\uFFFD1\uFFFD',
 *     'interpolation_1': '\uFFFD2\uFFFD',
 *     'closeTagSpan': '\uFFFD3\uFFFD',
 *   },
 *   // Options bag.
 *   {
 *     // Maps each placeholder to the original Angular source code which generates it's value.
 *     original_code: {
 *       'interpolation': '{{ sender }}',
 *       'startTagSpan': '<span class="receiver">',
 *       'interploation_1': '{{ receiver }}',
 *       'closeTagSpan': '</span>',
 *     },
 *   },
 * );
 * const I18N_0 = MSG_FOO;
 * ```
 */

function createGoogleGetMsgStatements(variable$1, message, closureVar, placeholderValues) {
  var messageString = serializeI18nMessageForGetMsg(message);
  var args = [literal(messageString)];

  if (Object.keys(placeholderValues).length) {
    // Message template parameters containing the magic strings replaced by the Angular runtime with
    // real data, e.g. `{'interpolation': '\uFFFD0\uFFFD'}`.
    args.push(mapLiteral(formatI18nPlaceholderNamesInMap(placeholderValues, true
    /* useCamelCase */
    ), true
    /* quoted */
    )); // Message options object, which contains original source code for placeholders (as they are
    // present in a template, e.g.
    // `{original_code: {'interpolation': '{{ name }}', 'startTagSpan': '<span>'}}`.

    args.push(mapLiteral({
      original_code: literalMap(Object.keys(placeholderValues).map(function (param) {
        return {
          key: formatI18nPlaceholderName(param),
          quoted: true,
          value: message.placeholders[param] ? // Get source span for typical placeholder if it exists.
          literal(message.placeholders[param].sourceSpan.toString()) : // Otherwise must be an ICU expression, get it's source span.
          literal(message.placeholderToMessage[param].nodes.map(function (node) {
            return node.sourceSpan.toString();
          }).join(''))
        };
      }))
    }));
  } // /**
  //  * @desc description of message
  //  * @meaning meaning of message
  //  */
  // const MSG_... = goog.getMsg(..);
  // I18N_X = MSG_...;


  var googGetMsgStmt = closureVar.set(variable(GOOG_GET_MSG).callFn(args)).toConstDecl();
  googGetMsgStmt.addLeadingComment(i18nMetaToJSDoc(message));
  var i18nAssignmentStmt = new ExpressionStatement(variable$1.set(closureVar));
  return [googGetMsgStmt, i18nAssignmentStmt];
}
/**
 * This visitor walks over i18n tree and generates its string representation, including ICUs and
 * placeholders in `{$placeholder}` (for plain messages) or `{PLACEHOLDER}` (inside ICUs) format.
 */


var GetMsgSerializerVisitor = /*#__PURE__*/function () {
  function GetMsgSerializerVisitor() {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, GetMsgSerializerVisitor);
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(GetMsgSerializerVisitor, [{
    key: "formatPh",
    value: function formatPh(value) {
      return "{$".concat(formatI18nPlaceholderName(value), "}");
    }
  }, {
    key: "visitText",
    value: function visitText(text) {
      return text.value;
    }
  }, {
    key: "visitContainer",
    value: function visitContainer(container) {
      var _this136 = this;

      return container.children.map(function (child) {
        return child.visit(_this136);
      }).join('');
    }
  }, {
    key: "visitIcu",
    value: function visitIcu(icu) {
      return serializeIcuNode(icu);
    }
  }, {
    key: "visitTagPlaceholder",
    value: function visitTagPlaceholder(ph) {
      var _this137 = this;

      return ph.isVoid ? this.formatPh(ph.startName) : "".concat(this.formatPh(ph.startName)).concat(ph.children.map(function (child) {
        return child.visit(_this137);
      }).join('')).concat(this.formatPh(ph.closeName));
    }
  }, {
    key: "visitPlaceholder",
    value: function visitPlaceholder(ph) {
      return this.formatPh(ph.name);
    }
  }, {
    key: "visitIcuPlaceholder",
    value: function visitIcuPlaceholder(ph, context) {
      return this.formatPh(ph.name);
    }
  }]);

  return GetMsgSerializerVisitor;
}();

var serializerVisitor = new GetMsgSerializerVisitor();

function serializeI18nMessageForGetMsg(message) {
  return message.nodes.map(function (node) {
    return node.visit(serializerVisitor, null);
  }).join('');
}

function createLocalizeStatements(variable, message, params) {
  var _serializeI18nMessage = serializeI18nMessageForLocalize(message),
      messageParts = _serializeI18nMessage.messageParts,
      placeHolders = _serializeI18nMessage.placeHolders;

  var sourceSpan = getSourceSpan(message);
  var expressions = placeHolders.map(function (ph) {
    return params[ph.text];
  });
  var localizedString$1 = localizedString(message, messageParts, placeHolders, expressions, sourceSpan);
  var variableInitialization = variable.set(localizedString$1);
  return [new ExpressionStatement(variableInitialization)];
}
/**
 * This visitor walks over an i18n tree, capturing literal strings and placeholders.
 *
 * The result can be used for generating the `$localize` tagged template literals.
 */


var LocalizeSerializerVisitor = /*#__PURE__*/function () {
  function LocalizeSerializerVisitor(placeholderToMessage, pieces) {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, LocalizeSerializerVisitor);

    this.placeholderToMessage = placeholderToMessage;
    this.pieces = pieces;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(LocalizeSerializerVisitor, [{
    key: "visitText",
    value: function visitText(text) {
      if (this.pieces[this.pieces.length - 1] instanceof LiteralPiece) {
        // Two literal pieces in a row means that there was some comment node in-between.
        this.pieces[this.pieces.length - 1].text += text.value;
      } else {
        var sourceSpan = new ParseSourceSpan(text.sourceSpan.fullStart, text.sourceSpan.end, text.sourceSpan.fullStart, text.sourceSpan.details);
        this.pieces.push(new LiteralPiece(text.value, sourceSpan));
      }
    }
  }, {
    key: "visitContainer",
    value: function visitContainer(container) {
      var _this138 = this;

      container.children.forEach(function (child) {
        return child.visit(_this138);
      });
    }
  }, {
    key: "visitIcu",
    value: function visitIcu(icu) {
      this.pieces.push(new LiteralPiece(serializeIcuNode(icu), icu.sourceSpan));
    }
  }, {
    key: "visitTagPlaceholder",
    value: function visitTagPlaceholder(ph) {
      var _this139 = this;

      var _a, _b;

      this.pieces.push(this.createPlaceholderPiece(ph.startName, (_a = ph.startSourceSpan) !== null && _a !== void 0 ? _a : ph.sourceSpan));

      if (!ph.isVoid) {
        ph.children.forEach(function (child) {
          return child.visit(_this139);
        });
        this.pieces.push(this.createPlaceholderPiece(ph.closeName, (_b = ph.endSourceSpan) !== null && _b !== void 0 ? _b : ph.sourceSpan));
      }
    }
  }, {
    key: "visitPlaceholder",
    value: function visitPlaceholder(ph) {
      this.pieces.push(this.createPlaceholderPiece(ph.name, ph.sourceSpan));
    }
  }, {
    key: "visitIcuPlaceholder",
    value: function visitIcuPlaceholder(ph) {
      this.pieces.push(this.createPlaceholderPiece(ph.name, ph.sourceSpan, this.placeholderToMessage[ph.name]));
    }
  }, {
    key: "createPlaceholderPiece",
    value: function createPlaceholderPiece(name, sourceSpan, associatedMessage) {
      return new PlaceholderPiece(formatI18nPlaceholderName(name,
      /* useCamelCase */
      false), sourceSpan, associatedMessage);
    }
  }]);

  return LocalizeSerializerVisitor;
}();
/**
 * Serialize an i18n message into two arrays: messageParts and placeholders.
 *
 * These arrays will be used to generate `$localize` tagged template literals.
 *
 * @param message The message to be serialized.
 * @returns an object containing the messageParts and placeholders.
 */


function serializeI18nMessageForLocalize(message) {
  var pieces = [];
  var serializerVisitor = new LocalizeSerializerVisitor(message.placeholderToMessage, pieces);
  message.nodes.forEach(function (node) {
    return node.visit(serializerVisitor);
  });
  return processMessagePieces(pieces);
}

function getSourceSpan(message) {
  var startNode = message.nodes[0];
  var endNode = message.nodes[message.nodes.length - 1];
  return new ParseSourceSpan(startNode.sourceSpan.fullStart, endNode.sourceSpan.end, startNode.sourceSpan.fullStart, startNode.sourceSpan.details);
}
/**
 * Convert the list of serialized MessagePieces into two arrays.
 *
 * One contains the literal string pieces and the other the placeholders that will be replaced by
 * expressions when rendering `$localize` tagged template literals.
 *
 * @param pieces The pieces to process.
 * @returns an object containing the messageParts and placeholders.
 */


function processMessagePieces(pieces) {
  var messageParts = [];
  var placeHolders = [];

  if (pieces[0] instanceof PlaceholderPiece) {
    // The first piece was a placeholder so we need to add an initial empty message part.
    messageParts.push(createEmptyMessagePart(pieces[0].sourceSpan.start));
  }

  for (var i = 0; i < pieces.length; i++) {
    var part = pieces[i];

    if (part instanceof LiteralPiece) {
      messageParts.push(part);
    } else {
      placeHolders.push(part);

      if (pieces[i - 1] instanceof PlaceholderPiece) {
        // There were two placeholders in a row, so we need to add an empty message part.
        messageParts.push(createEmptyMessagePart(pieces[i - 1].sourceSpan.end));
      }
    }
  }

  if (pieces[pieces.length - 1] instanceof PlaceholderPiece) {
    // The last piece was a placeholder so we need to add a final empty message part.
    messageParts.push(createEmptyMessagePart(pieces[pieces.length - 1].sourceSpan.end));
  }

  return {
    messageParts: messageParts,
    placeHolders: placeHolders
  };
}

function createEmptyMessagePart(location) {
  return new LiteralPiece('', new ParseSourceSpan(location, location));
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
// Selector attribute name of `<ng-content>`


var NG_CONTENT_SELECT_ATTR = 'select'; // Attribute name of `ngProjectAs`.

var NG_PROJECT_AS_ATTR_NAME = 'ngProjectAs'; // Global symbols available only inside event bindings.

var EVENT_BINDING_SCOPE_GLOBALS = new Set(['$event']); // List of supported global targets for event listeners

var GLOBAL_TARGET_RESOLVERS = new Map([['window', Identifiers.resolveWindow], ['document', Identifiers.resolveDocument], ['body', Identifiers.resolveBody]]);
var LEADING_TRIVIA_CHARS = [' ', '\n', '\r', '\t']; //  if (rf & flags) { .. }

function renderFlagCheckIfStmt(flags, statements) {
  return ifStmt(variable(RENDER_FLAGS).bitwiseAnd(literal(flags), null, false), statements);
}

function prepareEventListenerParameters(eventAst) {
  var handlerName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var scope = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var type = eventAst.type,
      name = eventAst.name,
      target = eventAst.target,
      phase = eventAst.phase,
      handler = eventAst.handler;

  if (target && !GLOBAL_TARGET_RESOLVERS.has(target)) {
    throw new Error("Unexpected global target '".concat(target, "' defined for '").concat(name, "' event.\n        Supported list of global targets: ").concat(Array.from(GLOBAL_TARGET_RESOLVERS.keys()), "."));
  }

  var eventArgumentName = '$event';
  var implicitReceiverAccesses = new Set();
  var implicitReceiverExpr = scope === null || scope.bindingLevel === 0 ? variable(CONTEXT_NAME) : scope.getOrCreateSharedContextVar(0);
  var bindingStatements = convertActionBinding(scope, implicitReceiverExpr, handler, 'b', eventAst.handlerSpan, implicitReceiverAccesses, EVENT_BINDING_SCOPE_GLOBALS);
  var statements = [];
  var variableDeclarations = scope === null || scope === void 0 ? void 0 : scope.variableDeclarations();
  var restoreViewStatement = scope === null || scope === void 0 ? void 0 : scope.restoreViewStatement();

  if (variableDeclarations) {
    // `variableDeclarations` needs to run first, because
    // `restoreViewStatement` depends on the result.
    statements.push.apply(statements, (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(variableDeclarations));
  }

  statements.push.apply(statements, (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(bindingStatements));

  if (restoreViewStatement) {
    statements.unshift(restoreViewStatement); // If there's a `restoreView` call, we need to reset the view at the end of the listener
    // in order to avoid a leak. If there's a `return` statement already, we wrap it in the
    // call, e.g. `return resetView(ctx.foo())`. Otherwise we add the call as the last statement.

    var lastStatement = statements[statements.length - 1];

    if (lastStatement instanceof ReturnStatement) {
      statements[statements.length - 1] = new ReturnStatement(invokeInstruction(lastStatement.value.sourceSpan, Identifiers.resetView, [lastStatement.value]));
    } else {
      statements.push(new ExpressionStatement(invokeInstruction(null, Identifiers.resetView, [])));
    }
  }

  var eventName = type === 1
  /* ParsedEventType.Animation */
  ? prepareSyntheticListenerName(name, phase) : name;
  var fnName = handlerName && sanitizeIdentifier(handlerName);
  var fnArgs = [];

  if (implicitReceiverAccesses.has(eventArgumentName)) {
    fnArgs.push(new FnParam(eventArgumentName, DYNAMIC_TYPE));
  }

  var handlerFn = fn(fnArgs, statements, INFERRED_TYPE, null, fnName);
  var params = [literal(eventName), handlerFn];

  if (target) {
    params.push(literal(false), // `useCapture` flag, defaults to `false`
    importExpr(GLOBAL_TARGET_RESOLVERS.get(target)));
  }

  return params;
}

function createComponentDefConsts() {
  return {
    prepareStatements: [],
    constExpressions: [],
    i18nVarRefsCache: new Map()
  };
}

var TemplateDefinitionBuilder = /*#__PURE__*/function () {
  function TemplateDefinitionBuilder(constantPool, parentBindingScope) {
    var _this140 = this;

    var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var contextName = arguments.length > 3 ? arguments[3] : undefined;
    var i18nContext = arguments.length > 4 ? arguments[4] : undefined;
    var templateIndex = arguments.length > 5 ? arguments[5] : undefined;
    var templateName = arguments.length > 6 ? arguments[6] : undefined;

    var _namespace = arguments.length > 7 ? arguments[7] : undefined;

    var relativeContextFilePath = arguments.length > 8 ? arguments[8] : undefined;
    var i18nUseExternalIds = arguments.length > 9 ? arguments[9] : undefined;

    var _constants = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : createComponentDefConsts();

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, TemplateDefinitionBuilder);

    this.constantPool = constantPool;
    this.level = level;
    this.contextName = contextName;
    this.i18nContext = i18nContext;
    this.templateIndex = templateIndex;
    this.templateName = templateName;
    this._namespace = _namespace;
    this.i18nUseExternalIds = i18nUseExternalIds;
    this._constants = _constants;
    this._dataIndex = 0;
    this._bindingContext = 0;
    this._prefixCode = [];
    /**
     * List of callbacks to generate creation mode instructions. We store them here as we process
     * the template so bindings in listeners are resolved only once all nodes have been visited.
     * This ensures all local refs and context variables are available for matching.
     */

    this._creationCodeFns = [];
    /**
     * List of callbacks to generate update mode instructions. We store them here as we process
     * the template so bindings are resolved only once all nodes have been visited. This ensures
     * all local refs and context variables are available for matching.
     */

    this._updateCodeFns = [];
    /** Index of the currently-selected node. */

    this._currentIndex = 0;
    /** Temporary variable declarations generated from visiting pipes, literals, etc. */

    this._tempVariables = [];
    /**
     * List of callbacks to build nested templates. Nested templates must not be visited until
     * after the parent template has finished visiting all of its nodes. This ensures that all
     * local ref bindings in nested templates are able to find local ref values if the refs
     * are defined after the template declaration.
     */

    this._nestedTemplateFns = []; // i18n context local to this template

    this.i18n = null; // Number of slots to reserve for pureFunctions

    this._pureFunctionSlots = 0; // Number of binding slots

    this._bindingSlots = 0; // Projection slots found in the template. Projection slots can distribute projected
    // nodes based on a selector, or can just use the wildcard selector to match
    // all nodes which aren't matching any selector.

    this._ngContentReservedSlots = []; // Number of non-default selectors found in all parent templates of this template. We need to
    // track it to properly adjust projection slot index in the `projection` instruction.

    this._ngContentSelectorsOffset = 0; // Expression that should be used as implicit receiver when converting template
    // expressions to output AST.

    this._implicitReceiverExpr = null; // These should be handled in the template or element directly.

    this.visitReference = invalid;
    this.visitVariable = invalid;
    this.visitTextAttribute = invalid;
    this.visitBoundAttribute = invalid;
    this.visitBoundEvent = invalid;
    this._bindingScope = parentBindingScope.nestedScope(level); // Turn the relative context file path into an identifier by replacing non-alphanumeric
    // characters with underscores.

    this.fileBasedI18nSuffix = relativeContextFilePath.replace(/[^A-Za-z0-9]/g, '_') + '_';
    this._valueConverter = new ValueConverter(constantPool, function () {
      return _this140.allocateDataSlot();
    }, function (numSlots) {
      return _this140.allocatePureFunctionSlots(numSlots);
    }, function (name, localName, slot, value) {
      _this140._bindingScope.set(_this140.level, localName, value);

      _this140.creationInstruction(null, Identifiers.pipe, [literal(slot), literal(name)]);
    });
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(TemplateDefinitionBuilder, [{
    key: "buildTemplateFunction",
    value: function buildTemplateFunction(nodes, variables) {
      var _this141 = this;

      var ngContentSelectorsOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var i18n = arguments.length > 3 ? arguments[3] : undefined;
      this._ngContentSelectorsOffset = ngContentSelectorsOffset;

      if (this._namespace !== Identifiers.namespaceHTML) {
        this.creationInstruction(null, this._namespace);
      } // Create variable bindings


      variables.forEach(function (v) {
        return _this141.registerContextVariables(v);
      }); // Initiate i18n context in case:
      // - this template has parent i18n context
      // - or the template has i18n meta associated with it,
      //   but it's not initiated by the Element (e.g. <ng-template i18n>)

      var initI18nContext = this.i18nContext || isI18nRootNode(i18n) && !isSingleI18nIcu(i18n) && !(isSingleElementTemplate(nodes) && nodes[0].i18n === i18n);
      var selfClosingI18nInstruction = hasTextChildrenOnly(nodes);

      if (initI18nContext) {
        this.i18nStart(null, i18n, selfClosingI18nInstruction);
      } // This is the initial pass through the nodes of this template. In this pass, we
      // queue all creation mode and update mode instructions for generation in the second
      // pass. It's necessary to separate the passes to ensure local refs are defined before
      // resolving bindings. We also count bindings in this pass as we walk bound expressions.


      visitAll$1(this, nodes); // Add total binding count to pure function count so pure function instructions are
      // generated with the correct slot offset when update instructions are processed.

      this._pureFunctionSlots += this._bindingSlots; // Pipes are walked in the first pass (to enqueue `pipe()` creation instructions and
      // `pipeBind` update instructions), so we have to update the slot offsets manually
      // to account for bindings.

      this._valueConverter.updatePipeSlotOffsets(this._bindingSlots); // Nested templates must be processed before creation instructions so template()
      // instructions can be generated with the correct internal const count.


      this._nestedTemplateFns.forEach(function (buildTemplateFn) {
        return buildTemplateFn();
      }); // Output the `projectionDef` instruction when some `<ng-content>` tags are present.
      // The `projectionDef` instruction is only emitted for the component template and
      // is skipped for nested templates (<ng-template> tags).


      if (this.level === 0 && this._ngContentReservedSlots.length) {
        var parameters = []; // By default the `projectionDef` instructions creates one slot for the wildcard
        // selector if no parameters are passed. Therefore we only want to allocate a new
        // array for the projection slots if the default projection slot is not sufficient.

        if (this._ngContentReservedSlots.length > 1 || this._ngContentReservedSlots[0] !== '*') {
          var r3ReservedSlots = this._ngContentReservedSlots.map(function (s) {
            return s !== '*' ? parseSelectorToR3Selector(s) : s;
          });

          parameters.push(this.constantPool.getConstLiteral(asLiteral(r3ReservedSlots), true));
        } // Since we accumulate ngContent selectors while processing template elements,
        // we *prepend* `projectionDef` to creation instructions block, to put it before
        // any `projection` instructions


        this.creationInstruction(null, Identifiers.projectionDef, parameters,
        /* prepend */
        true);
      }

      if (initI18nContext) {
        this.i18nEnd(null, selfClosingI18nInstruction);
      } // Generate all the creation mode instructions (e.g. resolve bindings in listeners)


      var creationStatements = getInstructionStatements(this._creationCodeFns); // Generate all the update mode instructions (e.g. resolve property or text bindings)

      var updateStatements = getInstructionStatements(this._updateCodeFns); //  Variable declaration must occur after binding resolution so we can generate context
      //  instructions that build on each other.
      // e.g. const b = nextContext().$implicit(); const b = nextContext();

      var creationVariables = this._bindingScope.viewSnapshotStatements();

      var updateVariables = this._bindingScope.variableDeclarations().concat(this._tempVariables);

      var creationBlock = creationStatements.length > 0 ? [renderFlagCheckIfStmt(1
      /* core.RenderFlags.Create */
      , creationVariables.concat(creationStatements))] : [];
      var updateBlock = updateStatements.length > 0 ? [renderFlagCheckIfStmt(2
      /* core.RenderFlags.Update */
      , updateVariables.concat(updateStatements))] : [];
      return fn( // i.e. (rf: RenderFlags, ctx: any)
      [new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null)], [].concat((0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(this._prefixCode), creationBlock, updateBlock), INFERRED_TYPE, null, this.templateName);
    } // LocalResolver

  }, {
    key: "getLocal",
    value: function getLocal(name) {
      return this._bindingScope.get(name);
    } // LocalResolver

  }, {
    key: "notifyImplicitReceiverUse",
    value: function notifyImplicitReceiverUse() {
      this._bindingScope.notifyImplicitReceiverUse();
    } // LocalResolver

  }, {
    key: "maybeRestoreView",
    value: function maybeRestoreView() {
      this._bindingScope.maybeRestoreView();
    }
  }, {
    key: "i18nTranslate",
    value: function i18nTranslate(message) {
      var _this$_constants$prep;

      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var ref = arguments.length > 2 ? arguments[2] : undefined;
      var transformFn = arguments.length > 3 ? arguments[3] : undefined;

      var _ref = ref || this.i18nGenerateMainBlockVar(); // Closure Compiler requires const names to start with `MSG_` but disallows any other const to
      // start with `MSG_`. We define a variable starting with `MSG_` just for the `goog.getMsg` call


      var closureVar = this.i18nGenerateClosureVar(message.id);
      var statements = getTranslationDeclStmts(message, _ref, closureVar, params, transformFn);

      (_this$_constants$prep = this._constants.prepareStatements).push.apply(_this$_constants$prep, (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(statements));

      return _ref;
    }
  }, {
    key: "registerContextVariables",
    value: function registerContextVariables(variable$1) {
      var scopedName = this._bindingScope.freshReferenceName();

      var retrievalLevel = this.level;
      var lhs = variable(variable$1.name + scopedName);

      this._bindingScope.set(retrievalLevel, variable$1.name, lhs, 1
      /* DeclarationPriority.CONTEXT */
      , function (scope, relativeLevel) {
        var rhs;

        if (scope.bindingLevel === retrievalLevel) {
          if (scope.isListenerScope() && scope.hasRestoreViewVariable()) {
            // e.g. restoredCtx.
            // We have to get the context from a view reference, if one is available, because
            // the context that was passed in during creation may not be correct anymore.
            // For more information see: https://github.com/angular/angular/pull/40360.
            rhs = variable(RESTORED_VIEW_CONTEXT_NAME);
            scope.notifyRestoredViewContextUse();
          } else {
            // e.g. ctx
            rhs = variable(CONTEXT_NAME);
          }
        } else {
          var sharedCtxVar = scope.getSharedContextName(retrievalLevel); // e.g. ctx_r0   OR  x(2);

          rhs = sharedCtxVar ? sharedCtxVar : generateNextContextExpr(relativeLevel);
        } // e.g. const $item$ = x(2).$implicit;


        return [lhs.set(rhs.prop(variable$1.value || IMPLICIT_REFERENCE)).toConstDecl()];
      });
    }
  }, {
    key: "i18nAppendBindings",
    value: function i18nAppendBindings(expressions) {
      var _this142 = this;

      if (expressions.length > 0) {
        expressions.forEach(function (expression) {
          return _this142.i18n.appendBinding(expression);
        });
      }
    }
  }, {
    key: "i18nBindProps",
    value: function i18nBindProps(props) {
      var _this143 = this;

      var bound = {};
      Object.keys(props).forEach(function (key) {
        var prop = props[key];

        if (prop instanceof Text$3) {
          bound[key] = literal(prop.value);
        } else {
          var value = prop.value.visit(_this143._valueConverter);

          _this143.allocateBindingSlots(value);

          if (value instanceof Interpolation) {
            var strings = value.strings,
                expressions = value.expressions;
            var _this143$i18n = _this143.i18n,
                id = _this143$i18n.id,
                bindings = _this143$i18n.bindings;
            var label = assembleI18nBoundString(strings, bindings.size, id);

            _this143.i18nAppendBindings(expressions);

            bound[key] = literal(label);
          }
        }
      });
      return bound;
    } // Generates top level vars for i18n blocks (i.e. `i18n_N`).

  }, {
    key: "i18nGenerateMainBlockVar",
    value: function i18nGenerateMainBlockVar() {
      return variable(this.constantPool.uniqueName(TRANSLATION_VAR_PREFIX));
    } // Generates vars with Closure-specific names for i18n blocks (i.e. `MSG_XXX`).

  }, {
    key: "i18nGenerateClosureVar",
    value: function i18nGenerateClosureVar(messageId) {
      var name;
      var suffix = this.fileBasedI18nSuffix.toUpperCase();

      if (this.i18nUseExternalIds) {
        var prefix = getTranslationConstPrefix("EXTERNAL_");
        var uniqueSuffix = this.constantPool.uniqueName(suffix);
        name = "".concat(prefix).concat(sanitizeIdentifier(messageId), "$$").concat(uniqueSuffix);
      } else {
        var _prefix = getTranslationConstPrefix(suffix);

        name = this.constantPool.uniqueName(_prefix);
      }

      return variable(name);
    }
  }, {
    key: "i18nUpdateRef",
    value: function i18nUpdateRef(context) {
      var icus = context.icus,
          meta = context.meta,
          isRoot = context.isRoot,
          isResolved = context.isResolved,
          isEmitted = context.isEmitted;

      if (isRoot && isResolved && !isEmitted && !isSingleI18nIcu(meta)) {
        context.isEmitted = true;
        var placeholders = context.getSerializedPlaceholders();
        var icuMapping = {};
        var params = placeholders.size ? placeholdersToParams(placeholders) : {};

        if (icus.size) {
          icus.forEach(function (refs, key) {
            if (refs.length === 1) {
              // if we have one ICU defined for a given
              // placeholder - just output its reference
              params[key] = refs[0];
            } else {
              // ... otherwise we need to activate post-processing
              // to replace ICU placeholders with proper values
              var placeholder = wrapI18nPlaceholder("".concat(I18N_ICU_MAPPING_PREFIX).concat(key));
              params[key] = literal(placeholder);
              icuMapping[key] = literalArr(refs);
            }
          });
        } // translation requires post processing in 2 cases:
        // - if we have placeholders with multiple values (ex. `START_DIV`: [�#1�, �#2�, ...])
        // - if we have multiple ICUs that refer to the same placeholder name


        var needsPostprocessing = Array.from(placeholders.values()).some(function (value) {
          return value.length > 1;
        }) || Object.keys(icuMapping).length;
        var transformFn;

        if (needsPostprocessing) {
          transformFn = function transformFn(raw) {
            var args = [raw];

            if (Object.keys(icuMapping).length) {
              args.push(mapLiteral(icuMapping, true));
            }

            return invokeInstruction(null, Identifiers.i18nPostprocess, args);
          };
        }

        this.i18nTranslate(meta, params, context.ref, transformFn);
      }
    }
  }, {
    key: "i18nStart",
    value: function i18nStart() {
      var span = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var meta = arguments.length > 1 ? arguments[1] : undefined;
      var selfClosing = arguments.length > 2 ? arguments[2] : undefined;
      var index = this.allocateDataSlot();
      this.i18n = this.i18nContext ? this.i18nContext.forkChildContext(index, this.templateIndex, meta) : new I18nContext(index, this.i18nGenerateMainBlockVar(), 0, this.templateIndex, meta); // generate i18nStart instruction

      var _this$i18n = this.i18n,
          id = _this$i18n.id,
          ref = _this$i18n.ref;
      var params = [literal(index), this.addToConsts(ref)];

      if (id > 0) {
        // do not push 3rd argument (sub-block id)
        // into i18nStart call for top level i18n context
        params.push(literal(id));
      }

      this.creationInstruction(span, selfClosing ? Identifiers.i18n : Identifiers.i18nStart, params);
    }
  }, {
    key: "i18nEnd",
    value: function i18nEnd() {
      var _this144 = this;

      var span = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var selfClosing = arguments.length > 1 ? arguments[1] : undefined;

      if (!this.i18n) {
        throw new Error('i18nEnd is executed with no i18n context present');
      }

      if (this.i18nContext) {
        this.i18nContext.reconcileChildContext(this.i18n);
        this.i18nUpdateRef(this.i18nContext);
      } else {
        this.i18nUpdateRef(this.i18n);
      } // setup accumulated bindings


      var _this$i18n2 = this.i18n,
          index = _this$i18n2.index,
          bindings = _this$i18n2.bindings;

      if (bindings.size) {
        var _iterator20 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper_js__WEBPACK_IMPORTED_MODULE_9__["default"])(bindings),
            _step20;

        try {
          var _loop = function _loop() {
            var binding = _step20.value;

            // for i18n block, advance to the most recent element index (by taking the current number of
            // elements and subtracting one) before invoking `i18nExp` instructions, to make sure the
            // necessary lifecycle hooks of components/directives are properly flushed.
            _this144.updateInstructionWithAdvance(_this144.getConstCount() - 1, span, Identifiers.i18nExp, function () {
              return _this144.convertPropertyBinding(binding);
            });
          };

          for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {
            _loop();
          }
        } catch (err) {
          _iterator20.e(err);
        } finally {
          _iterator20.f();
        }

        this.updateInstruction(span, Identifiers.i18nApply, [literal(index)]);
      }

      if (!selfClosing) {
        this.creationInstruction(span, Identifiers.i18nEnd);
      }

      this.i18n = null; // reset local i18n context
    }
  }, {
    key: "i18nAttributesInstruction",
    value: function i18nAttributesInstruction(nodeIndex, attrs, sourceSpan) {
      var _this145 = this;

      var hasBindings = false;
      var i18nAttrArgs = [];
      attrs.forEach(function (attr) {
        var message = attr.i18n;
        var converted = attr.value.visit(_this145._valueConverter);

        _this145.allocateBindingSlots(converted);

        if (converted instanceof Interpolation) {
          var placeholders = assembleBoundTextPlaceholders(message);
          var params = placeholdersToParams(placeholders);
          i18nAttrArgs.push(literal(attr.name), _this145.i18nTranslate(message, params));
          converted.expressions.forEach(function (expression) {
            hasBindings = true;

            _this145.updateInstructionWithAdvance(nodeIndex, sourceSpan, Identifiers.i18nExp, function () {
              return _this145.convertPropertyBinding(expression);
            });
          });
        }
      });

      if (i18nAttrArgs.length > 0) {
        var index = literal(this.allocateDataSlot());
        var constIndex = this.addToConsts(literalArr(i18nAttrArgs));
        this.creationInstruction(sourceSpan, Identifiers.i18nAttributes, [index, constIndex]);

        if (hasBindings) {
          this.updateInstruction(sourceSpan, Identifiers.i18nApply, [index]);
        }
      }
    }
  }, {
    key: "getNamespaceInstruction",
    value: function getNamespaceInstruction(namespaceKey) {
      switch (namespaceKey) {
        case 'math':
          return Identifiers.namespaceMathML;

        case 'svg':
          return Identifiers.namespaceSVG;

        default:
          return Identifiers.namespaceHTML;
      }
    }
  }, {
    key: "addNamespaceInstruction",
    value: function addNamespaceInstruction(nsInstruction, element) {
      this._namespace = nsInstruction;
      this.creationInstruction(element.startSourceSpan, nsInstruction);
    }
    /**
     * Adds an update instruction for an interpolated property or attribute, such as
     * `prop="{{value}}"` or `attr.title="{{value}}"`
     */

  }, {
    key: "interpolatedUpdateInstruction",
    value: function interpolatedUpdateInstruction(instruction, elementIndex, attrName, input, value, params) {
      var _this146 = this;

      this.updateInstructionWithAdvance(elementIndex, input.sourceSpan, instruction, function () {
        return [literal(attrName)].concat((0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(_this146.getUpdateInstructionArguments(value)), (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(params));
      });
    }
  }, {
    key: "visitContent",
    value: function visitContent(ngContent) {
      var slot = this.allocateDataSlot();
      var projectionSlotIdx = this._ngContentSelectorsOffset + this._ngContentReservedSlots.length;
      var parameters = [literal(slot)];

      this._ngContentReservedSlots.push(ngContent.selector);

      var nonContentSelectAttributes = ngContent.attributes.filter(function (attr) {
        return attr.name.toLowerCase() !== NG_CONTENT_SELECT_ATTR;
      });
      var attributes = this.getAttributeExpressions(ngContent.name, nonContentSelectAttributes, [], []);

      if (attributes.length > 0) {
        parameters.push(literal(projectionSlotIdx), literalArr(attributes));
      } else if (projectionSlotIdx !== 0) {
        parameters.push(literal(projectionSlotIdx));
      }

      this.creationInstruction(ngContent.sourceSpan, Identifiers.projection, parameters);

      if (this.i18n) {
        this.i18n.appendProjection(ngContent.i18n, slot);
      }
    }
  }, {
    key: "visitElement",
    value: function visitElement(element) {
      var _this147 = this;

      var _a, _b;

      var elementIndex = this.allocateDataSlot();
      var stylingBuilder = new StylingBuilder(null);
      var isNonBindableMode = false;
      var isI18nRootElement = isI18nRootNode(element.i18n) && !isSingleI18nIcu(element.i18n);
      var outputAttrs = [];

      var _splitNsName = splitNsName(element.name),
          _splitNsName2 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_slicedToArray_js__WEBPACK_IMPORTED_MODULE_3__["default"])(_splitNsName, 2),
          namespaceKey = _splitNsName2[0],
          elementName = _splitNsName2[1];

      var isNgContainer$1 = isNgContainer(element.name); // Handle styling, i18n, ngNonBindable attributes

      var _iterator21 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper_js__WEBPACK_IMPORTED_MODULE_9__["default"])(element.attributes),
          _step21;

      try {
        for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {
          var attr = _step21.value;
          var name = attr.name,
              value = attr.value;

          if (name === NON_BINDABLE_ATTR) {
            isNonBindableMode = true;
          } else if (name === 'style') {
            stylingBuilder.registerStyleAttr(value);
          } else if (name === 'class') {
            stylingBuilder.registerClassAttr(value);
          } else {
            outputAttrs.push(attr);
          }
        } // Regular element or ng-container creation mode

      } catch (err) {
        _iterator21.e(err);
      } finally {
        _iterator21.f();
      }

      var parameters = [literal(elementIndex)];

      if (!isNgContainer$1) {
        parameters.push(literal(elementName));
      } // Add the attributes


      var allOtherInputs = [];
      var boundI18nAttrs = [];
      element.inputs.forEach(function (input) {
        var stylingInputWasSet = stylingBuilder.registerBoundInput(input);

        if (!stylingInputWasSet) {
          if (input.type === 0
          /* BindingType.Property */
          && input.i18n) {
            boundI18nAttrs.push(input);
          } else {
            allOtherInputs.push(input);
          }
        }
      }); // add attributes for directive and projection matching purposes

      var attributes = this.getAttributeExpressions(element.name, outputAttrs, allOtherInputs, element.outputs, stylingBuilder, [], boundI18nAttrs);
      parameters.push(this.addAttrsToConsts(attributes)); // local refs (ex.: <div #foo #bar="baz">)

      var refs = this.prepareRefsArray(element.references);
      parameters.push(this.addToConsts(refs));
      var wasInNamespace = this._namespace;
      var currentNamespace = this.getNamespaceInstruction(namespaceKey); // If the namespace is changing now, include an instruction to change it
      // during element creation.

      if (currentNamespace !== wasInNamespace) {
        this.addNamespaceInstruction(currentNamespace, element);
      }

      if (this.i18n) {
        this.i18n.appendElement(element.i18n, elementIndex);
      } // Note that we do not append text node instructions and ICUs inside i18n section,
      // so we exclude them while calculating whether current element has children


      var hasChildren = !isI18nRootElement && this.i18n ? !hasTextChildrenOnly(element.children) : element.children.length > 0;
      var createSelfClosingInstruction = !stylingBuilder.hasBindingsWithPipes && element.outputs.length === 0 && boundI18nAttrs.length === 0 && !hasChildren;
      var createSelfClosingI18nInstruction = !createSelfClosingInstruction && hasTextChildrenOnly(element.children);

      if (createSelfClosingInstruction) {
        this.creationInstruction(element.sourceSpan, isNgContainer$1 ? Identifiers.elementContainer : Identifiers.element, trimTrailingNulls(parameters));
      } else {
        this.creationInstruction(element.startSourceSpan, isNgContainer$1 ? Identifiers.elementContainerStart : Identifiers.elementStart, trimTrailingNulls(parameters));

        if (isNonBindableMode) {
          this.creationInstruction(element.startSourceSpan, Identifiers.disableBindings);
        }

        if (boundI18nAttrs.length > 0) {
          this.i18nAttributesInstruction(elementIndex, boundI18nAttrs, (_a = element.startSourceSpan) !== null && _a !== void 0 ? _a : element.sourceSpan);
        } // Generate Listeners (outputs)


        if (element.outputs.length > 0) {
          var _iterator22 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper_js__WEBPACK_IMPORTED_MODULE_9__["default"])(element.outputs),
              _step22;

          try {
            for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {
              var outputAst = _step22.value;
              this.creationInstruction(outputAst.sourceSpan, Identifiers.listener, this.prepareListenerParameter(element.name, outputAst, elementIndex));
            }
          } catch (err) {
            _iterator22.e(err);
          } finally {
            _iterator22.f();
          }
        } // Note: it's important to keep i18n/i18nStart instructions after i18nAttributes and
        // listeners, to make sure i18nAttributes instruction targets current element at runtime.


        if (isI18nRootElement) {
          this.i18nStart(element.startSourceSpan, element.i18n, createSelfClosingI18nInstruction);
        }
      } // the code here will collect all update-level styling instructions and add them to the
      // update block of the template function AOT code. Instructions like `styleProp`,
      // `styleMap`, `classMap`, `classProp`
      // are all generated and assigned in the code below.


      var stylingInstructions = stylingBuilder.buildUpdateLevelInstructions(this._valueConverter);
      var limit = stylingInstructions.length - 1;

      for (var i = 0; i <= limit; i++) {
        var instruction = stylingInstructions[i];
        this._bindingSlots += this.processStylingUpdateInstruction(elementIndex, instruction);
      } // the reason why `undefined` is used is because the renderer understands this as a
      // special value to symbolize that there is no RHS to this binding
      // TODO (matsko): revisit this once FW-959 is approached


      var emptyValueBindInstruction = literal(undefined);
      var propertyBindings = [];
      var attributeBindings = []; // Generate element input bindings

      allOtherInputs.forEach(function (input) {
        var inputType = input.type;

        if (inputType === 4
        /* BindingType.Animation */
        ) {
          var value = input.value.visit(_this147._valueConverter); // animation bindings can be presented in the following formats:
          // 1. [@binding]="fooExp"
          // 2. [@binding]="{value:fooExp, params:{...}}"
          // 3. [@binding]
          // 4. @binding
          // All formats will be valid for when a synthetic binding is created.
          // The reasoning for this is because the renderer should get each
          // synthetic binding value in the order of the array that they are
          // defined in...

          var hasValue = value instanceof LiteralPrimitive ? !!value.value : true;

          _this147.allocateBindingSlots(value);

          propertyBindings.push({
            span: input.sourceSpan,
            paramsOrFn: getBindingFunctionParams(function () {
              return hasValue ? _this147.convertPropertyBinding(value) : emptyValueBindInstruction;
            }, prepareSyntheticPropertyName(input.name))
          });
        } else {
          // we must skip attributes with associated i18n context, since these attributes are handled
          // separately and corresponding `i18nExp` and `i18nApply` instructions will be generated
          if (input.i18n) return;

          var _value2 = input.value.visit(_this147._valueConverter);

          if (_value2 !== undefined) {
            var params = [];

            var _splitNsName3 = splitNsName(input.name),
                _splitNsName4 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_slicedToArray_js__WEBPACK_IMPORTED_MODULE_3__["default"])(_splitNsName3, 2),
                attrNamespace = _splitNsName4[0],
                attrName = _splitNsName4[1];

            var isAttributeBinding = inputType === 1
            /* BindingType.Attribute */
            ;
            var sanitizationRef = resolveSanitizationFn(input.securityContext, isAttributeBinding);
            if (sanitizationRef) params.push(sanitizationRef);

            if (attrNamespace) {
              var namespaceLiteral = literal(attrNamespace);

              if (sanitizationRef) {
                params.push(namespaceLiteral);
              } else {
                // If there wasn't a sanitization ref, we need to add
                // an extra param so that we can pass in the namespace.
                params.push(literal(null), namespaceLiteral);
              }
            }

            _this147.allocateBindingSlots(_value2);

            if (inputType === 0
            /* BindingType.Property */
            ) {
              if (_value2 instanceof Interpolation) {
                // prop="{{value}}" and friends
                _this147.interpolatedUpdateInstruction(getPropertyInterpolationExpression(_value2), elementIndex, attrName, input, _value2, params);
              } else {
                // [prop]="value"
                // Collect all the properties so that we can chain into a single function at the end.
                propertyBindings.push({
                  span: input.sourceSpan,
                  paramsOrFn: getBindingFunctionParams(function () {
                    return _this147.convertPropertyBinding(_value2);
                  }, attrName, params)
                });
              }
            } else if (inputType === 1
            /* BindingType.Attribute */
            ) {
              if (_value2 instanceof Interpolation && getInterpolationArgsLength(_value2) > 1) {
                // attr.name="text{{value}}" and friends
                _this147.interpolatedUpdateInstruction(getAttributeInterpolationExpression(_value2), elementIndex, attrName, input, _value2, params);
              } else {
                var boundValue = _value2 instanceof Interpolation ? _value2.expressions[0] : _value2; // [attr.name]="value" or attr.name="{{value}}"
                // Collect the attribute bindings so that they can be chained at the end.

                attributeBindings.push({
                  span: input.sourceSpan,
                  paramsOrFn: getBindingFunctionParams(function () {
                    return _this147.convertPropertyBinding(boundValue);
                  }, attrName, params)
                });
              }
            } else {
              // class prop
              _this147.updateInstructionWithAdvance(elementIndex, input.sourceSpan, Identifiers.classProp, function () {
                return [literal(elementIndex), literal(attrName), _this147.convertPropertyBinding(_value2)].concat(params);
              });
            }
          }
        }
      });

      for (var _i8 = 0, _propertyBindings = propertyBindings; _i8 < _propertyBindings.length; _i8++) {
        var propertyBinding = _propertyBindings[_i8];
        this.updateInstructionWithAdvance(elementIndex, propertyBinding.span, Identifiers.property, propertyBinding.paramsOrFn);
      }

      for (var _i9 = 0, _attributeBindings = attributeBindings; _i9 < _attributeBindings.length; _i9++) {
        var attributeBinding = _attributeBindings[_i9];
        this.updateInstructionWithAdvance(elementIndex, attributeBinding.span, Identifiers.attribute, attributeBinding.paramsOrFn);
      } // Traverse element child nodes


      visitAll$1(this, element.children);

      if (!isI18nRootElement && this.i18n) {
        this.i18n.appendElement(element.i18n, elementIndex, true);
      }

      if (!createSelfClosingInstruction) {
        // Finish element construction mode.
        var span = (_b = element.endSourceSpan) !== null && _b !== void 0 ? _b : element.sourceSpan;

        if (isI18nRootElement) {
          this.i18nEnd(span, createSelfClosingI18nInstruction);
        }

        if (isNonBindableMode) {
          this.creationInstruction(span, Identifiers.enableBindings);
        }

        this.creationInstruction(span, isNgContainer$1 ? Identifiers.elementContainerEnd : Identifiers.elementEnd);
      }
    }
  }, {
    key: "visitTemplate",
    value: function visitTemplate(template) {
      var _this148 = this;

      var _a;

      var NG_TEMPLATE_TAG_NAME = 'ng-template';
      var templateIndex = this.allocateDataSlot();

      if (this.i18n) {
        this.i18n.appendTemplate(template.i18n, templateIndex);
      }

      var tagNameWithoutNamespace = template.tagName ? splitNsName(template.tagName)[1] : template.tagName;
      var contextName = "".concat(this.contextName).concat(template.tagName ? '_' + sanitizeIdentifier(template.tagName) : '', "_").concat(templateIndex);
      var templateName = "".concat(contextName, "_Template");
      var parameters = [literal(templateIndex), variable(templateName), // We don't care about the tag's namespace here, because we infer
      // it based on the parent nodes inside the template instruction.
      literal(tagNameWithoutNamespace)]; // prepare attributes parameter (including attributes used for directive matching)

      var attrsExprs = this.getAttributeExpressions(NG_TEMPLATE_TAG_NAME, template.attributes, template.inputs, template.outputs, undefined
      /* styles */
      , template.templateAttrs);
      parameters.push(this.addAttrsToConsts(attrsExprs)); // local refs (ex.: <ng-template #foo>)

      if (template.references && template.references.length) {
        var refs = this.prepareRefsArray(template.references);
        parameters.push(this.addToConsts(refs));
        parameters.push(importExpr(Identifiers.templateRefExtractor));
      } // Create the template function


      var templateVisitor = new TemplateDefinitionBuilder(this.constantPool, this._bindingScope, this.level + 1, contextName, this.i18n, templateIndex, templateName, this._namespace, this.fileBasedI18nSuffix, this.i18nUseExternalIds, this._constants); // Nested templates must not be visited until after their parent templates have completed
      // processing, so they are queued here until after the initial pass. Otherwise, we wouldn't
      // be able to support bindings in nested templates to local refs that occur after the
      // template definition. e.g. <div *ngIf="showing">{{ foo }}</div>  <div #foo></div>

      this._nestedTemplateFns.push(function () {
        var templateFunctionExpr = templateVisitor.buildTemplateFunction(template.children, template.variables, _this148._ngContentReservedSlots.length + _this148._ngContentSelectorsOffset, template.i18n);

        _this148.constantPool.statements.push(templateFunctionExpr.toDeclStmt(templateName));

        if (templateVisitor._ngContentReservedSlots.length) {
          var _this148$_ngContentRe;

          (_this148$_ngContentRe = _this148._ngContentReservedSlots).push.apply(_this148$_ngContentRe, (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(templateVisitor._ngContentReservedSlots));
        }
      }); // e.g. template(1, MyComp_Template_1)


      this.creationInstruction(template.sourceSpan, Identifiers.templateCreate, function () {
        parameters.splice(2, 0, literal(templateVisitor.getConstCount()), literal(templateVisitor.getVarCount()));
        return trimTrailingNulls(parameters);
      }); // handle property bindings e.g. ɵɵproperty('ngForOf', ctx.items), et al;

      this.templatePropertyBindings(templateIndex, template.templateAttrs); // Only add normal input/output binding instructions on explicit <ng-template> elements.

      if (tagNameWithoutNamespace === NG_TEMPLATE_TAG_NAME) {
        var _partitionArray = partitionArray(template.inputs, hasI18nMeta),
            _partitionArray2 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_slicedToArray_js__WEBPACK_IMPORTED_MODULE_3__["default"])(_partitionArray, 2),
            i18nInputs = _partitionArray2[0],
            inputs = _partitionArray2[1]; // Add i18n attributes that may act as inputs to directives. If such attributes are present,
        // generate `i18nAttributes` instruction. Note: we generate it only for explicit <ng-template>
        // elements, in case of inline templates, corresponding instructions will be generated in the
        // nested template function.


        if (i18nInputs.length > 0) {
          this.i18nAttributesInstruction(templateIndex, i18nInputs, (_a = template.startSourceSpan) !== null && _a !== void 0 ? _a : template.sourceSpan);
        } // Add the input bindings


        if (inputs.length > 0) {
          this.templatePropertyBindings(templateIndex, inputs);
        } // Generate listeners for directive output


        var _iterator23 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper_js__WEBPACK_IMPORTED_MODULE_9__["default"])(template.outputs),
            _step23;

        try {
          for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {
            var outputAst = _step23.value;
            this.creationInstruction(outputAst.sourceSpan, Identifiers.listener, this.prepareListenerParameter('ng_template', outputAst, templateIndex));
          }
        } catch (err) {
          _iterator23.e(err);
        } finally {
          _iterator23.f();
        }
      }
    }
  }, {
    key: "visitBoundText",
    value: function visitBoundText(text) {
      var _this149 = this;

      if (this.i18n) {
        var _value3 = text.value.visit(this._valueConverter);

        this.allocateBindingSlots(_value3);

        if (_value3 instanceof Interpolation) {
          this.i18n.appendBoundText(text.i18n);
          this.i18nAppendBindings(_value3.expressions);
        }

        return;
      }

      var nodeIndex = this.allocateDataSlot();
      this.creationInstruction(text.sourceSpan, Identifiers.text, [literal(nodeIndex)]);
      var value = text.value.visit(this._valueConverter);
      this.allocateBindingSlots(value);

      if (value instanceof Interpolation) {
        this.updateInstructionWithAdvance(nodeIndex, text.sourceSpan, getTextInterpolationExpression(value), function () {
          return _this149.getUpdateInstructionArguments(value);
        });
      } else {
        error('Text nodes should be interpolated and never bound directly.');
      }
    }
  }, {
    key: "visitText",
    value: function visitText(text) {
      // when a text element is located within a translatable
      // block, we exclude this text element from instructions set,
      // since it will be captured in i18n content and processed at runtime
      if (!this.i18n) {
        this.creationInstruction(text.sourceSpan, Identifiers.text, [literal(this.allocateDataSlot()), literal(text.value)]);
      }
    }
  }, {
    key: "visitIcu",
    value: function visitIcu(icu) {
      var initWasInvoked = false; // if an ICU was created outside of i18n block, we still treat
      // it as a translatable entity and invoke i18nStart and i18nEnd
      // to generate i18n context and the necessary instructions

      if (!this.i18n) {
        initWasInvoked = true;
        this.i18nStart(null, icu.i18n, true);
      }

      var i18n = this.i18n;
      var vars = this.i18nBindProps(icu.vars);
      var placeholders = this.i18nBindProps(icu.placeholders); // output ICU directly and keep ICU reference in context

      var message = icu.i18n; // we always need post-processing function for ICUs, to make sure that:
      // - all placeholders in a form of {PLACEHOLDER} are replaced with actual values (note:
      // `goog.getMsg` does not process ICUs and uses the `{PLACEHOLDER}` format for placeholders
      // inside ICUs)
      // - all ICU vars (such as `VAR_SELECT` or `VAR_PLURAL`) are replaced with correct values

      var transformFn = function transformFn(raw) {
        var params = Object.assign(Object.assign({}, vars), placeholders);
        var formatted = formatI18nPlaceholderNamesInMap(params,
        /* useCamelCase */
        false);
        return invokeInstruction(null, Identifiers.i18nPostprocess, [raw, mapLiteral(formatted, true)]);
      }; // in case the whole i18n message is a single ICU - we do not need to
      // create a separate top-level translation, we can use the root ref instead
      // and make this ICU a top-level translation
      // note: ICU placeholders are replaced with actual values in `i18nPostprocess` function
      // separately, so we do not pass placeholders into `i18nTranslate` function.


      if (isSingleI18nIcu(i18n.meta)) {
        this.i18nTranslate(message,
        /* placeholders */
        {}, i18n.ref, transformFn);
      } else {
        // output ICU directly and keep ICU reference in context
        var ref = this.i18nTranslate(message,
        /* placeholders */
        {},
        /* ref */
        undefined, transformFn);
        i18n.appendIcu(icuFromI18nMessage(message).name, ref);
      }

      if (initWasInvoked) {
        this.i18nEnd(null, true);
      }

      return null;
    }
  }, {
    key: "allocateDataSlot",
    value: function allocateDataSlot() {
      return this._dataIndex++;
    }
  }, {
    key: "getConstCount",
    value: function getConstCount() {
      return this._dataIndex;
    }
  }, {
    key: "getVarCount",
    value: function getVarCount() {
      return this._pureFunctionSlots;
    }
  }, {
    key: "getConsts",
    value: function getConsts() {
      return this._constants;
    }
  }, {
    key: "getNgContentSelectors",
    value: function getNgContentSelectors() {
      return this._ngContentReservedSlots.length ? this.constantPool.getConstLiteral(asLiteral(this._ngContentReservedSlots), true) : null;
    }
  }, {
    key: "bindingContext",
    value: function bindingContext() {
      return "".concat(this._bindingContext++);
    }
  }, {
    key: "templatePropertyBindings",
    value: function templatePropertyBindings(templateIndex, attrs) {
      var _this150 = this;

      var propertyBindings = [];

      var _iterator24 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper_js__WEBPACK_IMPORTED_MODULE_9__["default"])(attrs),
          _step24;

      try {
        var _loop2 = function _loop2() {
          var input = _step24.value;

          if (!(input instanceof BoundAttribute)) {
            return "continue";
          }

          var value = input.value.visit(_this150._valueConverter);

          if (value === undefined) {
            return "continue";
          }

          _this150.allocateBindingSlots(value);

          if (value instanceof Interpolation) {
            // Params typically contain attribute namespace and value sanitizer, which is applicable
            // for regular HTML elements, but not applicable for <ng-template> (since props act as
            // inputs to directives), so keep params array empty.
            var params = []; // prop="{{value}}" case

            _this150.interpolatedUpdateInstruction(getPropertyInterpolationExpression(value), templateIndex, input.name, input, value, params);
          } else {
            // [prop]="value" case
            propertyBindings.push({
              span: input.sourceSpan,
              paramsOrFn: getBindingFunctionParams(function () {
                return _this150.convertPropertyBinding(value);
              }, input.name)
            });
          }
        };

        for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {
          var _ret = _loop2();

          if (_ret === "continue") continue;
        }
      } catch (err) {
        _iterator24.e(err);
      } finally {
        _iterator24.f();
      }

      for (var _i10 = 0, _propertyBindings2 = propertyBindings; _i10 < _propertyBindings2.length; _i10++) {
        var propertyBinding = _propertyBindings2[_i10];
        this.updateInstructionWithAdvance(templateIndex, propertyBinding.span, Identifiers.property, propertyBinding.paramsOrFn);
      }
    } // Bindings must only be resolved after all local refs have been visited, so all
    // instructions are queued in callbacks that execute once the initial pass has completed.
    // Otherwise, we wouldn't be able to support local refs that are defined after their
    // bindings. e.g. {{ foo }} <div #foo></div>

  }, {
    key: "instructionFn",
    value: function instructionFn(fns, span, reference, paramsOrFn) {
      var prepend = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
      fns[prepend ? 'unshift' : 'push']({
        span: span,
        reference: reference,
        paramsOrFn: paramsOrFn
      });
    }
  }, {
    key: "processStylingUpdateInstruction",
    value: function processStylingUpdateInstruction(elementIndex, instruction) {
      var _this151 = this;

      var allocateBindingSlots = 0;

      if (instruction) {
        var _iterator25 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper_js__WEBPACK_IMPORTED_MODULE_9__["default"])(instruction.calls),
            _step25;

        try {
          var _loop3 = function _loop3() {
            var call = _step25.value;
            allocateBindingSlots += call.allocateBindingSlots;

            _this151.updateInstructionWithAdvance(elementIndex, call.sourceSpan, instruction.reference, function () {
              return call.params(function (value) {
                return call.supportsInterpolation && value instanceof Interpolation ? _this151.getUpdateInstructionArguments(value) : _this151.convertPropertyBinding(value);
              });
            });
          };

          for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {
            _loop3();
          }
        } catch (err) {
          _iterator25.e(err);
        } finally {
          _iterator25.f();
        }
      }

      return allocateBindingSlots;
    }
  }, {
    key: "creationInstruction",
    value: function creationInstruction(span, reference, paramsOrFn, prepend) {
      this.instructionFn(this._creationCodeFns, span, reference, paramsOrFn || [], prepend);
    }
  }, {
    key: "updateInstructionWithAdvance",
    value: function updateInstructionWithAdvance(nodeIndex, span, reference, paramsOrFn) {
      this.addAdvanceInstructionIfNecessary(nodeIndex, span);
      this.updateInstruction(span, reference, paramsOrFn);
    }
  }, {
    key: "updateInstruction",
    value: function updateInstruction(span, reference, paramsOrFn) {
      this.instructionFn(this._updateCodeFns, span, reference, paramsOrFn || []);
    }
  }, {
    key: "addAdvanceInstructionIfNecessary",
    value: function addAdvanceInstructionIfNecessary(nodeIndex, span) {
      if (nodeIndex !== this._currentIndex) {
        var delta = nodeIndex - this._currentIndex;

        if (delta < 1) {
          throw new Error('advance instruction can only go forwards');
        }

        this.instructionFn(this._updateCodeFns, span, Identifiers.advance, [literal(delta)]);
        this._currentIndex = nodeIndex;
      }
    }
  }, {
    key: "allocatePureFunctionSlots",
    value: function allocatePureFunctionSlots(numSlots) {
      var originalSlots = this._pureFunctionSlots;
      this._pureFunctionSlots += numSlots;
      return originalSlots;
    }
  }, {
    key: "allocateBindingSlots",
    value: function allocateBindingSlots(value) {
      this._bindingSlots += value instanceof Interpolation ? value.expressions.length : 1;
    }
    /**
     * Gets an expression that refers to the implicit receiver. The implicit
     * receiver is always the root level context.
     */

  }, {
    key: "getImplicitReceiverExpr",
    value: function getImplicitReceiverExpr() {
      if (this._implicitReceiverExpr) {
        return this._implicitReceiverExpr;
      }

      return this._implicitReceiverExpr = this.level === 0 ? variable(CONTEXT_NAME) : this._bindingScope.getOrCreateSharedContextVar(0);
    }
  }, {
    key: "convertPropertyBinding",
    value: function convertPropertyBinding(value) {
      var _this$_tempVariables;

      var convertedPropertyBinding = _convertPropertyBinding(this, this.getImplicitReceiverExpr(), value, this.bindingContext());

      var valExpr = convertedPropertyBinding.currValExpr;

      (_this$_tempVariables = this._tempVariables).push.apply(_this$_tempVariables, (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(convertedPropertyBinding.stmts));

      return valExpr;
    }
    /**
     * Gets a list of argument expressions to pass to an update instruction expression. Also updates
     * the temp variables state with temp variables that were identified as needing to be created
     * while visiting the arguments.
     * @param value The original expression we will be resolving an arguments list from.
     */

  }, {
    key: "getUpdateInstructionArguments",
    value: function getUpdateInstructionArguments(value) {
      var _this$_tempVariables2;

      var _convertUpdateArgumen = convertUpdateArguments(this, this.getImplicitReceiverExpr(), value, this.bindingContext()),
          args = _convertUpdateArgumen.args,
          stmts = _convertUpdateArgumen.stmts;

      (_this$_tempVariables2 = this._tempVariables).push.apply(_this$_tempVariables2, (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(stmts));

      return args;
    }
    /**
     * Prepares all attribute expression values for the `TAttributes` array.
     *
     * The purpose of this function is to properly construct an attributes array that
     * is passed into the `elementStart` (or just `element`) functions. Because there
     * are many different types of attributes, the array needs to be constructed in a
     * special way so that `elementStart` can properly evaluate them.
     *
     * The format looks like this:
     *
     * ```
     * attrs = [prop, value, prop2, value2,
     *   PROJECT_AS, selector,
     *   CLASSES, class1, class2,
     *   STYLES, style1, value1, style2, value2,
     *   BINDINGS, name1, name2, name3,
     *   TEMPLATE, name4, name5, name6,
     *   I18N, name7, name8, ...]
     * ```
     *
     * Note that this function will fully ignore all synthetic (@foo) attribute values
     * because those values are intended to always be generated as property instructions.
     */

  }, {
    key: "getAttributeExpressions",
    value: function getAttributeExpressions(elementName, renderAttributes, inputs, outputs, styles) {
      var templateAttrs = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [];
      var boundI18nAttrs = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : [];
      var alreadySeen = new Set();
      var attrExprs = [];
      var ngProjectAsAttr;

      var _iterator26 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper_js__WEBPACK_IMPORTED_MODULE_9__["default"])(renderAttributes),
          _step26;

      try {
        for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {
          var attr = _step26.value;

          if (attr.name === NG_PROJECT_AS_ATTR_NAME) {
            ngProjectAsAttr = attr;
          } // Note that static i18n attributes aren't in the i18n array,
          // because they're treated in the same way as regular attributes.


          if (attr.i18n) {
            // When i18n attributes are present on elements with structural directives
            // (e.g. `<div *ngIf title="Hello" i18n-title>`), we want to avoid generating
            // duplicate i18n translation blocks for `ɵɵtemplate` and `ɵɵelement` instruction
            // attributes. So we do a cache lookup to see if suitable i18n translation block
            // already exists.
            var i18nVarRefsCache = this._constants.i18nVarRefsCache;
            var i18nVarRef = void 0;

            if (i18nVarRefsCache.has(attr.i18n)) {
              i18nVarRef = i18nVarRefsCache.get(attr.i18n);
            } else {
              i18nVarRef = this.i18nTranslate(attr.i18n);
              i18nVarRefsCache.set(attr.i18n, i18nVarRef);
            }

            attrExprs.push(literal(attr.name), i18nVarRef);
          } else {
            attrExprs.push.apply(attrExprs, (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(getAttributeNameLiterals(attr.name)).concat([trustedConstAttribute(elementName, attr)]));
          }
        } // Keep ngProjectAs next to the other name, value pairs so we can verify that we match
        // ngProjectAs marker in the attribute name slot.

      } catch (err) {
        _iterator26.e(err);
      } finally {
        _iterator26.f();
      }

      if (ngProjectAsAttr) {
        attrExprs.push.apply(attrExprs, (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(getNgProjectAsLiteral(ngProjectAsAttr)));
      }

      function addAttrExpr(key, value) {
        if (typeof key === 'string') {
          if (!alreadySeen.has(key)) {
            attrExprs.push.apply(attrExprs, (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(getAttributeNameLiterals(key)));
            value !== undefined && attrExprs.push(value);
            alreadySeen.add(key);
          }
        } else {
          attrExprs.push(literal(key));
        }
      } // it's important that this occurs before BINDINGS and TEMPLATE because once `elementStart`
      // comes across the BINDINGS or TEMPLATE markers then it will continue reading each value as
      // as single property value cell by cell.


      if (styles) {
        styles.populateInitialStylingAttrs(attrExprs);
      }

      if (inputs.length || outputs.length) {
        var attrsLengthBeforeInputs = attrExprs.length;

        for (var i = 0; i < inputs.length; i++) {
          var input = inputs[i]; // We don't want the animation and attribute bindings in the
          // attributes array since they aren't used for directive matching.

          if (input.type !== 4
          /* BindingType.Animation */
          && input.type !== 1
          /* BindingType.Attribute */
          ) {
            addAttrExpr(input.name);
          }
        }

        for (var _i11 = 0; _i11 < outputs.length; _i11++) {
          var output = outputs[_i11];

          if (output.type !== 1
          /* ParsedEventType.Animation */
          ) {
            addAttrExpr(output.name);
          }
        } // this is a cheap way of adding the marker only after all the input/output
        // values have been filtered (by not including the animation ones) and added
        // to the expressions. The marker is important because it tells the runtime
        // code that this is where attributes without values start...


        if (attrExprs.length !== attrsLengthBeforeInputs) {
          attrExprs.splice(attrsLengthBeforeInputs, 0, literal(3
          /* core.AttributeMarker.Bindings */
          ));
        }
      }

      if (templateAttrs.length) {
        attrExprs.push(literal(4
        /* core.AttributeMarker.Template */
        ));
        templateAttrs.forEach(function (attr) {
          return addAttrExpr(attr.name);
        });
      }

      if (boundI18nAttrs.length) {
        attrExprs.push(literal(6
        /* core.AttributeMarker.I18n */
        ));
        boundI18nAttrs.forEach(function (attr) {
          return addAttrExpr(attr.name);
        });
      }

      return attrExprs;
    }
  }, {
    key: "addToConsts",
    value: function addToConsts(expression) {
      if (isNull(expression)) {
        return TYPED_NULL_EXPR;
      }

      var consts = this._constants.constExpressions; // Try to reuse a literal that's already in the array, if possible.

      for (var i = 0; i < consts.length; i++) {
        if (consts[i].isEquivalent(expression)) {
          return literal(i);
        }
      }

      return literal(consts.push(expression) - 1);
    }
  }, {
    key: "addAttrsToConsts",
    value: function addAttrsToConsts(attrs) {
      return attrs.length > 0 ? this.addToConsts(literalArr(attrs)) : TYPED_NULL_EXPR;
    }
  }, {
    key: "prepareRefsArray",
    value: function prepareRefsArray(references) {
      var _this152 = this;

      if (!references || references.length === 0) {
        return TYPED_NULL_EXPR;
      }

      var refsParam = flatten(references.map(function (reference) {
        var slot = _this152.allocateDataSlot(); // Generate the update temporary.


        var variableName = _this152._bindingScope.freshReferenceName();

        var retrievalLevel = _this152.level;
        var lhs = variable(variableName);

        _this152._bindingScope.set(retrievalLevel, reference.name, lhs, 0
        /* DeclarationPriority.DEFAULT */
        , function (scope, relativeLevel) {
          // e.g. nextContext(2);
          var nextContextStmt = relativeLevel > 0 ? [generateNextContextExpr(relativeLevel).toStmt()] : []; // e.g. const $foo$ = reference(1);

          var refExpr = lhs.set(importExpr(Identifiers.reference).callFn([literal(slot)]));
          return nextContextStmt.concat(refExpr.toConstDecl());
        }, true);

        return [reference.name, reference.value];
      }));
      return asLiteral(refsParam);
    }
  }, {
    key: "prepareListenerParameter",
    value: function prepareListenerParameter(tagName, outputAst, index) {
      var _this153 = this;

      return function () {
        var eventName = outputAst.name;
        var bindingFnName = outputAst.type === 1
        /* ParsedEventType.Animation */
        ? // synthetic @listener.foo values are treated the exact same as are standard listeners
        prepareSyntheticListenerFunctionName(eventName, outputAst.phase) : sanitizeIdentifier(eventName);
        var handlerName = "".concat(_this153.templateName, "_").concat(tagName, "_").concat(bindingFnName, "_").concat(index, "_listener");

        var scope = _this153._bindingScope.nestedScope(_this153._bindingScope.bindingLevel, EVENT_BINDING_SCOPE_GLOBALS);

        return prepareEventListenerParameters(outputAst, handlerName, scope);
      };
    }
  }]);

  return TemplateDefinitionBuilder;
}();

var ValueConverter = /*#__PURE__*/function (_AstMemoryEfficientTr) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(ValueConverter, _AstMemoryEfficientTr);

  var _super79 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(ValueConverter);

  function ValueConverter(constantPool, allocateSlot, allocatePureFunctionSlots, definePipe) {
    var _this154;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, ValueConverter);

    _this154 = _super79.call(this);
    _this154.constantPool = constantPool;
    _this154.allocateSlot = allocateSlot;
    _this154.allocatePureFunctionSlots = allocatePureFunctionSlots;
    _this154.definePipe = definePipe;
    _this154._pipeBindExprs = [];
    return _this154;
  } // AstMemoryEfficientTransformer


  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(ValueConverter, [{
    key: "visitPipe",
    value: function visitPipe(pipe, context) {
      // Allocate a slot to create the pipe
      var slot = this.allocateSlot();
      var slotPseudoLocal = "PIPE:".concat(slot); // Allocate one slot for the result plus one slot per pipe argument

      var pureFunctionSlot = this.allocatePureFunctionSlots(2 + pipe.args.length);
      var target = new PropertyRead(pipe.span, pipe.sourceSpan, pipe.nameSpan, new ImplicitReceiver(pipe.span, pipe.sourceSpan), slotPseudoLocal);

      var _pipeBindingCallInfo = pipeBindingCallInfo(pipe.args),
          identifier = _pipeBindingCallInfo.identifier,
          isVarLength = _pipeBindingCallInfo.isVarLength;

      this.definePipe(pipe.name, slotPseudoLocal, slot, importExpr(identifier));
      var args = [pipe.exp].concat((0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(pipe.args));
      var convertedArgs = isVarLength ? this.visitAll([new LiteralArray(pipe.span, pipe.sourceSpan, args)]) : this.visitAll(args);
      var pipeBindExpr = new Call(pipe.span, pipe.sourceSpan, target, [new LiteralPrimitive(pipe.span, pipe.sourceSpan, slot), new LiteralPrimitive(pipe.span, pipe.sourceSpan, pureFunctionSlot)].concat((0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(convertedArgs)), null);

      this._pipeBindExprs.push(pipeBindExpr);

      return pipeBindExpr;
    }
  }, {
    key: "updatePipeSlotOffsets",
    value: function updatePipeSlotOffsets(bindingSlots) {
      this._pipeBindExprs.forEach(function (pipe) {
        // update the slot offset arg (index 1) to account for binding slots
        var slotOffset = pipe.args[1];
        slotOffset.value += bindingSlots;
      });
    }
  }, {
    key: "visitLiteralArray",
    value: function visitLiteralArray(array, context) {
      var _this155 = this;

      return new BuiltinFunctionCall(array.span, array.sourceSpan, this.visitAll(array.expressions), function (values) {
        // If the literal has calculated (non-literal) elements transform it into
        // calls to literal factories that compose the literal and will cache intermediate
        // values.
        var literal = literalArr(values);
        return getLiteralFactory(_this155.constantPool, literal, _this155.allocatePureFunctionSlots);
      });
    }
  }, {
    key: "visitLiteralMap",
    value: function visitLiteralMap(map, context) {
      var _this156 = this;

      return new BuiltinFunctionCall(map.span, map.sourceSpan, this.visitAll(map.values), function (values) {
        // If the literal has calculated (non-literal) elements  transform it into
        // calls to literal factories that compose the literal and will cache intermediate
        // values.
        var literal = literalMap(values.map(function (value, index) {
          return {
            key: map.keys[index].key,
            value: value,
            quoted: map.keys[index].quoted
          };
        }));
        return getLiteralFactory(_this156.constantPool, literal, _this156.allocatePureFunctionSlots);
      });
    }
  }]);

  return ValueConverter;
}(AstMemoryEfficientTransformer); // Pipes always have at least one parameter, the value they operate on


var pipeBindingIdentifiers = [Identifiers.pipeBind1, Identifiers.pipeBind2, Identifiers.pipeBind3, Identifiers.pipeBind4];

function pipeBindingCallInfo(args) {
  var identifier = pipeBindingIdentifiers[args.length];
  return {
    identifier: identifier || Identifiers.pipeBindV,
    isVarLength: !identifier
  };
}

var pureFunctionIdentifiers = [Identifiers.pureFunction0, Identifiers.pureFunction1, Identifiers.pureFunction2, Identifiers.pureFunction3, Identifiers.pureFunction4, Identifiers.pureFunction5, Identifiers.pureFunction6, Identifiers.pureFunction7, Identifiers.pureFunction8];

function pureFunctionCallInfo(args) {
  var identifier = pureFunctionIdentifiers[args.length];
  return {
    identifier: identifier || Identifiers.pureFunctionV,
    isVarLength: !identifier
  };
} // e.g. x(2);


function generateNextContextExpr(relativeLevelDiff) {
  return importExpr(Identifiers.nextContext).callFn(relativeLevelDiff > 1 ? [literal(relativeLevelDiff)] : []);
}

function getLiteralFactory(constantPool, literal$1, allocateSlots) {
  var _constantPool$getLite = constantPool.getLiteralFactory(literal$1),
      literalFactory = _constantPool$getLite.literalFactory,
      literalFactoryArguments = _constantPool$getLite.literalFactoryArguments; // Allocate 1 slot for the result plus 1 per argument


  var startSlot = allocateSlots(1 + literalFactoryArguments.length);

  var _pureFunctionCallInfo = pureFunctionCallInfo(literalFactoryArguments),
      identifier = _pureFunctionCallInfo.identifier,
      isVarLength = _pureFunctionCallInfo.isVarLength; // Literal factories are pure functions that only need to be re-invoked when the parameters
  // change.


  var args = [literal(startSlot), literalFactory];

  if (isVarLength) {
    args.push(literalArr(literalFactoryArguments));
  } else {
    args.push.apply(args, (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(literalFactoryArguments));
  }

  return importExpr(identifier).callFn(args);
}
/**
 * Gets an array of literals that can be added to an expression
 * to represent the name and namespace of an attribute. E.g.
 * `:xlink:href` turns into `[AttributeMarker.NamespaceURI, 'xlink', 'href']`.
 *
 * @param name Name of the attribute, including the namespace.
 */


function getAttributeNameLiterals(name) {
  var _splitNsName5 = splitNsName(name),
      _splitNsName6 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_slicedToArray_js__WEBPACK_IMPORTED_MODULE_3__["default"])(_splitNsName5, 2),
      attributeNamespace = _splitNsName6[0],
      attributeName = _splitNsName6[1];

  var nameLiteral = literal(attributeName);

  if (attributeNamespace) {
    return [literal(0
    /* core.AttributeMarker.NamespaceURI */
    ), literal(attributeNamespace), nameLiteral];
  }

  return [nameLiteral];
}
/** The prefix used to get a shared context in BindingScope's map. */


var SHARED_CONTEXT_KEY = '$$shared_ctx$$';

var BindingScope = /*#__PURE__*/function () {
  function BindingScope() {
    var bindingLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var globals = arguments.length > 2 ? arguments[2] : undefined;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, BindingScope);

    this.bindingLevel = bindingLevel;
    this.parent = parent;
    this.globals = globals;
    /** Keeps a map from local variables to their BindingData. */

    this.map = new Map();
    this.referenceNameIndex = 0;
    this.restoreViewVariable = null;
    this.usesRestoredViewContext = false;

    if (globals !== undefined) {
      var _iterator27 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper_js__WEBPACK_IMPORTED_MODULE_9__["default"])(globals),
          _step27;

      try {
        for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {
          var name = _step27.value;
          this.set(0, name, variable(name));
        }
      } catch (err) {
        _iterator27.e(err);
      } finally {
        _iterator27.f();
      }
    }
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(BindingScope, [{
    key: "get",
    value: function get(name) {
      var current = this;

      while (current) {
        var value = current.map.get(name);

        if (value != null) {
          if (current !== this) {
            // make a local copy and reset the `declare` state
            value = {
              retrievalLevel: value.retrievalLevel,
              lhs: value.lhs,
              declareLocalCallback: value.declareLocalCallback,
              declare: false,
              priority: value.priority
            }; // Cache the value locally.

            this.map.set(name, value); // Possibly generate a shared context var

            this.maybeGenerateSharedContextVar(value);
            this.maybeRestoreView();
          }

          if (value.declareLocalCallback && !value.declare) {
            value.declare = true;
          }

          return value.lhs;
        }

        current = current.parent;
      } // If we get to this point, we are looking for a property on the top level component
      // - If level === 0, we are on the top and don't need to re-declare `ctx`.
      // - If level > 0, we are in an embedded view. We need to retrieve the name of the
      // local var we used to store the component context, e.g. const $comp$ = x();


      return this.bindingLevel === 0 ? null : this.getComponentProperty(name);
    }
    /**
     * Create a local variable for later reference.
     *
     * @param retrievalLevel The level from which this value can be retrieved
     * @param name Name of the variable.
     * @param lhs AST representing the left hand side of the `let lhs = rhs;`.
     * @param priority The sorting priority of this var
     * @param declareLocalCallback The callback to invoke when declaring this local var
     * @param localRef Whether or not this is a local ref
     */

  }, {
    key: "set",
    value: function set(retrievalLevel, name, lhs) {
      var priority = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var declareLocalCallback = arguments.length > 4 ? arguments[4] : undefined;
      var localRef = arguments.length > 5 ? arguments[5] : undefined;

      if (this.map.has(name)) {
        if (localRef) {
          // Do not throw an error if it's a local ref and do not update existing value,
          // so the first defined ref is always returned.
          return this;
        }

        error("The name ".concat(name, " is already defined in scope to be ").concat(this.map.get(name)));
      }

      this.map.set(name, {
        retrievalLevel: retrievalLevel,
        lhs: lhs,
        declare: false,
        declareLocalCallback: declareLocalCallback,
        priority: priority
      });
      return this;
    } // Implemented as part of LocalResolver.

  }, {
    key: "getLocal",
    value: function getLocal(name) {
      return this.get(name);
    } // Implemented as part of LocalResolver.

  }, {
    key: "notifyImplicitReceiverUse",
    value: function notifyImplicitReceiverUse() {
      if (this.bindingLevel !== 0) {
        // Since the implicit receiver is accessed in an embedded view, we need to
        // ensure that we declare a shared context variable for the current template
        // in the update variables.
        this.map.get(SHARED_CONTEXT_KEY + 0).declare = true;
      }
    }
  }, {
    key: "nestedScope",
    value: function nestedScope(level, globals) {
      var newScope = new BindingScope(level, this, globals);
      if (level > 0) newScope.generateSharedContextVar(0);
      return newScope;
    }
    /**
     * Gets or creates a shared context variable and returns its expression. Note that
     * this does not mean that the shared variable will be declared. Variables in the
     * binding scope will be only declared if they are used.
     */

  }, {
    key: "getOrCreateSharedContextVar",
    value: function getOrCreateSharedContextVar(retrievalLevel) {
      var bindingKey = SHARED_CONTEXT_KEY + retrievalLevel;

      if (!this.map.has(bindingKey)) {
        this.generateSharedContextVar(retrievalLevel);
      } // Shared context variables are always generated as "ReadVarExpr".


      return this.map.get(bindingKey).lhs;
    }
  }, {
    key: "getSharedContextName",
    value: function getSharedContextName(retrievalLevel) {
      var sharedCtxObj = this.map.get(SHARED_CONTEXT_KEY + retrievalLevel); // Shared context variables are always generated as "ReadVarExpr".

      return sharedCtxObj && sharedCtxObj.declare ? sharedCtxObj.lhs : null;
    }
  }, {
    key: "maybeGenerateSharedContextVar",
    value: function maybeGenerateSharedContextVar(value) {
      if (value.priority === 1
      /* DeclarationPriority.CONTEXT */
      && value.retrievalLevel < this.bindingLevel) {
        var sharedCtxObj = this.map.get(SHARED_CONTEXT_KEY + value.retrievalLevel);

        if (sharedCtxObj) {
          sharedCtxObj.declare = true;
        } else {
          this.generateSharedContextVar(value.retrievalLevel);
        }
      }
    }
  }, {
    key: "generateSharedContextVar",
    value: function generateSharedContextVar(retrievalLevel) {
      var lhs = variable(CONTEXT_NAME + this.freshReferenceName());
      this.map.set(SHARED_CONTEXT_KEY + retrievalLevel, {
        retrievalLevel: retrievalLevel,
        lhs: lhs,
        declareLocalCallback: function declareLocalCallback(scope, relativeLevel) {
          // const ctx_r0 = nextContext(2);
          return [lhs.set(generateNextContextExpr(relativeLevel)).toConstDecl()];
        },
        declare: false,
        priority: 2
        /* DeclarationPriority.SHARED_CONTEXT */

      });
    }
  }, {
    key: "getComponentProperty",
    value: function getComponentProperty(name) {
      var componentValue = this.map.get(SHARED_CONTEXT_KEY + 0);
      componentValue.declare = true;
      this.maybeRestoreView();
      return componentValue.lhs.prop(name);
    }
  }, {
    key: "maybeRestoreView",
    value: function maybeRestoreView() {
      // View restoration is required for listener instructions inside embedded views, because
      // they only run in creation mode and they can have references to the context object.
      // If the context object changes in update mode, the reference will be incorrect, because
      // it was established during creation.
      if (this.isListenerScope()) {
        if (!this.parent.restoreViewVariable) {
          // parent saves variable to generate a shared `const $s$ = getCurrentView();` instruction
          this.parent.restoreViewVariable = variable(this.parent.freshReferenceName());
        }

        this.restoreViewVariable = this.parent.restoreViewVariable;
      }
    }
  }, {
    key: "restoreViewStatement",
    value: function restoreViewStatement() {
      if (this.restoreViewVariable) {
        var restoreCall = invokeInstruction(null, Identifiers.restoreView, [this.restoreViewVariable]); // Either `const restoredCtx = restoreView($state$);` or `restoreView($state$);`
        // depending on whether it is being used.

        return this.usesRestoredViewContext ? variable(RESTORED_VIEW_CONTEXT_NAME).set(restoreCall).toConstDecl() : restoreCall.toStmt();
      }

      return null;
    }
  }, {
    key: "viewSnapshotStatements",
    value: function viewSnapshotStatements() {
      // const $state$ = getCurrentView();
      return this.restoreViewVariable ? [this.restoreViewVariable.set(invokeInstruction(null, Identifiers.getCurrentView, [])).toConstDecl()] : [];
    }
  }, {
    key: "isListenerScope",
    value: function isListenerScope() {
      return this.parent && this.parent.bindingLevel === this.bindingLevel;
    }
  }, {
    key: "variableDeclarations",
    value: function variableDeclarations() {
      var _this157 = this;

      var currentContextLevel = 0;
      return Array.from(this.map.values()).filter(function (value) {
        return value.declare;
      }).sort(function (a, b) {
        return b.retrievalLevel - a.retrievalLevel || b.priority - a.priority;
      }).reduce(function (stmts, value) {
        var levelDiff = _this157.bindingLevel - value.retrievalLevel;
        var currStmts = value.declareLocalCallback(_this157, levelDiff - currentContextLevel);
        currentContextLevel = levelDiff;
        return stmts.concat(currStmts);
      }, []);
    }
  }, {
    key: "freshReferenceName",
    value: function freshReferenceName() {
      var current = this; // Find the top scope as it maintains the global reference count

      while (current.parent) {
        current = current.parent;
      }

      var ref = "".concat(REFERENCE_PREFIX).concat(current.referenceNameIndex++);
      return ref;
    }
  }, {
    key: "hasRestoreViewVariable",
    value: function hasRestoreViewVariable() {
      return !!this.restoreViewVariable;
    }
  }, {
    key: "notifyRestoredViewContextUse",
    value: function notifyRestoredViewContextUse() {
      this.usesRestoredViewContext = true;
    }
  }], [{
    key: "createRootScope",
    value: function createRootScope() {
      return new BindingScope();
    }
  }]);

  return BindingScope;
}();
/**
 * Creates a `CssSelector` given a tag name and a map of attributes
 */


function createCssSelector(elementName, attributes) {
  var cssSelector = new CssSelector();
  var elementNameNoNs = splitNsName(elementName)[1];
  cssSelector.setElement(elementNameNoNs);
  Object.getOwnPropertyNames(attributes).forEach(function (name) {
    var nameNoNs = splitNsName(name)[1];
    var value = attributes[name];
    cssSelector.addAttribute(nameNoNs, value);

    if (name.toLowerCase() === 'class') {
      var classes = value.trim().split(/\s+/);
      classes.forEach(function (className) {
        return cssSelector.addClassName(className);
      });
    }
  });
  return cssSelector;
}
/**
 * Creates an array of expressions out of an `ngProjectAs` attributes
 * which can be added to the instruction parameters.
 */


function getNgProjectAsLiteral(attribute) {
  // Parse the attribute value into a CssSelectorList. Note that we only take the
  // first selector, because we don't support multiple selectors in ngProjectAs.
  var parsedR3Selector = parseSelectorToR3Selector(attribute.value)[0];
  return [literal(5
  /* core.AttributeMarker.ProjectAs */
  ), asLiteral(parsedR3Selector)];
}
/**
 * Gets the instruction to generate for an interpolated property
 * @param interpolation An Interpolation AST
 */


function getPropertyInterpolationExpression(interpolation) {
  switch (getInterpolationArgsLength(interpolation)) {
    case 1:
      return Identifiers.propertyInterpolate;

    case 3:
      return Identifiers.propertyInterpolate1;

    case 5:
      return Identifiers.propertyInterpolate2;

    case 7:
      return Identifiers.propertyInterpolate3;

    case 9:
      return Identifiers.propertyInterpolate4;

    case 11:
      return Identifiers.propertyInterpolate5;

    case 13:
      return Identifiers.propertyInterpolate6;

    case 15:
      return Identifiers.propertyInterpolate7;

    case 17:
      return Identifiers.propertyInterpolate8;

    default:
      return Identifiers.propertyInterpolateV;
  }
}
/**
 * Gets the instruction to generate for an interpolated attribute
 * @param interpolation An Interpolation AST
 */


function getAttributeInterpolationExpression(interpolation) {
  switch (getInterpolationArgsLength(interpolation)) {
    case 3:
      return Identifiers.attributeInterpolate1;

    case 5:
      return Identifiers.attributeInterpolate2;

    case 7:
      return Identifiers.attributeInterpolate3;

    case 9:
      return Identifiers.attributeInterpolate4;

    case 11:
      return Identifiers.attributeInterpolate5;

    case 13:
      return Identifiers.attributeInterpolate6;

    case 15:
      return Identifiers.attributeInterpolate7;

    case 17:
      return Identifiers.attributeInterpolate8;

    default:
      return Identifiers.attributeInterpolateV;
  }
}
/**
 * Gets the instruction to generate for interpolated text.
 * @param interpolation An Interpolation AST
 */


function getTextInterpolationExpression(interpolation) {
  switch (getInterpolationArgsLength(interpolation)) {
    case 1:
      return Identifiers.textInterpolate;

    case 3:
      return Identifiers.textInterpolate1;

    case 5:
      return Identifiers.textInterpolate2;

    case 7:
      return Identifiers.textInterpolate3;

    case 9:
      return Identifiers.textInterpolate4;

    case 11:
      return Identifiers.textInterpolate5;

    case 13:
      return Identifiers.textInterpolate6;

    case 15:
      return Identifiers.textInterpolate7;

    case 17:
      return Identifiers.textInterpolate8;

    default:
      return Identifiers.textInterpolateV;
  }
}
/**
 * Parse a template into render3 `Node`s and additional metadata, with no other dependencies.
 *
 * @param template text of the template to parse
 * @param templateUrl URL to use for source mapping of the parsed template
 * @param options options to modify how the template is parsed
 */


function parseTemplate(template, templateUrl) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var interpolationConfig = options.interpolationConfig,
      preserveWhitespaces = options.preserveWhitespaces,
      enableI18nLegacyMessageIdFormat = options.enableI18nLegacyMessageIdFormat;
  var bindingParser = makeBindingParser(interpolationConfig);
  var htmlParser = new HtmlParser();
  var parseResult = htmlParser.parse(template, templateUrl, Object.assign(Object.assign({
    leadingTriviaChars: LEADING_TRIVIA_CHARS
  }, options), {
    tokenizeExpansionForms: true
  }));

  if (!options.alwaysAttemptHtmlToR3AstConversion && parseResult.errors && parseResult.errors.length > 0) {
    var _parsedTemplate = {
      interpolationConfig: interpolationConfig,
      preserveWhitespaces: preserveWhitespaces,
      errors: parseResult.errors,
      nodes: [],
      styleUrls: [],
      styles: [],
      ngContentSelectors: []
    };

    if (options.collectCommentNodes) {
      _parsedTemplate.commentNodes = [];
    }

    return _parsedTemplate;
  }

  var rootNodes = parseResult.rootNodes; // process i18n meta information (scan attributes, generate ids)
  // before we run whitespace removal process, because existing i18n
  // extraction process (ng extract-i18n) relies on a raw content to generate
  // message ids

  var i18nMetaVisitor = new I18nMetaVisitor(interpolationConfig,
  /* keepI18nAttrs */
  !preserveWhitespaces, enableI18nLegacyMessageIdFormat);
  var i18nMetaResult = i18nMetaVisitor.visitAllWithErrors(rootNodes);

  if (!options.alwaysAttemptHtmlToR3AstConversion && i18nMetaResult.errors && i18nMetaResult.errors.length > 0) {
    var _parsedTemplate2 = {
      interpolationConfig: interpolationConfig,
      preserveWhitespaces: preserveWhitespaces,
      errors: i18nMetaResult.errors,
      nodes: [],
      styleUrls: [],
      styles: [],
      ngContentSelectors: []
    };

    if (options.collectCommentNodes) {
      _parsedTemplate2.commentNodes = [];
    }

    return _parsedTemplate2;
  }

  rootNodes = i18nMetaResult.rootNodes;

  if (!preserveWhitespaces) {
    rootNodes = visitAll(new WhitespaceVisitor(), rootNodes); // run i18n meta visitor again in case whitespaces are removed (because that might affect
    // generated i18n message content) and first pass indicated that i18n content is present in a
    // template. During this pass i18n IDs generated at the first pass will be preserved, so we can
    // mimic existing extraction process (ng extract-i18n)

    if (i18nMetaVisitor.hasI18nMeta) {
      rootNodes = visitAll(new I18nMetaVisitor(interpolationConfig,
      /* keepI18nAttrs */
      false), rootNodes);
    }
  }

  var _htmlAstToRender3Ast = htmlAstToRender3Ast(rootNodes, bindingParser, {
    collectCommentNodes: !!options.collectCommentNodes
  }),
      nodes = _htmlAstToRender3Ast.nodes,
      errors = _htmlAstToRender3Ast.errors,
      styleUrls = _htmlAstToRender3Ast.styleUrls,
      styles = _htmlAstToRender3Ast.styles,
      ngContentSelectors = _htmlAstToRender3Ast.ngContentSelectors,
      commentNodes = _htmlAstToRender3Ast.commentNodes;

  errors.push.apply(errors, (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(parseResult.errors).concat((0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(i18nMetaResult.errors)));
  var parsedTemplate = {
    interpolationConfig: interpolationConfig,
    preserveWhitespaces: preserveWhitespaces,
    errors: errors.length > 0 ? errors : null,
    nodes: nodes,
    styleUrls: styleUrls,
    styles: styles,
    ngContentSelectors: ngContentSelectors
  };

  if (options.collectCommentNodes) {
    parsedTemplate.commentNodes = commentNodes;
  }

  return parsedTemplate;
}

var elementRegistry = new DomElementSchemaRegistry();
/**
 * Construct a `BindingParser` with a default configuration.
 */

function makeBindingParser() {
  var interpolationConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_INTERPOLATION_CONFIG;
  return new BindingParser(new Parser$1(new Lexer()), interpolationConfig, elementRegistry, []);
}

function resolveSanitizationFn(context, isAttribute) {
  switch (context) {
    case SecurityContext.HTML:
      return importExpr(Identifiers.sanitizeHtml);

    case SecurityContext.SCRIPT:
      return importExpr(Identifiers.sanitizeScript);

    case SecurityContext.STYLE:
      // the compiler does not fill in an instruction for [style.prop?] binding
      // values because the style algorithm knows internally what props are subject
      // to sanitization (only [attr.style] values are explicitly sanitized)
      return isAttribute ? importExpr(Identifiers.sanitizeStyle) : null;

    case SecurityContext.URL:
      return importExpr(Identifiers.sanitizeUrl);

    case SecurityContext.RESOURCE_URL:
      return importExpr(Identifiers.sanitizeResourceUrl);

    default:
      return null;
  }
}

function trustedConstAttribute(tagName, attr) {
  var value = asLiteral(attr.value);

  if (isTrustedTypesSink(tagName, attr.name)) {
    switch (elementRegistry.securityContext(tagName, attr.name,
    /* isAttribute */
    true)) {
      case SecurityContext.HTML:
        return taggedTemplate(importExpr(Identifiers.trustConstantHtml), new TemplateLiteral([new TemplateLiteralElement(attr.value)], []), undefined, attr.valueSpan);
      // NB: no SecurityContext.SCRIPT here, as the corresponding tags are stripped by the compiler.

      case SecurityContext.RESOURCE_URL:
        return taggedTemplate(importExpr(Identifiers.trustConstantResourceUrl), new TemplateLiteral([new TemplateLiteralElement(attr.value)], []), undefined, attr.valueSpan);

      default:
        return value;
    }
  } else {
    return value;
  }
}

function isSingleElementTemplate(children) {
  return children.length === 1 && children[0] instanceof Element$1;
}

function isTextNode(node) {
  return node instanceof Text$3 || node instanceof BoundText || node instanceof Icu$1;
}

function hasTextChildrenOnly(children) {
  return children.every(isTextNode);
}

function getBindingFunctionParams(deferredParams, name, eagerParams) {
  return function () {
    var value = deferredParams();
    var fnParams = Array.isArray(value) ? value : [value];

    if (eagerParams) {
      fnParams.push.apply(fnParams, (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(eagerParams));
    }

    if (name) {
      // We want the property name to always be the first function parameter.
      fnParams.unshift(literal(name));
    }

    return fnParams;
  };
}
/** Name of the global variable that is used to determine if we use Closure translations or not */


var NG_I18N_CLOSURE_MODE = 'ngI18nClosureMode';
/**
 * Generate statements that define a given translation message.
 *
 * ```
 * var I18N_1;
 * if (typeof ngI18nClosureMode !== undefined && ngI18nClosureMode) {
 *     var MSG_EXTERNAL_XXX = goog.getMsg(
 *          "Some message with {$interpolation}!",
 *          { "interpolation": "\uFFFD0\uFFFD" }
 *     );
 *     I18N_1 = MSG_EXTERNAL_XXX;
 * }
 * else {
 *     I18N_1 = $localize`Some message with ${'\uFFFD0\uFFFD'}!`;
 * }
 * ```
 *
 * @param message The original i18n AST message node
 * @param variable The variable that will be assigned the translation, e.g. `I18N_1`.
 * @param closureVar The variable for Closure `goog.getMsg` calls, e.g. `MSG_EXTERNAL_XXX`.
 * @param params Object mapping placeholder names to their values (e.g.
 * `{ "interpolation": "\uFFFD0\uFFFD" }`).
 * @param transformFn Optional transformation function that will be applied to the translation (e.g.
 * post-processing).
 * @returns An array of statements that defined a given translation.
 */

function getTranslationDeclStmts(message, variable, closureVar) {
  var params = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var transformFn = arguments.length > 4 ? arguments[4] : undefined;
  var statements = [declareI18nVariable(variable), ifStmt(createClosureModeGuard(), createGoogleGetMsgStatements(variable, message, closureVar, params), createLocalizeStatements(variable, message, formatI18nPlaceholderNamesInMap(params,
  /* useCamelCase */
  false)))];

  if (transformFn) {
    statements.push(new ExpressionStatement(variable.set(transformFn(variable))));
  }

  return statements;
}
/**
 * Create the expression that will be used to guard the closure mode block
 * It is equivalent to:
 *
 * ```
 * typeof ngI18nClosureMode !== undefined && ngI18nClosureMode
 * ```
 */


function createClosureModeGuard() {
  return typeofExpr(variable(NG_I18N_CLOSURE_MODE)).notIdentical(literal('undefined', STRING_TYPE)).and(variable(NG_I18N_CLOSURE_MODE));
}

function flatten(list) {
  return list.reduce(function (flat, item) {
    var flatItem = Array.isArray(item) ? flatten(item) : item;
    return flat.concat(flatItem);
  }, []);
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
// This regex matches any binding names that contain the "attr." prefix, e.g. "attr.required"
// If there is a match, the first matching group will contain the attribute name to bind.


var ATTR_REGEX = /attr\.([^\]]+)/;
var COMPONENT_VARIABLE = '%COMP%';
var HOST_ATTR = "_nghost-".concat(COMPONENT_VARIABLE);
var CONTENT_ATTR = "_ngcontent-".concat(COMPONENT_VARIABLE);

function baseDirectiveFields(meta, constantPool, bindingParser) {
  var definitionMap = new DefinitionMap();
  var selectors = parseSelectorToR3Selector(meta.selector); // e.g. `type: MyDirective`

  definitionMap.set('type', meta.internalType); // e.g. `selectors: [['', 'someDir', '']]`

  if (selectors.length > 0) {
    definitionMap.set('selectors', asLiteral(selectors));
  }

  if (meta.queries.length > 0) {
    // e.g. `contentQueries: (rf, ctx, dirIndex) => { ... }
    definitionMap.set('contentQueries', createContentQueriesFunction(meta.queries, constantPool, meta.name));
  }

  if (meta.viewQueries.length) {
    definitionMap.set('viewQuery', createViewQueriesFunction(meta.viewQueries, constantPool, meta.name));
  } // e.g. `hostBindings: (rf, ctx) => { ... }


  definitionMap.set('hostBindings', createHostBindingsFunction(meta.host, meta.typeSourceSpan, bindingParser, constantPool, meta.selector || '', meta.name, definitionMap)); // e.g 'inputs: {a: 'a'}`

  definitionMap.set('inputs', conditionallyCreateMapObjectLiteral(meta.inputs, true)); // e.g 'outputs: {a: 'a'}`

  definitionMap.set('outputs', conditionallyCreateMapObjectLiteral(meta.outputs));

  if (meta.exportAs !== null) {
    definitionMap.set('exportAs', literalArr(meta.exportAs.map(function (e) {
      return literal(e);
    })));
  }

  if (meta.isStandalone) {
    definitionMap.set('standalone', literal(true));
  }

  return definitionMap;
}
/**
 * Add features to the definition map.
 */


function addFeatures(definitionMap, meta) {
  // e.g. `features: [NgOnChangesFeature]`
  var features = [];
  var providers = meta.providers;
  var viewProviders = meta.viewProviders;

  if (providers || viewProviders) {
    var args = [providers || new LiteralArrayExpr([])];

    if (viewProviders) {
      args.push(viewProviders);
    }

    features.push(importExpr(Identifiers.ProvidersFeature).callFn(args));
  }

  if (meta.usesInheritance) {
    features.push(importExpr(Identifiers.InheritDefinitionFeature));
  }

  if (meta.fullInheritance) {
    features.push(importExpr(Identifiers.CopyDefinitionFeature));
  }

  if (meta.lifecycle.usesOnChanges) {
    features.push(importExpr(Identifiers.NgOnChangesFeature));
  } // TODO: better way of differentiating component vs directive metadata.


  if (meta.hasOwnProperty('template') && meta.isStandalone) {
    features.push(importExpr(Identifiers.StandaloneFeature));
  }

  if (features.length) {
    definitionMap.set('features', literalArr(features));
  }
}
/**
 * Compile a directive for the render3 runtime as defined by the `R3DirectiveMetadata`.
 */


function compileDirectiveFromMetadata(meta, constantPool, bindingParser) {
  var definitionMap = baseDirectiveFields(meta, constantPool, bindingParser);
  addFeatures(definitionMap, meta);
  var expression = importExpr(Identifiers.defineDirective).callFn([definitionMap.toLiteralMap()], undefined, true);
  var type = createDirectiveType(meta);
  return {
    expression: expression,
    type: type,
    statements: []
  };
}
/**
 * Compile a component for the render3 runtime as defined by the `R3ComponentMetadata`.
 */


function compileComponentFromMetadata(meta, constantPool, bindingParser) {
  var definitionMap = baseDirectiveFields(meta, constantPool, bindingParser);
  addFeatures(definitionMap, meta);
  var selector = meta.selector && CssSelector.parse(meta.selector);
  var firstSelector = selector && selector[0]; // e.g. `attr: ["class", ".my.app"]`
  // This is optional an only included if the first selector of a component specifies attributes.

  if (firstSelector) {
    var selectorAttributes = firstSelector.getAttrs();

    if (selectorAttributes.length) {
      definitionMap.set('attrs', constantPool.getConstLiteral(literalArr(selectorAttributes.map(function (value) {
        return value != null ? literal(value) : literal(undefined);
      })),
      /* forceShared */
      true));
    }
  } // e.g. `template: function MyComponent_Template(_ctx, _cm) {...}`


  var templateTypeName = meta.name;
  var templateName = templateTypeName ? "".concat(templateTypeName, "_Template") : null;
  var changeDetection = meta.changeDetection;
  var template = meta.template;
  var templateBuilder = new TemplateDefinitionBuilder(constantPool, BindingScope.createRootScope(), 0, templateTypeName, null, null, templateName, Identifiers.namespaceHTML, meta.relativeContextFilePath, meta.i18nUseExternalIds);
  var templateFunctionExpression = templateBuilder.buildTemplateFunction(template.nodes, []); // We need to provide this so that dynamically generated components know what
  // projected content blocks to pass through to the component when it is instantiated.

  var ngContentSelectors = templateBuilder.getNgContentSelectors();

  if (ngContentSelectors) {
    definitionMap.set('ngContentSelectors', ngContentSelectors);
  } // e.g. `decls: 2`


  definitionMap.set('decls', literal(templateBuilder.getConstCount())); // e.g. `vars: 2`

  definitionMap.set('vars', literal(templateBuilder.getVarCount())); // Generate `consts` section of ComponentDef:
  // - either as an array:
  //   `consts: [['one', 'two'], ['three', 'four']]`
  // - or as a factory function in case additional statements are present (to support i18n):
  //   `consts: function() { var i18n_0; if (ngI18nClosureMode) {...} else {...} return [i18n_0]; }`

  var _templateBuilder$getC = templateBuilder.getConsts(),
      constExpressions = _templateBuilder$getC.constExpressions,
      prepareStatements = _templateBuilder$getC.prepareStatements;

  if (constExpressions.length > 0) {
    var constsExpr = literalArr(constExpressions); // Prepare statements are present - turn `consts` into a function.

    if (prepareStatements.length > 0) {
      constsExpr = fn([], [].concat((0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(prepareStatements), [new ReturnStatement(constsExpr)]));
    }

    definitionMap.set('consts', constsExpr);
  }

  definitionMap.set('template', templateFunctionExpression);

  if (meta.declarations.length > 0) {
    definitionMap.set('dependencies', compileDeclarationList(literalArr(meta.declarations.map(function (decl) {
      return decl.type;
    })), meta.declarationListEmitMode));
  }

  if (meta.encapsulation === null) {
    meta.encapsulation = ViewEncapsulation.Emulated;
  } // e.g. `styles: [str1, str2]`


  if (meta.styles && meta.styles.length) {
    var styleValues = meta.encapsulation == ViewEncapsulation.Emulated ? compileStyles(meta.styles, CONTENT_ATTR, HOST_ATTR) : meta.styles;
    var styleNodes = styleValues.reduce(function (result, style) {
      if (style.trim().length > 0) {
        result.push(constantPool.getConstLiteral(literal(style)));
      }

      return result;
    }, []);

    if (styleNodes.length > 0) {
      definitionMap.set('styles', literalArr(styleNodes));
    }
  } else if (meta.encapsulation === ViewEncapsulation.Emulated) {
    // If there is no style, don't generate css selectors on elements
    meta.encapsulation = ViewEncapsulation.None;
  } // Only set view encapsulation if it's not the default value


  if (meta.encapsulation !== ViewEncapsulation.Emulated) {
    definitionMap.set('encapsulation', literal(meta.encapsulation));
  } // e.g. `animation: [trigger('123', [])]`


  if (meta.animations !== null) {
    definitionMap.set('data', literalMap([{
      key: 'animation',
      value: meta.animations,
      quoted: false
    }]));
  } // Only set the change detection flag if it's defined and it's not the default.


  if (changeDetection != null && changeDetection !== ChangeDetectionStrategy.Default) {
    definitionMap.set('changeDetection', literal(changeDetection));
  }

  var expression = importExpr(Identifiers.defineComponent).callFn([definitionMap.toLiteralMap()], undefined, true);
  var type = createComponentType(meta);
  return {
    expression: expression,
    type: type,
    statements: []
  };
}
/**
 * Creates the type specification from the component meta. This type is inserted into .d.ts files
 * to be consumed by upstream compilations.
 */


function createComponentType(meta) {
  var typeParams = createBaseDirectiveTypeParams(meta);
  typeParams.push(stringArrayAsType(meta.template.ngContentSelectors));
  typeParams.push(expressionType(literal(meta.isStandalone)));
  return expressionType(importExpr(Identifiers.ComponentDeclaration, typeParams));
}
/**
 * Compiles the array literal of declarations into an expression according to the provided emit
 * mode.
 */


function compileDeclarationList(list, mode) {
  switch (mode) {
    case 0
    /* DeclarationListEmitMode.Direct */
    :
      // directives: [MyDir],
      return list;

    case 1
    /* DeclarationListEmitMode.Closure */
    :
      // directives: function () { return [MyDir]; }
      return fn([], [new ReturnStatement(list)]);

    case 2
    /* DeclarationListEmitMode.ClosureResolved */
    :
      // directives: function () { return [MyDir].map(ng.resolveForwardRef); }
      var resolvedList = list.prop('map').callFn([importExpr(Identifiers.resolveForwardRef)]);
      return fn([], [new ReturnStatement(resolvedList)]);
  }
}

function prepareQueryParams(query, constantPool) {
  var parameters = [getQueryPredicate(query, constantPool), literal(toQueryFlags(query))];

  if (query.read) {
    parameters.push(query.read);
  }

  return parameters;
}
/**
 * Translates query flags into `TQueryFlags` type in packages/core/src/render3/interfaces/query.ts
 * @param query
 */


function toQueryFlags(query) {
  return (query.descendants ? 1
  /* QueryFlags.descendants */
  : 0
  /* QueryFlags.none */
  ) | (query.static ? 2
  /* QueryFlags.isStatic */
  : 0
  /* QueryFlags.none */
  ) | (query.emitDistinctChangesOnly ? 4
  /* QueryFlags.emitDistinctChangesOnly */
  : 0
  /* QueryFlags.none */
  );
}

function convertAttributesToExpressions(attributes) {
  var values = [];

  var _iterator28 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper_js__WEBPACK_IMPORTED_MODULE_9__["default"])(Object.getOwnPropertyNames(attributes)),
      _step28;

  try {
    for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {
      var key = _step28.value;
      var value = attributes[key];
      values.push(literal(key), value);
    }
  } catch (err) {
    _iterator28.e(err);
  } finally {
    _iterator28.f();
  }

  return values;
} // Define and update any content queries


function createContentQueriesFunction(queries, constantPool, name) {
  var createStatements = [];
  var updateStatements = [];
  var tempAllocator = temporaryAllocator(updateStatements, TEMPORARY_NAME);

  var _iterator29 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper_js__WEBPACK_IMPORTED_MODULE_9__["default"])(queries),
      _step29;

  try {
    for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {
      var query = _step29.value;
      // creation, e.g. r3.contentQuery(dirIndex, somePredicate, true, null);
      createStatements.push(importExpr(Identifiers.contentQuery).callFn([variable('dirIndex')].concat((0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(prepareQueryParams(query, constantPool)))).toStmt()); // update, e.g. (r3.queryRefresh(tmp = r3.loadQuery()) && (ctx.someDir = tmp));

      var temporary = tempAllocator();
      var getQueryList = importExpr(Identifiers.loadQuery).callFn([]);
      var refresh = importExpr(Identifiers.queryRefresh).callFn([temporary.set(getQueryList)]);
      var updateDirective = variable(CONTEXT_NAME).prop(query.propertyName).set(query.first ? temporary.prop('first') : temporary);
      updateStatements.push(refresh.and(updateDirective).toStmt());
    }
  } catch (err) {
    _iterator29.e(err);
  } finally {
    _iterator29.f();
  }

  var contentQueriesFnName = name ? "".concat(name, "_ContentQueries") : null;
  return fn([new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null), new FnParam('dirIndex', null)], [renderFlagCheckIfStmt(1
  /* core.RenderFlags.Create */
  , createStatements), renderFlagCheckIfStmt(2
  /* core.RenderFlags.Update */
  , updateStatements)], INFERRED_TYPE, null, contentQueriesFnName);
}

function stringAsType(str) {
  return expressionType(literal(str));
}

function stringMapAsType(map) {
  var mapValues = Object.keys(map).map(function (key) {
    var value = Array.isArray(map[key]) ? map[key][0] : map[key];
    return {
      key: key,
      value: literal(value),
      quoted: true
    };
  });
  return expressionType(literalMap(mapValues));
}

function stringArrayAsType(arr) {
  return arr.length > 0 ? expressionType(literalArr(arr.map(function (value) {
    return literal(value);
  }))) : NONE_TYPE;
}

function createBaseDirectiveTypeParams(meta) {
  // On the type side, remove newlines from the selector as it will need to fit into a TypeScript
  // string literal, which must be on one line.
  var selectorForType = meta.selector !== null ? meta.selector.replace(/\n/g, '') : null;
  return [typeWithParameters(meta.type.type, meta.typeArgumentCount), selectorForType !== null ? stringAsType(selectorForType) : NONE_TYPE, meta.exportAs !== null ? stringArrayAsType(meta.exportAs) : NONE_TYPE, stringMapAsType(meta.inputs), stringMapAsType(meta.outputs), stringArrayAsType(meta.queries.map(function (q) {
    return q.propertyName;
  }))];
}
/**
 * Creates the type specification from the directive meta. This type is inserted into .d.ts files
 * to be consumed by upstream compilations.
 */


function createDirectiveType(meta) {
  var typeParams = createBaseDirectiveTypeParams(meta); // Directives have no NgContentSelectors slot, but instead express a `never` type
  // so that future fields align.

  typeParams.push(NONE_TYPE);
  typeParams.push(expressionType(literal(meta.isStandalone)));
  return expressionType(importExpr(Identifiers.DirectiveDeclaration, typeParams));
} // Define and update any view queries


function createViewQueriesFunction(viewQueries, constantPool, name) {
  var createStatements = [];
  var updateStatements = [];
  var tempAllocator = temporaryAllocator(updateStatements, TEMPORARY_NAME);
  viewQueries.forEach(function (query) {
    // creation, e.g. r3.viewQuery(somePredicate, true);
    var queryDefinition = importExpr(Identifiers.viewQuery).callFn(prepareQueryParams(query, constantPool));
    createStatements.push(queryDefinition.toStmt()); // update, e.g. (r3.queryRefresh(tmp = r3.loadQuery()) && (ctx.someDir = tmp));

    var temporary = tempAllocator();
    var getQueryList = importExpr(Identifiers.loadQuery).callFn([]);
    var refresh = importExpr(Identifiers.queryRefresh).callFn([temporary.set(getQueryList)]);
    var updateDirective = variable(CONTEXT_NAME).prop(query.propertyName).set(query.first ? temporary.prop('first') : temporary);
    updateStatements.push(refresh.and(updateDirective).toStmt());
  });
  var viewQueryFnName = name ? "".concat(name, "_Query") : null;
  return fn([new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null)], [renderFlagCheckIfStmt(1
  /* core.RenderFlags.Create */
  , createStatements), renderFlagCheckIfStmt(2
  /* core.RenderFlags.Update */
  , updateStatements)], INFERRED_TYPE, null, viewQueryFnName);
} // Return a host binding function or null if one is not necessary.


function createHostBindingsFunction(hostBindingsMetadata, typeSourceSpan, bindingParser, constantPool, selector, name, definitionMap) {
  var bindingContext = variable(CONTEXT_NAME);
  var styleBuilder = new StylingBuilder(bindingContext);
  var _hostBindingsMetadata = hostBindingsMetadata.specialAttributes,
      styleAttr = _hostBindingsMetadata.styleAttr,
      classAttr = _hostBindingsMetadata.classAttr;

  if (styleAttr !== undefined) {
    styleBuilder.registerStyleAttr(styleAttr);
  }

  if (classAttr !== undefined) {
    styleBuilder.registerClassAttr(classAttr);
  }

  var createInstructions = [];
  var updateInstructions = [];
  var updateVariables = [];
  var hostBindingSourceSpan = typeSourceSpan; // Calculate host event bindings

  var eventBindings = bindingParser.createDirectiveHostEventAsts(hostBindingsMetadata.listeners, hostBindingSourceSpan);

  if (eventBindings && eventBindings.length) {
    createInstructions.push.apply(createInstructions, (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(createHostListeners(eventBindings, name)));
  } // Calculate the host property bindings


  var bindings = bindingParser.createBoundHostProperties(hostBindingsMetadata.properties, hostBindingSourceSpan);
  var allOtherBindings = []; // We need to calculate the total amount of binding slots required by
  // all the instructions together before any value conversions happen.
  // Value conversions may require additional slots for interpolation and
  // bindings with pipes. These calculates happen after this block.

  var totalHostVarsCount = 0;
  bindings && bindings.forEach(function (binding) {
    var stylingInputWasSet = styleBuilder.registerInputBasedOnName(binding.name, binding.expression, hostBindingSourceSpan);

    if (stylingInputWasSet) {
      totalHostVarsCount += MIN_STYLING_BINDING_SLOTS_REQUIRED;
    } else {
      allOtherBindings.push(binding);
      totalHostVarsCount++;
    }
  });
  var valueConverter;

  var getValueConverter = function getValueConverter() {
    if (!valueConverter) {
      var hostVarsCountFn = function hostVarsCountFn(numSlots) {
        var originalVarsCount = totalHostVarsCount;
        totalHostVarsCount += numSlots;
        return originalVarsCount;
      };

      valueConverter = new ValueConverter(constantPool, function () {
        return error('Unexpected node');
      }, // new nodes are illegal here
      hostVarsCountFn, function () {
        return error('Unexpected pipe');
      }); // pipes are illegal here
    }

    return valueConverter;
  };

  var propertyBindings = [];
  var attributeBindings = [];
  var syntheticHostBindings = [];

  for (var _i12 = 0, _allOtherBindings = allOtherBindings; _i12 < _allOtherBindings.length; _i12++) {
    var binding = _allOtherBindings[_i12];
    // resolve literal arrays and literal objects
    var value = binding.expression.visit(getValueConverter());
    var bindingExpr = bindingFn(bindingContext, value);

    var _getBindingNameAndIns = getBindingNameAndInstruction(binding),
        bindingName = _getBindingNameAndIns.bindingName,
        instruction = _getBindingNameAndIns.instruction,
        isAttribute = _getBindingNameAndIns.isAttribute;

    var securityContexts = bindingParser.calcPossibleSecurityContexts(selector, bindingName, isAttribute).filter(function (context) {
      return context !== SecurityContext.NONE;
    });
    var sanitizerFn = null;

    if (securityContexts.length) {
      if (securityContexts.length === 2 && securityContexts.indexOf(SecurityContext.URL) > -1 && securityContexts.indexOf(SecurityContext.RESOURCE_URL) > -1) {
        // Special case for some URL attributes (such as "src" and "href") that may be a part
        // of different security contexts. In this case we use special sanitization function and
        // select the actual sanitizer at runtime based on a tag name that is provided while
        // invoking sanitization function.
        sanitizerFn = importExpr(Identifiers.sanitizeUrlOrResourceUrl);
      } else {
        sanitizerFn = resolveSanitizationFn(securityContexts[0], isAttribute);
      }
    }

    var instructionParams = [literal(bindingName), bindingExpr.currValExpr];

    if (sanitizerFn) {
      instructionParams.push(sanitizerFn);
    }

    updateVariables.push.apply(updateVariables, (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(bindingExpr.stmts));

    if (instruction === Identifiers.hostProperty) {
      propertyBindings.push(instructionParams);
    } else if (instruction === Identifiers.attribute) {
      attributeBindings.push(instructionParams);
    } else if (instruction === Identifiers.syntheticHostProperty) {
      syntheticHostBindings.push(instructionParams);
    } else {
      updateInstructions.push({
        reference: instruction,
        paramsOrFn: instructionParams,
        span: null
      });
    }
  }

  for (var _i13 = 0, _propertyBindings3 = propertyBindings; _i13 < _propertyBindings3.length; _i13++) {
    var bindingParams = _propertyBindings3[_i13];
    updateInstructions.push({
      reference: Identifiers.hostProperty,
      paramsOrFn: bindingParams,
      span: null
    });
  }

  for (var _i14 = 0, _attributeBindings2 = attributeBindings; _i14 < _attributeBindings2.length; _i14++) {
    var _bindingParams = _attributeBindings2[_i14];
    updateInstructions.push({
      reference: Identifiers.attribute,
      paramsOrFn: _bindingParams,
      span: null
    });
  }

  for (var _i15 = 0, _syntheticHostBinding = syntheticHostBindings; _i15 < _syntheticHostBinding.length; _i15++) {
    var _bindingParams2 = _syntheticHostBinding[_i15];
    updateInstructions.push({
      reference: Identifiers.syntheticHostProperty,
      paramsOrFn: _bindingParams2,
      span: null
    });
  } // since we're dealing with directives/components and both have hostBinding
  // functions, we need to generate a special hostAttrs instruction that deals
  // with both the assignment of styling as well as static attributes to the host
  // element. The instruction below will instruct all initial styling (styling
  // that is inside of a host binding within a directive/component) to be attached
  // to the host element alongside any of the provided host attributes that were
  // collected earlier.


  var hostAttrs = convertAttributesToExpressions(hostBindingsMetadata.attributes);
  styleBuilder.assignHostAttrs(hostAttrs, definitionMap);

  if (styleBuilder.hasBindings) {
    // finally each binding that was registered in the statement above will need to be added to
    // the update block of a component/directive templateFn/hostBindingsFn so that the bindings
    // are evaluated and updated for the element.
    styleBuilder.buildUpdateLevelInstructions(getValueConverter()).forEach(function (instruction) {
      var _iterator30 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper_js__WEBPACK_IMPORTED_MODULE_9__["default"])(instruction.calls),
          _step30;

      try {
        for (_iterator30.s(); !(_step30 = _iterator30.n()).done;) {
          var call = _step30.value;
          // we subtract a value of `1` here because the binding slot was already allocated
          // at the top of this method when all the input bindings were counted.
          totalHostVarsCount += Math.max(call.allocateBindingSlots - MIN_STYLING_BINDING_SLOTS_REQUIRED, 0);
          updateInstructions.push({
            reference: instruction.reference,
            paramsOrFn: convertStylingCall(call, bindingContext, bindingFn),
            span: null
          });
        }
      } catch (err) {
        _iterator30.e(err);
      } finally {
        _iterator30.f();
      }
    });
  }

  if (totalHostVarsCount) {
    definitionMap.set('hostVars', literal(totalHostVarsCount));
  }

  if (createInstructions.length > 0 || updateInstructions.length > 0) {
    var hostBindingsFnName = name ? "".concat(name, "_HostBindings") : null;
    var statements = [];

    if (createInstructions.length > 0) {
      statements.push(renderFlagCheckIfStmt(1
      /* core.RenderFlags.Create */
      , getInstructionStatements(createInstructions)));
    }

    if (updateInstructions.length > 0) {
      statements.push(renderFlagCheckIfStmt(2
      /* core.RenderFlags.Update */
      , updateVariables.concat(getInstructionStatements(updateInstructions))));
    }

    return fn([new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null)], statements, INFERRED_TYPE, null, hostBindingsFnName);
  }

  return null;
}

function bindingFn(implicit, value) {
  return _convertPropertyBinding(null, implicit, value, 'b');
}

function convertStylingCall(call, bindingContext, bindingFn) {
  return call.params(function (value) {
    return bindingFn(bindingContext, value).currValExpr;
  });
}

function getBindingNameAndInstruction(binding) {
  var bindingName = binding.name;
  var instruction; // Check to see if this is an attr binding or a property binding

  var attrMatches = bindingName.match(ATTR_REGEX);

  if (attrMatches) {
    bindingName = attrMatches[1];
    instruction = Identifiers.attribute;
  } else {
    if (binding.isAnimation) {
      bindingName = prepareSyntheticPropertyName(bindingName); // host bindings that have a synthetic property (e.g. @foo) should always be rendered
      // in the context of the component and not the parent. Therefore there is a special
      // compatibility instruction available for this purpose.

      instruction = Identifiers.syntheticHostProperty;
    } else {
      instruction = Identifiers.hostProperty;
    }
  }

  return {
    bindingName: bindingName,
    instruction: instruction,
    isAttribute: !!attrMatches
  };
}

function createHostListeners(eventBindings, name) {
  var listenerParams = [];
  var syntheticListenerParams = [];
  var instructions = [];

  var _iterator31 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper_js__WEBPACK_IMPORTED_MODULE_9__["default"])(eventBindings),
      _step31;

  try {
    for (_iterator31.s(); !(_step31 = _iterator31.n()).done;) {
      var binding = _step31.value;
      var bindingName = binding.name && sanitizeIdentifier(binding.name);
      var bindingFnName = binding.type === 1
      /* ParsedEventType.Animation */
      ? prepareSyntheticListenerFunctionName(bindingName, binding.targetOrPhase) : bindingName;
      var handlerName = name && bindingName ? "".concat(name, "_").concat(bindingFnName, "_HostBindingHandler") : null;

      var _params3 = prepareEventListenerParameters(BoundEvent.fromParsedEvent(binding), handlerName);

      if (binding.type == 1
      /* ParsedEventType.Animation */
      ) {
        syntheticListenerParams.push(_params3);
      } else {
        listenerParams.push(_params3);
      }
    }
  } catch (err) {
    _iterator31.e(err);
  } finally {
    _iterator31.f();
  }

  for (var _i16 = 0, _syntheticListenerPar = syntheticListenerParams; _i16 < _syntheticListenerPar.length; _i16++) {
    var params = _syntheticListenerPar[_i16];
    instructions.push({
      reference: Identifiers.syntheticHostListener,
      paramsOrFn: params,
      span: null
    });
  }

  for (var _i17 = 0, _listenerParams = listenerParams; _i17 < _listenerParams.length; _i17++) {
    var _params2 = _listenerParams[_i17];
    instructions.push({
      reference: Identifiers.listener,
      paramsOrFn: _params2,
      span: null
    });
  }

  return instructions;
}

var HOST_REG_EXP = /^(?:\[([^\]]+)\])|(?:\(([^\)]+)\))$/;

function parseHostBindings(host) {
  var attributes = {};
  var listeners = {};
  var properties = {};
  var specialAttributes = {};

  for (var _i18 = 0, _Object$keys3 = Object.keys(host); _i18 < _Object$keys3.length; _i18++) {
    var key = _Object$keys3[_i18];
    var value = host[key];
    var matches = key.match(HOST_REG_EXP);

    if (matches === null) {
      switch (key) {
        case 'class':
          if (typeof value !== 'string') {
            // TODO(alxhub): make this a diagnostic.
            throw new Error("Class binding must be string");
          }

          specialAttributes.classAttr = value;
          break;

        case 'style':
          if (typeof value !== 'string') {
            // TODO(alxhub): make this a diagnostic.
            throw new Error("Style binding must be string");
          }

          specialAttributes.styleAttr = value;
          break;

        default:
          if (typeof value === 'string') {
            attributes[key] = literal(value);
          } else {
            attributes[key] = value;
          }

      }
    } else if (matches[1
    /* HostBindingGroup.Binding */
    ] != null) {
      if (typeof value !== 'string') {
        // TODO(alxhub): make this a diagnostic.
        throw new Error("Property binding must be string");
      } // synthetic properties (the ones that have a `@` as a prefix)
      // are still treated the same as regular properties. Therefore
      // there is no point in storing them in a separate map.


      properties[matches[1
      /* HostBindingGroup.Binding */
      ]] = value;
    } else if (matches[2
    /* HostBindingGroup.Event */
    ] != null) {
      if (typeof value !== 'string') {
        // TODO(alxhub): make this a diagnostic.
        throw new Error("Event binding must be string");
      }

      listeners[matches[2
      /* HostBindingGroup.Event */
      ]] = value;
    }
  }

  return {
    attributes: attributes,
    listeners: listeners,
    properties: properties,
    specialAttributes: specialAttributes
  };
}
/**
 * Verifies host bindings and returns the list of errors (if any). Empty array indicates that a
 * given set of host bindings has no errors.
 *
 * @param bindings set of host bindings to verify.
 * @param sourceSpan source span where host bindings were defined.
 * @returns array of errors associated with a given set of host bindings.
 */


function verifyHostBindings(bindings, sourceSpan) {
  // TODO: abstract out host bindings verification logic and use it instead of
  // creating events and properties ASTs to detect errors (FW-996)
  var bindingParser = makeBindingParser();
  bindingParser.createDirectiveHostEventAsts(bindings.listeners, sourceSpan);
  bindingParser.createBoundHostProperties(bindings.properties, sourceSpan);
  return bindingParser.errors;
}

function compileStyles(styles, selector, hostSelector) {
  var shadowCss = new ShadowCss();
  return styles.map(function (style) {
    return shadowCss.shimCssText(style, selector, hostSelector);
  });
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * An interface for retrieving documents by URL that the compiler uses to
 * load templates.
 *
 * This is an abstract class, rather than an interface, so that it can be used
 * as injection token.
 */


var ResourceLoader = /*#__PURE__*/(0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(function ResourceLoader() {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, ResourceLoader);
});
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */


var CompilerFacadeImpl = /*#__PURE__*/function () {
  function CompilerFacadeImpl() {
    var jitEvaluator = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new JitEvaluator();

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, CompilerFacadeImpl);

    this.jitEvaluator = jitEvaluator;
    this.FactoryTarget = FactoryTarget$1;
    this.ResourceLoader = ResourceLoader;
    this.elementSchemaRegistry = new DomElementSchemaRegistry();
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(CompilerFacadeImpl, [{
    key: "compilePipe",
    value: function compilePipe(angularCoreEnv, sourceMapUrl, facade) {
      var metadata = {
        name: facade.name,
        type: wrapReference(facade.type),
        internalType: new WrappedNodeExpr(facade.type),
        typeArgumentCount: 0,
        deps: null,
        pipeName: facade.pipeName,
        pure: facade.pure,
        isStandalone: facade.isStandalone
      };
      var res = compilePipeFromMetadata(metadata);
      return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);
    }
  }, {
    key: "compilePipeDeclaration",
    value: function compilePipeDeclaration(angularCoreEnv, sourceMapUrl, declaration) {
      var meta = convertDeclarePipeFacadeToMetadata(declaration);
      var res = compilePipeFromMetadata(meta);
      return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);
    }
  }, {
    key: "compileInjectable",
    value: function compileInjectable(angularCoreEnv, sourceMapUrl, facade) {
      var _a;

      var _compileInjectable2 = _compileInjectable({
        name: facade.name,
        type: wrapReference(facade.type),
        internalType: new WrappedNodeExpr(facade.type),
        typeArgumentCount: facade.typeArgumentCount,
        providedIn: computeProvidedIn(facade.providedIn),
        useClass: convertToProviderExpression(facade, 'useClass'),
        useFactory: wrapExpression(facade, 'useFactory'),
        useValue: convertToProviderExpression(facade, 'useValue'),
        useExisting: convertToProviderExpression(facade, 'useExisting'),
        deps: (_a = facade.deps) === null || _a === void 0 ? void 0 : _a.map(convertR3DependencyMetadata)
      },
      /* resolveForwardRefs */
      true),
          expression = _compileInjectable2.expression,
          statements = _compileInjectable2.statements;

      return this.jitExpression(expression, angularCoreEnv, sourceMapUrl, statements);
    }
  }, {
    key: "compileInjectableDeclaration",
    value: function compileInjectableDeclaration(angularCoreEnv, sourceMapUrl, facade) {
      var _a;

      var _compileInjectable3 = _compileInjectable({
        name: facade.type.name,
        type: wrapReference(facade.type),
        internalType: new WrappedNodeExpr(facade.type),
        typeArgumentCount: 0,
        providedIn: computeProvidedIn(facade.providedIn),
        useClass: convertToProviderExpression(facade, 'useClass'),
        useFactory: wrapExpression(facade, 'useFactory'),
        useValue: convertToProviderExpression(facade, 'useValue'),
        useExisting: convertToProviderExpression(facade, 'useExisting'),
        deps: (_a = facade.deps) === null || _a === void 0 ? void 0 : _a.map(convertR3DeclareDependencyMetadata)
      },
      /* resolveForwardRefs */
      true),
          expression = _compileInjectable3.expression,
          statements = _compileInjectable3.statements;

      return this.jitExpression(expression, angularCoreEnv, sourceMapUrl, statements);
    }
  }, {
    key: "compileInjector",
    value: function compileInjector(angularCoreEnv, sourceMapUrl, facade) {
      var meta = {
        name: facade.name,
        type: wrapReference(facade.type),
        internalType: new WrappedNodeExpr(facade.type),
        providers: facade.providers && facade.providers.length > 0 ? new WrappedNodeExpr(facade.providers) : null,
        imports: facade.imports.map(function (i) {
          return new WrappedNodeExpr(i);
        })
      };

      var res = _compileInjector(meta);

      return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);
    }
  }, {
    key: "compileInjectorDeclaration",
    value: function compileInjectorDeclaration(angularCoreEnv, sourceMapUrl, declaration) {
      var meta = convertDeclareInjectorFacadeToMetadata(declaration);

      var res = _compileInjector(meta);

      return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);
    }
  }, {
    key: "compileNgModule",
    value: function compileNgModule(angularCoreEnv, sourceMapUrl, facade) {
      var meta = {
        type: wrapReference(facade.type),
        internalType: new WrappedNodeExpr(facade.type),
        adjacentType: new WrappedNodeExpr(facade.type),
        bootstrap: facade.bootstrap.map(wrapReference),
        declarations: facade.declarations.map(wrapReference),
        imports: facade.imports.map(wrapReference),
        exports: facade.exports.map(wrapReference),
        selectorScopeMode: R3SelectorScopeMode.Inline,
        containsForwardDecls: false,
        schemas: facade.schemas ? facade.schemas.map(wrapReference) : null,
        id: facade.id ? new WrappedNodeExpr(facade.id) : null
      };

      var res = _compileNgModule(meta);

      return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);
    }
  }, {
    key: "compileNgModuleDeclaration",
    value: function compileNgModuleDeclaration(angularCoreEnv, sourceMapUrl, declaration) {
      var expression = compileNgModuleDeclarationExpression(declaration);
      return this.jitExpression(expression, angularCoreEnv, sourceMapUrl, []);
    }
  }, {
    key: "compileDirective",
    value: function compileDirective(angularCoreEnv, sourceMapUrl, facade) {
      var meta = convertDirectiveFacadeToMetadata(facade);
      return this.compileDirectiveFromMeta(angularCoreEnv, sourceMapUrl, meta);
    }
  }, {
    key: "compileDirectiveDeclaration",
    value: function compileDirectiveDeclaration(angularCoreEnv, sourceMapUrl, declaration) {
      var typeSourceSpan = this.createParseSourceSpan('Directive', declaration.type.name, sourceMapUrl);
      var meta = convertDeclareDirectiveFacadeToMetadata(declaration, typeSourceSpan);
      return this.compileDirectiveFromMeta(angularCoreEnv, sourceMapUrl, meta);
    }
  }, {
    key: "compileDirectiveFromMeta",
    value: function compileDirectiveFromMeta(angularCoreEnv, sourceMapUrl, meta) {
      var constantPool = new ConstantPool();
      var bindingParser = makeBindingParser();
      var res = compileDirectiveFromMetadata(meta, constantPool, bindingParser);
      return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, constantPool.statements);
    }
  }, {
    key: "compileComponent",
    value: function compileComponent(angularCoreEnv, sourceMapUrl, facade) {
      // Parse the template and check for errors.
      var _parseJitTemplate = parseJitTemplate(facade.template, facade.name, sourceMapUrl, facade.preserveWhitespaces, facade.interpolation),
          template = _parseJitTemplate.template,
          interpolation = _parseJitTemplate.interpolation; // Compile the component metadata, including template, into an expression.


      var meta = Object.assign(Object.assign(Object.assign({}, facade), convertDirectiveFacadeToMetadata(facade)), {
        selector: facade.selector || this.elementSchemaRegistry.getDefaultComponentElementName(),
        template: template,
        declarations: facade.declarations.map(convertDeclarationFacadeToMetadata),
        declarationListEmitMode: 0
        /* DeclarationListEmitMode.Direct */
        ,
        styles: [].concat((0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(facade.styles), (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(template.styles)),
        encapsulation: facade.encapsulation,
        interpolation: interpolation,
        changeDetection: facade.changeDetection,
        animations: facade.animations != null ? new WrappedNodeExpr(facade.animations) : null,
        viewProviders: facade.viewProviders != null ? new WrappedNodeExpr(facade.viewProviders) : null,
        relativeContextFilePath: '',
        i18nUseExternalIds: true
      });
      var jitExpressionSourceMap = "ng:///".concat(facade.name, ".js");
      return this.compileComponentFromMeta(angularCoreEnv, jitExpressionSourceMap, meta);
    }
  }, {
    key: "compileComponentDeclaration",
    value: function compileComponentDeclaration(angularCoreEnv, sourceMapUrl, declaration) {
      var typeSourceSpan = this.createParseSourceSpan('Component', declaration.type.name, sourceMapUrl);
      var meta = convertDeclareComponentFacadeToMetadata(declaration, typeSourceSpan, sourceMapUrl);
      return this.compileComponentFromMeta(angularCoreEnv, sourceMapUrl, meta);
    }
  }, {
    key: "compileComponentFromMeta",
    value: function compileComponentFromMeta(angularCoreEnv, sourceMapUrl, meta) {
      var constantPool = new ConstantPool();
      var bindingParser = makeBindingParser(meta.interpolation);
      var res = compileComponentFromMetadata(meta, constantPool, bindingParser);
      return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, constantPool.statements);
    }
  }, {
    key: "compileFactory",
    value: function compileFactory(angularCoreEnv, sourceMapUrl, meta) {
      var factoryRes = compileFactoryFunction({
        name: meta.name,
        type: wrapReference(meta.type),
        internalType: new WrappedNodeExpr(meta.type),
        typeArgumentCount: meta.typeArgumentCount,
        deps: convertR3DependencyMetadataArray(meta.deps),
        target: meta.target
      });
      return this.jitExpression(factoryRes.expression, angularCoreEnv, sourceMapUrl, factoryRes.statements);
    }
  }, {
    key: "compileFactoryDeclaration",
    value: function compileFactoryDeclaration(angularCoreEnv, sourceMapUrl, meta) {
      var factoryRes = compileFactoryFunction({
        name: meta.type.name,
        type: wrapReference(meta.type),
        internalType: new WrappedNodeExpr(meta.type),
        typeArgumentCount: 0,
        deps: Array.isArray(meta.deps) ? meta.deps.map(convertR3DeclareDependencyMetadata) : meta.deps,
        target: meta.target
      });
      return this.jitExpression(factoryRes.expression, angularCoreEnv, sourceMapUrl, factoryRes.statements);
    }
  }, {
    key: "createParseSourceSpan",
    value: function createParseSourceSpan(kind, typeName, sourceUrl) {
      return r3JitTypeSourceSpan(kind, typeName, sourceUrl);
    }
    /**
     * JIT compiles an expression and returns the result of executing that expression.
     *
     * @param def the definition which will be compiled and executed to get the value to patch
     * @param context an object map of @angular/core symbol names to symbols which will be available
     * in the context of the compiled expression
     * @param sourceUrl a URL to use for the source map of the compiled expression
     * @param preStatements a collection of statements that should be evaluated before the expression.
     */

  }, {
    key: "jitExpression",
    value: function jitExpression(def, context, sourceUrl, preStatements) {
      // The ConstantPool may contain Statements which declare variables used in the final expression.
      // Therefore, its statements need to precede the actual JIT operation. The final statement is a
      // declaration of $def which is set to the expression being compiled.
      var statements = [].concat((0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(preStatements), [new DeclareVarStmt('$def', def, undefined, StmtModifier.Exported)]);
      var res = this.jitEvaluator.evaluateStatements(sourceUrl, statements, new R3JitReflector(context),
      /* enableSourceMaps */
      true);
      return res['$def'];
    }
  }]);

  return CompilerFacadeImpl;
}();

function convertToR3QueryMetadata(facade) {
  return Object.assign(Object.assign({}, facade), {
    predicate: convertQueryPredicate(facade.predicate),
    read: facade.read ? new WrappedNodeExpr(facade.read) : null,
    static: facade.static,
    emitDistinctChangesOnly: facade.emitDistinctChangesOnly
  });
}

function convertQueryDeclarationToMetadata(declaration) {
  var _a, _b, _c, _d;

  return {
    propertyName: declaration.propertyName,
    first: (_a = declaration.first) !== null && _a !== void 0 ? _a : false,
    predicate: convertQueryPredicate(declaration.predicate),
    descendants: (_b = declaration.descendants) !== null && _b !== void 0 ? _b : false,
    read: declaration.read ? new WrappedNodeExpr(declaration.read) : null,
    static: (_c = declaration.static) !== null && _c !== void 0 ? _c : false,
    emitDistinctChangesOnly: (_d = declaration.emitDistinctChangesOnly) !== null && _d !== void 0 ? _d : true
  };
}

function convertQueryPredicate(predicate) {
  return Array.isArray(predicate) ? // The predicate is an array of strings so pass it through.
  predicate : // The predicate is a type - assume that we will need to unwrap any `forwardRef()` calls.
  createMayBeForwardRefExpression(new WrappedNodeExpr(predicate), 1
  /* ForwardRefHandling.Wrapped */
  );
}

function convertDirectiveFacadeToMetadata(facade) {
  var inputsFromMetadata = parseInputOutputs(facade.inputs || []);
  var outputsFromMetadata = parseInputOutputs(facade.outputs || []);
  var propMetadata = facade.propMetadata;
  var inputsFromType = {};
  var outputsFromType = {};

  var _loop4 = function _loop4(field) {
    if (propMetadata.hasOwnProperty(field)) {
      propMetadata[field].forEach(function (ann) {
        if (isInput(ann)) {
          inputsFromType[field] = ann.bindingPropertyName ? [ann.bindingPropertyName, field] : field;
        } else if (isOutput(ann)) {
          outputsFromType[field] = ann.bindingPropertyName || field;
        }
      });
    }
  };

  for (var field in propMetadata) {
    _loop4(field);
  }

  return Object.assign(Object.assign({}, facade), {
    typeArgumentCount: 0,
    typeSourceSpan: facade.typeSourceSpan,
    type: wrapReference(facade.type),
    internalType: new WrappedNodeExpr(facade.type),
    deps: null,
    host: extractHostBindings(facade.propMetadata, facade.typeSourceSpan, facade.host),
    inputs: Object.assign(Object.assign({}, inputsFromMetadata), inputsFromType),
    outputs: Object.assign(Object.assign({}, outputsFromMetadata), outputsFromType),
    queries: facade.queries.map(convertToR3QueryMetadata),
    providers: facade.providers != null ? new WrappedNodeExpr(facade.providers) : null,
    viewQueries: facade.viewQueries.map(convertToR3QueryMetadata),
    fullInheritance: false
  });
}

function convertDeclareDirectiveFacadeToMetadata(declaration, typeSourceSpan) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j;

  return {
    name: declaration.type.name,
    type: wrapReference(declaration.type),
    typeSourceSpan: typeSourceSpan,
    internalType: new WrappedNodeExpr(declaration.type),
    selector: (_a = declaration.selector) !== null && _a !== void 0 ? _a : null,
    inputs: (_b = declaration.inputs) !== null && _b !== void 0 ? _b : {},
    outputs: (_c = declaration.outputs) !== null && _c !== void 0 ? _c : {},
    host: convertHostDeclarationToMetadata(declaration.host),
    queries: ((_d = declaration.queries) !== null && _d !== void 0 ? _d : []).map(convertQueryDeclarationToMetadata),
    viewQueries: ((_e = declaration.viewQueries) !== null && _e !== void 0 ? _e : []).map(convertQueryDeclarationToMetadata),
    providers: declaration.providers !== undefined ? new WrappedNodeExpr(declaration.providers) : null,
    exportAs: (_f = declaration.exportAs) !== null && _f !== void 0 ? _f : null,
    usesInheritance: (_g = declaration.usesInheritance) !== null && _g !== void 0 ? _g : false,
    lifecycle: {
      usesOnChanges: (_h = declaration.usesOnChanges) !== null && _h !== void 0 ? _h : false
    },
    deps: null,
    typeArgumentCount: 0,
    fullInheritance: false,
    isStandalone: (_j = declaration.isStandalone) !== null && _j !== void 0 ? _j : false
  };
}

function convertHostDeclarationToMetadata() {
  var host = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var _a, _b, _c;

  return {
    attributes: convertOpaqueValuesToExpressions((_a = host.attributes) !== null && _a !== void 0 ? _a : {}),
    listeners: (_b = host.listeners) !== null && _b !== void 0 ? _b : {},
    properties: (_c = host.properties) !== null && _c !== void 0 ? _c : {},
    specialAttributes: {
      classAttr: host.classAttribute,
      styleAttr: host.styleAttribute
    }
  };
}

function convertOpaqueValuesToExpressions(obj) {
  var result = {};

  for (var _i19 = 0, _Object$keys4 = Object.keys(obj); _i19 < _Object$keys4.length; _i19++) {
    var key = _Object$keys4[_i19];
    result[key] = new WrappedNodeExpr(obj[key]);
  }

  return result;
}

function convertDeclareComponentFacadeToMetadata(decl, typeSourceSpan, sourceMapUrl) {
  var _a, _b, _c, _d;

  var _parseJitTemplate2 = parseJitTemplate(decl.template, decl.type.name, sourceMapUrl, (_a = decl.preserveWhitespaces) !== null && _a !== void 0 ? _a : false, decl.interpolation),
      template = _parseJitTemplate2.template,
      interpolation = _parseJitTemplate2.interpolation;

  var declarations = [];

  if (decl.dependencies) {
    var _iterator32 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper_js__WEBPACK_IMPORTED_MODULE_9__["default"])(decl.dependencies),
        _step32;

    try {
      for (_iterator32.s(); !(_step32 = _iterator32.n()).done;) {
        var innerDep = _step32.value;

        switch (innerDep.kind) {
          case 'directive':
          case 'component':
            declarations.push(convertDirectiveDeclarationToMetadata(innerDep));
            break;

          case 'pipe':
            declarations.push(convertPipeDeclarationToMetadata(innerDep));
            break;
        }
      }
    } catch (err) {
      _iterator32.e(err);
    } finally {
      _iterator32.f();
    }
  } else if (decl.components || decl.directives || decl.pipes) {
    // Existing declarations on NPM may not be using the new `dependencies` merged field, and may
    // have separate fields for dependencies instead. Unify them for JIT compilation.
    decl.components && declarations.push.apply(declarations, (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(decl.components.map(function (dir) {
      return convertDirectiveDeclarationToMetadata(dir,
      /* isComponent */
      true);
    })));
    decl.directives && declarations.push.apply(declarations, (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(decl.directives.map(function (dir) {
      return convertDirectiveDeclarationToMetadata(dir);
    })));
    decl.pipes && declarations.push.apply(declarations, (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(convertPipeMapToMetadata(decl.pipes)));
  }

  return Object.assign(Object.assign({}, convertDeclareDirectiveFacadeToMetadata(decl, typeSourceSpan)), {
    template: template,
    styles: (_b = decl.styles) !== null && _b !== void 0 ? _b : [],
    declarations: declarations,
    viewProviders: decl.viewProviders !== undefined ? new WrappedNodeExpr(decl.viewProviders) : null,
    animations: decl.animations !== undefined ? new WrappedNodeExpr(decl.animations) : null,
    changeDetection: (_c = decl.changeDetection) !== null && _c !== void 0 ? _c : ChangeDetectionStrategy.Default,
    encapsulation: (_d = decl.encapsulation) !== null && _d !== void 0 ? _d : ViewEncapsulation.Emulated,
    interpolation: interpolation,
    declarationListEmitMode: 2
    /* DeclarationListEmitMode.ClosureResolved */
    ,
    relativeContextFilePath: '',
    i18nUseExternalIds: true
  });
}

function convertDeclarationFacadeToMetadata(declaration) {
  return Object.assign(Object.assign({}, declaration), {
    type: new WrappedNodeExpr(declaration.type)
  });
}

function convertDirectiveDeclarationToMetadata(declaration) {
  var isComponent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

  var _a, _b, _c;

  return {
    kind: R3TemplateDependencyKind.Directive,
    isComponent: isComponent || declaration.kind === 'component',
    selector: declaration.selector,
    type: new WrappedNodeExpr(declaration.type),
    inputs: (_a = declaration.inputs) !== null && _a !== void 0 ? _a : [],
    outputs: (_b = declaration.outputs) !== null && _b !== void 0 ? _b : [],
    exportAs: (_c = declaration.exportAs) !== null && _c !== void 0 ? _c : null
  };
}

function convertPipeMapToMetadata(pipes) {
  if (!pipes) {
    return [];
  }

  return Object.keys(pipes).map(function (name) {
    return {
      kind: R3TemplateDependencyKind.Pipe,
      name: name,
      type: new WrappedNodeExpr(pipes[name])
    };
  });
}

function convertPipeDeclarationToMetadata(pipe) {
  return {
    kind: R3TemplateDependencyKind.Pipe,
    name: pipe.name,
    type: new WrappedNodeExpr(pipe.type)
  };
}

function parseJitTemplate(template, typeName, sourceMapUrl, preserveWhitespaces, interpolation) {
  var interpolationConfig = interpolation ? InterpolationConfig.fromArray(interpolation) : DEFAULT_INTERPOLATION_CONFIG; // Parse the template and check for errors.

  var parsed = parseTemplate(template, sourceMapUrl, {
    preserveWhitespaces: preserveWhitespaces,
    interpolationConfig: interpolationConfig
  });

  if (parsed.errors !== null) {
    var errors = parsed.errors.map(function (err) {
      return err.toString();
    }).join(', ');
    throw new Error("Errors during JIT compilation of template for ".concat(typeName, ": ").concat(errors));
  }

  return {
    template: parsed,
    interpolation: interpolationConfig
  };
}
/**
 * Convert the expression, if present to an `R3ProviderExpression`.
 *
 * In JIT mode we do not want the compiler to wrap the expression in a `forwardRef()` call because,
 * if it is referencing a type that has not yet been defined, it will have already been wrapped in
 * a `forwardRef()` - either by the application developer or during partial-compilation. Thus we can
 * use `ForwardRefHandling.None`.
 */


function convertToProviderExpression(obj, property) {
  if (obj.hasOwnProperty(property)) {
    return createMayBeForwardRefExpression(new WrappedNodeExpr(obj[property]), 0
    /* ForwardRefHandling.None */
    );
  } else {
    return undefined;
  }
}

function wrapExpression(obj, property) {
  if (obj.hasOwnProperty(property)) {
    return new WrappedNodeExpr(obj[property]);
  } else {
    return undefined;
  }
}

function computeProvidedIn(providedIn) {
  var expression = typeof providedIn === 'function' ? new WrappedNodeExpr(providedIn) : new LiteralExpr(providedIn !== null && providedIn !== void 0 ? providedIn : null); // See `convertToProviderExpression()` for why this uses `ForwardRefHandling.None`.

  return createMayBeForwardRefExpression(expression, 0
  /* ForwardRefHandling.None */
  );
}

function convertR3DependencyMetadataArray(facades) {
  return facades == null ? null : facades.map(convertR3DependencyMetadata);
}

function convertR3DependencyMetadata(facade) {
  var isAttributeDep = facade.attribute != null; // both `null` and `undefined`

  var rawToken = facade.token === null ? null : new WrappedNodeExpr(facade.token); // In JIT mode, if the dep is an `@Attribute()` then we use the attribute name given in
  // `attribute` rather than the `token`.

  var token = isAttributeDep ? new WrappedNodeExpr(facade.attribute) : rawToken;
  return createR3DependencyMetadata(token, isAttributeDep, facade.host, facade.optional, facade.self, facade.skipSelf);
}

function convertR3DeclareDependencyMetadata(facade) {
  var _a, _b, _c, _d, _e;

  var isAttributeDep = (_a = facade.attribute) !== null && _a !== void 0 ? _a : false;
  var token = facade.token === null ? null : new WrappedNodeExpr(facade.token);
  return createR3DependencyMetadata(token, isAttributeDep, (_b = facade.host) !== null && _b !== void 0 ? _b : false, (_c = facade.optional) !== null && _c !== void 0 ? _c : false, (_d = facade.self) !== null && _d !== void 0 ? _d : false, (_e = facade.skipSelf) !== null && _e !== void 0 ? _e : false);
}

function createR3DependencyMetadata(token, isAttributeDep, host, optional, self, skipSelf) {
  // If the dep is an `@Attribute()` the `attributeNameType` ought to be the `unknown` type.
  // But types are not available at runtime so we just use a literal `"<unknown>"` string as a dummy
  // marker.
  var attributeNameType = isAttributeDep ? literal('unknown') : null;
  return {
    token: token,
    attributeNameType: attributeNameType,
    host: host,
    optional: optional,
    self: self,
    skipSelf: skipSelf
  };
}

function extractHostBindings(propMetadata, sourceSpan, host) {
  // First parse the declarations from the metadata.
  var bindings = parseHostBindings(host || {}); // After that check host bindings for errors

  var errors = verifyHostBindings(bindings, sourceSpan);

  if (errors.length) {
    throw new Error(errors.map(function (error) {
      return error.msg;
    }).join('\n'));
  } // Next, loop over the properties of the object, looking for @HostBinding and @HostListener.


  var _loop5 = function _loop5(field) {
    if (propMetadata.hasOwnProperty(field)) {
      propMetadata[field].forEach(function (ann) {
        if (isHostBinding(ann)) {
          // Since this is a decorator, we know that the value is a class member. Always access it
          // through `this` so that further down the line it can't be confused for a literal value
          // (e.g. if there's a property called `true`).
          bindings.properties[ann.hostPropertyName || field] = getSafePropertyAccessString('this', field);
        } else if (isHostListener(ann)) {
          bindings.listeners[ann.eventName || field] = "".concat(field, "(").concat((ann.args || []).join(','), ")");
        }
      });
    }
  };

  for (var field in propMetadata) {
    _loop5(field);
  }

  return bindings;
}

function isHostBinding(value) {
  return value.ngMetadataName === 'HostBinding';
}

function isHostListener(value) {
  return value.ngMetadataName === 'HostListener';
}

function isInput(value) {
  return value.ngMetadataName === 'Input';
}

function isOutput(value) {
  return value.ngMetadataName === 'Output';
}

function parseInputOutputs(values) {
  return values.reduce(function (map, value) {
    var _value$split$map = value.split(',').map(function (piece) {
      return piece.trim();
    }),
        _value$split$map2 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_slicedToArray_js__WEBPACK_IMPORTED_MODULE_3__["default"])(_value$split$map, 2),
        field = _value$split$map2[0],
        property = _value$split$map2[1];

    map[field] = property || field;
    return map;
  }, {});
}

function convertDeclarePipeFacadeToMetadata(declaration) {
  var _a, _b;

  return {
    name: declaration.type.name,
    type: wrapReference(declaration.type),
    internalType: new WrappedNodeExpr(declaration.type),
    typeArgumentCount: 0,
    pipeName: declaration.name,
    deps: null,
    pure: (_a = declaration.pure) !== null && _a !== void 0 ? _a : true,
    isStandalone: (_b = declaration.isStandalone) !== null && _b !== void 0 ? _b : false
  };
}

function convertDeclareInjectorFacadeToMetadata(declaration) {
  return {
    name: declaration.type.name,
    type: wrapReference(declaration.type),
    internalType: new WrappedNodeExpr(declaration.type),
    providers: declaration.providers !== undefined && declaration.providers.length > 0 ? new WrappedNodeExpr(declaration.providers) : null,
    imports: declaration.imports !== undefined ? declaration.imports.map(function (i) {
      return new WrappedNodeExpr(i);
    }) : []
  };
}

function publishFacade(global) {
  var ng = global.ng || (global.ng = {});
  ng.ɵcompilerFacade = new CompilerFacadeImpl();
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */


var VERSION = new Version('14.0.2');
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

var CompilerConfig = /*#__PURE__*/(0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(function CompilerConfig() {
  var _ref13 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref13$defaultEncapsu = _ref13.defaultEncapsulation,
      defaultEncapsulation = _ref13$defaultEncapsu === void 0 ? ViewEncapsulation.Emulated : _ref13$defaultEncapsu,
      _ref13$useJit = _ref13.useJit,
      useJit = _ref13$useJit === void 0 ? true : _ref13$useJit,
      _ref13$jitDevMode = _ref13.jitDevMode,
      jitDevMode = _ref13$jitDevMode === void 0 ? false : _ref13$jitDevMode,
      _ref13$missingTransla = _ref13.missingTranslation,
      missingTranslation = _ref13$missingTransla === void 0 ? null : _ref13$missingTransla,
      preserveWhitespaces = _ref13.preserveWhitespaces,
      strictInjectionParameters = _ref13.strictInjectionParameters;

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, CompilerConfig);

  this.defaultEncapsulation = defaultEncapsulation;
  this.useJit = !!useJit;
  this.jitDevMode = !!jitDevMode;
  this.missingTranslation = missingTranslation;
  this.preserveWhitespaces = preserveWhitespacesDefault(noUndefined(preserveWhitespaces));
  this.strictInjectionParameters = strictInjectionParameters === true;
});

function preserveWhitespacesDefault(preserveWhitespacesOption) {
  var defaultSetting = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  return preserveWhitespacesOption === null ? defaultSetting : preserveWhitespacesOption;
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */


var _I18N_ATTR = 'i18n';
var _I18N_ATTR_PREFIX = 'i18n-';
var _I18N_COMMENT_PREFIX_REGEXP = /^i18n:?/;
var MEANING_SEPARATOR = '|';
var ID_SEPARATOR = '@@';
var i18nCommentsWarned = false;
/**
 * Extract translatable messages from an html AST
 */

function extractMessages(nodes, interpolationConfig, implicitTags, implicitAttrs) {
  var visitor = new _Visitor(implicitTags, implicitAttrs);
  return visitor.extract(nodes, interpolationConfig);
}

function mergeTranslations(nodes, translations, interpolationConfig, implicitTags, implicitAttrs) {
  var visitor = new _Visitor(implicitTags, implicitAttrs);
  return visitor.merge(nodes, translations, interpolationConfig);
}

var ExtractionResult = /*#__PURE__*/(0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(function ExtractionResult(messages, errors) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, ExtractionResult);

  this.messages = messages;
  this.errors = errors;
});

var _VisitorMode;

(function (_VisitorMode) {
  _VisitorMode[_VisitorMode["Extract"] = 0] = "Extract";
  _VisitorMode[_VisitorMode["Merge"] = 1] = "Merge";
})(_VisitorMode || (_VisitorMode = {}));
/**
 * This Visitor is used:
 * 1. to extract all the translatable strings from an html AST (see `extract()`),
 * 2. to replace the translatable strings with the actual translations (see `merge()`)
 *
 * @internal
 */


var _Visitor = /*#__PURE__*/function () {
  function _Visitor(_implicitTags, _implicitAttrs) {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, _Visitor);

    this._implicitTags = _implicitTags;
    this._implicitAttrs = _implicitAttrs;
  }
  /**
   * Extracts the messages from the tree
   */


  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(_Visitor, [{
    key: "extract",
    value: function extract(nodes, interpolationConfig) {
      var _this158 = this;

      this._init(_VisitorMode.Extract, interpolationConfig);

      nodes.forEach(function (node) {
        return node.visit(_this158, null);
      });

      if (this._inI18nBlock) {
        this._reportError(nodes[nodes.length - 1], 'Unclosed block');
      }

      return new ExtractionResult(this._messages, this._errors);
    }
    /**
     * Returns a tree where all translatable nodes are translated
     */

  }, {
    key: "merge",
    value: function merge(nodes, translations, interpolationConfig) {
      this._init(_VisitorMode.Merge, interpolationConfig);

      this._translations = translations; // Construct a single fake root element

      var wrapper = new Element('wrapper', [], nodes, undefined, undefined, undefined);
      var translatedNode = wrapper.visit(this, null);

      if (this._inI18nBlock) {
        this._reportError(nodes[nodes.length - 1], 'Unclosed block');
      }

      return new ParseTreeResult(translatedNode.children, this._errors);
    }
  }, {
    key: "visitExpansionCase",
    value: function visitExpansionCase(icuCase, context) {
      // Parse cases for translatable html attributes
      var expression = visitAll(this, icuCase.expression, context);

      if (this._mode === _VisitorMode.Merge) {
        return new ExpansionCase(icuCase.value, expression, icuCase.sourceSpan, icuCase.valueSourceSpan, icuCase.expSourceSpan);
      }
    }
  }, {
    key: "visitExpansion",
    value: function visitExpansion(icu, context) {
      this._mayBeAddBlockChildren(icu);

      var wasInIcu = this._inIcu;

      if (!this._inIcu) {
        // nested ICU messages should not be extracted but top-level translated as a whole
        if (this._isInTranslatableSection) {
          this._addMessage([icu]);
        }

        this._inIcu = true;
      }

      var cases = visitAll(this, icu.cases, context);

      if (this._mode === _VisitorMode.Merge) {
        icu = new Expansion(icu.switchValue, icu.type, cases, icu.sourceSpan, icu.switchValueSourceSpan);
      }

      this._inIcu = wasInIcu;
      return icu;
    }
  }, {
    key: "visitComment",
    value: function visitComment(comment, context) {
      var isOpening = _isOpeningComment(comment);

      if (isOpening && this._isInTranslatableSection) {
        this._reportError(comment, 'Could not start a block inside a translatable section');

        return;
      }

      var isClosing = _isClosingComment(comment);

      if (isClosing && !this._inI18nBlock) {
        this._reportError(comment, 'Trying to close an unopened block');

        return;
      }

      if (!this._inI18nNode && !this._inIcu) {
        if (!this._inI18nBlock) {
          if (isOpening) {
            // deprecated from v5 you should use <ng-container i18n> instead of i18n comments
            if (!i18nCommentsWarned && console && console.warn) {
              i18nCommentsWarned = true;
              var details = comment.sourceSpan.details ? ", ".concat(comment.sourceSpan.details) : ''; // TODO(ocombe): use a log service once there is a public one available

              console.warn("I18n comments are deprecated, use an <ng-container> element instead (".concat(comment.sourceSpan.start).concat(details, ")"));
            }

            this._inI18nBlock = true;
            this._blockStartDepth = this._depth;
            this._blockChildren = [];
            this._blockMeaningAndDesc = comment.value.replace(_I18N_COMMENT_PREFIX_REGEXP, '').trim();

            this._openTranslatableSection(comment);
          }
        } else {
          if (isClosing) {
            if (this._depth == this._blockStartDepth) {
              this._closeTranslatableSection(comment, this._blockChildren);

              this._inI18nBlock = false;

              var message = this._addMessage(this._blockChildren, this._blockMeaningAndDesc); // merge attributes in sections


              var nodes = this._translateMessage(comment, message);

              return visitAll(this, nodes);
            } else {
              this._reportError(comment, 'I18N blocks should not cross element boundaries');

              return;
            }
          }
        }
      }
    }
  }, {
    key: "visitText",
    value: function visitText(text, context) {
      if (this._isInTranslatableSection) {
        this._mayBeAddBlockChildren(text);
      }

      return text;
    }
  }, {
    key: "visitElement",
    value: function visitElement(el, context) {
      var _this159 = this;

      this._mayBeAddBlockChildren(el);

      this._depth++;
      var wasInI18nNode = this._inI18nNode;
      var wasInImplicitNode = this._inImplicitNode;
      var childNodes = [];
      var translatedChildNodes = undefined; // Extract:
      // - top level nodes with the (implicit) "i18n" attribute if not already in a section
      // - ICU messages

      var i18nAttr = _getI18nAttr(el);

      var i18nMeta = i18nAttr ? i18nAttr.value : '';
      var isImplicit = this._implicitTags.some(function (tag) {
        return el.name === tag;
      }) && !this._inIcu && !this._isInTranslatableSection;
      var isTopLevelImplicit = !wasInImplicitNode && isImplicit;
      this._inImplicitNode = wasInImplicitNode || isImplicit;

      if (!this._isInTranslatableSection && !this._inIcu) {
        if (i18nAttr || isTopLevelImplicit) {
          this._inI18nNode = true;

          var message = this._addMessage(el.children, i18nMeta);

          translatedChildNodes = this._translateMessage(el, message);
        }

        if (this._mode == _VisitorMode.Extract) {
          var isTranslatable = i18nAttr || isTopLevelImplicit;
          if (isTranslatable) this._openTranslatableSection(el);
          visitAll(this, el.children);
          if (isTranslatable) this._closeTranslatableSection(el, el.children);
        }
      } else {
        if (i18nAttr || isTopLevelImplicit) {
          this._reportError(el, 'Could not mark an element as translatable inside a translatable section');
        }

        if (this._mode == _VisitorMode.Extract) {
          // Descend into child nodes for extraction
          visitAll(this, el.children);
        }
      }

      if (this._mode === _VisitorMode.Merge) {
        var visitNodes = translatedChildNodes || el.children;
        visitNodes.forEach(function (child) {
          var visited = child.visit(_this159, context);

          if (visited && !_this159._isInTranslatableSection) {
            // Do not add the children from translatable sections (= i18n blocks here)
            // They will be added later in this loop when the block closes (i.e. on `<!-- /i18n -->`)
            childNodes = childNodes.concat(visited);
          }
        });
      }

      this._visitAttributesOf(el);

      this._depth--;
      this._inI18nNode = wasInI18nNode;
      this._inImplicitNode = wasInImplicitNode;

      if (this._mode === _VisitorMode.Merge) {
        var translatedAttrs = this._translateAttributes(el);

        return new Element(el.name, translatedAttrs, childNodes, el.sourceSpan, el.startSourceSpan, el.endSourceSpan);
      }

      return null;
    }
  }, {
    key: "visitAttribute",
    value: function visitAttribute(attribute, context) {
      throw new Error('unreachable code');
    }
  }, {
    key: "_init",
    value: function _init(mode, interpolationConfig) {
      this._mode = mode;
      this._inI18nBlock = false;
      this._inI18nNode = false;
      this._depth = 0;
      this._inIcu = false;
      this._msgCountAtSectionStart = undefined;
      this._errors = [];
      this._messages = [];
      this._inImplicitNode = false;
      this._createI18nMessage = createI18nMessageFactory(interpolationConfig);
    } // looks for translatable attributes

  }, {
    key: "_visitAttributesOf",
    value: function _visitAttributesOf(el) {
      var _this160 = this;

      var explicitAttrNameToValue = {};
      var implicitAttrNames = this._implicitAttrs[el.name] || [];
      el.attrs.filter(function (attr) {
        return attr.name.startsWith(_I18N_ATTR_PREFIX);
      }).forEach(function (attr) {
        return explicitAttrNameToValue[attr.name.slice(_I18N_ATTR_PREFIX.length)] = attr.value;
      });
      el.attrs.forEach(function (attr) {
        if (attr.name in explicitAttrNameToValue) {
          _this160._addMessage([attr], explicitAttrNameToValue[attr.name]);
        } else if (implicitAttrNames.some(function (name) {
          return attr.name === name;
        })) {
          _this160._addMessage([attr]);
        }
      });
    } // add a translatable message

  }, {
    key: "_addMessage",
    value: function _addMessage(ast, msgMeta) {
      if (ast.length == 0 || ast.length == 1 && ast[0] instanceof Attribute && !ast[0].value) {
        // Do not create empty messages
        return null;
      }

      var _parseMessageMeta2 = _parseMessageMeta(msgMeta),
          meaning = _parseMessageMeta2.meaning,
          description = _parseMessageMeta2.description,
          id = _parseMessageMeta2.id;

      var message = this._createI18nMessage(ast, meaning, description, id);

      this._messages.push(message);

      return message;
    } // Translates the given message given the `TranslationBundle`
    // This is used for translating elements / blocks - see `_translateAttributes` for attributes
    // no-op when called in extraction mode (returns [])

  }, {
    key: "_translateMessage",
    value: function _translateMessage(el, message) {
      if (message && this._mode === _VisitorMode.Merge) {
        var nodes = this._translations.get(message);

        if (nodes) {
          return nodes;
        }

        this._reportError(el, "Translation unavailable for message id=\"".concat(this._translations.digest(message), "\""));
      }

      return [];
    } // translate the attributes of an element and remove i18n specific attributes

  }, {
    key: "_translateAttributes",
    value: function _translateAttributes(el) {
      var _this161 = this;

      var attributes = el.attrs;
      var i18nParsedMessageMeta = {};
      attributes.forEach(function (attr) {
        if (attr.name.startsWith(_I18N_ATTR_PREFIX)) {
          i18nParsedMessageMeta[attr.name.slice(_I18N_ATTR_PREFIX.length)] = _parseMessageMeta(attr.value);
        }
      });
      var translatedAttributes = [];
      attributes.forEach(function (attr) {
        if (attr.name === _I18N_ATTR || attr.name.startsWith(_I18N_ATTR_PREFIX)) {
          // strip i18n specific attributes
          return;
        }

        if (attr.value && attr.value != '' && i18nParsedMessageMeta.hasOwnProperty(attr.name)) {
          var _i18nParsedMessageMet = i18nParsedMessageMeta[attr.name],
              meaning = _i18nParsedMessageMet.meaning,
              description = _i18nParsedMessageMet.description,
              id = _i18nParsedMessageMet.id;

          var message = _this161._createI18nMessage([attr], meaning, description, id);

          var nodes = _this161._translations.get(message);

          if (nodes) {
            if (nodes.length == 0) {
              translatedAttributes.push(new Attribute(attr.name, '', attr.sourceSpan, undefined
              /* keySpan */
              , undefined
              /* valueSpan */
              , undefined
              /* valueTokens */
              , undefined
              /* i18n */
              ));
            } else if (nodes[0] instanceof Text) {
              var value = nodes[0].value;
              translatedAttributes.push(new Attribute(attr.name, value, attr.sourceSpan, undefined
              /* keySpan */
              , undefined
              /* valueSpan */
              , undefined
              /* valueTokens */
              , undefined
              /* i18n */
              ));
            } else {
              _this161._reportError(el, "Unexpected translation for attribute \"".concat(attr.name, "\" (id=\"").concat(id || _this161._translations.digest(message), "\")"));
            }
          } else {
            _this161._reportError(el, "Translation unavailable for attribute \"".concat(attr.name, "\" (id=\"").concat(id || _this161._translations.digest(message), "\")"));
          }
        } else {
          translatedAttributes.push(attr);
        }
      });
      return translatedAttributes;
    }
    /**
     * Add the node as a child of the block when:
     * - we are in a block,
     * - we are not inside a ICU message (those are handled separately),
     * - the node is a "direct child" of the block
     */

  }, {
    key: "_mayBeAddBlockChildren",
    value: function _mayBeAddBlockChildren(node) {
      if (this._inI18nBlock && !this._inIcu && this._depth == this._blockStartDepth) {
        this._blockChildren.push(node);
      }
    }
    /**
     * Marks the start of a section, see `_closeTranslatableSection`
     */

  }, {
    key: "_openTranslatableSection",
    value: function _openTranslatableSection(node) {
      if (this._isInTranslatableSection) {
        this._reportError(node, 'Unexpected section start');
      } else {
        this._msgCountAtSectionStart = this._messages.length;
      }
    }
    /**
     * A translatable section could be:
     * - the content of translatable element,
     * - nodes between `<!-- i18n -->` and `<!-- /i18n -->` comments
     */

  }, {
    key: "_isInTranslatableSection",
    get: function get() {
      return this._msgCountAtSectionStart !== void 0;
    }
    /**
     * Terminates a section.
     *
     * If a section has only one significant children (comments not significant) then we should not
     * keep the message from this children:
     *
     * `<p i18n="meaning|description">{ICU message}</p>` would produce two messages:
     * - one for the <p> content with meaning and description,
     * - another one for the ICU message.
     *
     * In this case the last message is discarded as it contains less information (the AST is
     * otherwise identical).
     *
     * Note that we should still keep messages extracted from attributes inside the section (ie in the
     * ICU message here)
     */

  }, {
    key: "_closeTranslatableSection",
    value: function _closeTranslatableSection(node, directChildren) {
      if (!this._isInTranslatableSection) {
        this._reportError(node, 'Unexpected section end');

        return;
      }

      var startIndex = this._msgCountAtSectionStart;
      var significantChildren = directChildren.reduce(function (count, node) {
        return count + (node instanceof Comment ? 0 : 1);
      }, 0);

      if (significantChildren == 1) {
        for (var i = this._messages.length - 1; i >= startIndex; i--) {
          var ast = this._messages[i].nodes;

          if (!(ast.length == 1 && ast[0] instanceof Text$2)) {
            this._messages.splice(i, 1);

            break;
          }
        }
      }

      this._msgCountAtSectionStart = undefined;
    }
  }, {
    key: "_reportError",
    value: function _reportError(node, msg) {
      this._errors.push(new I18nError(node.sourceSpan, msg));
    }
  }]);

  return _Visitor;
}();

function _isOpeningComment(n) {
  return !!(n instanceof Comment && n.value && n.value.startsWith('i18n'));
}

function _isClosingComment(n) {
  return !!(n instanceof Comment && n.value && n.value === '/i18n');
}

function _getI18nAttr(p) {
  return p.attrs.find(function (attr) {
    return attr.name === _I18N_ATTR;
  }) || null;
}

function _parseMessageMeta(i18n) {
  if (!i18n) return {
    meaning: '',
    description: '',
    id: ''
  };
  var idIndex = i18n.indexOf(ID_SEPARATOR);
  var descIndex = i18n.indexOf(MEANING_SEPARATOR);

  var _ref14 = idIndex > -1 ? [i18n.slice(0, idIndex), i18n.slice(idIndex + 2)] : [i18n, ''],
      _ref15 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_slicedToArray_js__WEBPACK_IMPORTED_MODULE_3__["default"])(_ref14, 2),
      meaningAndDesc = _ref15[0],
      id = _ref15[1];

  var _ref16 = descIndex > -1 ? [meaningAndDesc.slice(0, descIndex), meaningAndDesc.slice(descIndex + 1)] : ['', meaningAndDesc],
      _ref17 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_slicedToArray_js__WEBPACK_IMPORTED_MODULE_3__["default"])(_ref16, 2),
      meaning = _ref17[0],
      description = _ref17[1];

  return {
    meaning: meaning,
    description: description,
    id: id.trim()
  };
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */


var XmlTagDefinition = /*#__PURE__*/function () {
  function XmlTagDefinition() {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, XmlTagDefinition);

    this.closedByParent = false;
    this.isVoid = false;
    this.ignoreFirstLf = false;
    this.canSelfClose = true;
    this.preventNamespaceInheritance = false;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(XmlTagDefinition, [{
    key: "requireExtraParent",
    value: function requireExtraParent(currentParent) {
      return false;
    }
  }, {
    key: "isClosedByChild",
    value: function isClosedByChild(name) {
      return false;
    }
  }, {
    key: "getContentType",
    value: function getContentType() {
      return TagContentType.PARSABLE_DATA;
    }
  }]);

  return XmlTagDefinition;
}();

var _TAG_DEFINITION = new XmlTagDefinition();

function getXmlTagDefinition(tagName) {
  return _TAG_DEFINITION;
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */


var XmlParser = /*#__PURE__*/function (_Parser2) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(XmlParser, _Parser2);

  var _super80 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(XmlParser);

  function XmlParser() {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, XmlParser);

    return _super80.call(this, getXmlTagDefinition);
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(XmlParser, [{
    key: "parse",
    value: function parse(source, url, options) {
      return (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_5__["default"])((0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_6__["default"])(XmlParser.prototype), "parse", this).call(this, source, url, options);
    }
  }]);

  return XmlParser;
}(Parser);
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */


var _VERSION$1 = '1.2';
var _XMLNS$1 = 'urn:oasis:names:tc:xliff:document:1.2'; // TODO(vicb): make this a param (s/_/-/)

var _DEFAULT_SOURCE_LANG$1 = 'en';
var _PLACEHOLDER_TAG$2 = 'x';
var _MARKER_TAG$1 = 'mrk';
var _FILE_TAG = 'file';
var _SOURCE_TAG$1 = 'source';
var _SEGMENT_SOURCE_TAG = 'seg-source';
var _ALT_TRANS_TAG = 'alt-trans';
var _TARGET_TAG$1 = 'target';
var _UNIT_TAG$1 = 'trans-unit';
var _CONTEXT_GROUP_TAG = 'context-group';
var _CONTEXT_TAG = 'context'; // https://docs.oasis-open.org/xliff/v1.2/os/xliff-core.html
// https://docs.oasis-open.org/xliff/v1.2/xliff-profile-html/xliff-profile-html-1.2.html

var Xliff = /*#__PURE__*/function (_Serializer2) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(Xliff, _Serializer2);

  var _super81 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(Xliff);

  function Xliff() {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, Xliff);

    return _super81.apply(this, arguments);
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(Xliff, [{
    key: "write",
    value: function write(messages, locale) {
      var visitor = new _WriteVisitor$1();
      var transUnits = [];
      messages.forEach(function (message) {
        var _transUnit$children;

        var contextTags = [];
        message.sources.forEach(function (source) {
          var contextGroupTag = new Tag(_CONTEXT_GROUP_TAG, {
            purpose: 'location'
          });
          contextGroupTag.children.push(new CR(10), new Tag(_CONTEXT_TAG, {
            'context-type': 'sourcefile'
          }, [new Text$1(source.filePath)]), new CR(10), new Tag(_CONTEXT_TAG, {
            'context-type': 'linenumber'
          }, [new Text$1("".concat(source.startLine))]), new CR(8));
          contextTags.push(new CR(8), contextGroupTag);
        });
        var transUnit = new Tag(_UNIT_TAG$1, {
          id: message.id,
          datatype: 'html'
        });

        (_transUnit$children = transUnit.children).push.apply(_transUnit$children, [new CR(8), new Tag(_SOURCE_TAG$1, {}, visitor.serialize(message.nodes))].concat(contextTags));

        if (message.description) {
          transUnit.children.push(new CR(8), new Tag('note', {
            priority: '1',
            from: 'description'
          }, [new Text$1(message.description)]));
        }

        if (message.meaning) {
          transUnit.children.push(new CR(8), new Tag('note', {
            priority: '1',
            from: 'meaning'
          }, [new Text$1(message.meaning)]));
        }

        transUnit.children.push(new CR(6));
        transUnits.push(new CR(6), transUnit);
      });
      var body = new Tag('body', {}, [].concat(transUnits, [new CR(4)]));
      var file = new Tag('file', {
        'source-language': locale || _DEFAULT_SOURCE_LANG$1,
        datatype: 'plaintext',
        original: 'ng2.template'
      }, [new CR(4), body, new CR(2)]);
      var xliff = new Tag('xliff', {
        version: _VERSION$1,
        xmlns: _XMLNS$1
      }, [new CR(2), file, new CR()]);
      return serialize([new Declaration({
        version: '1.0',
        encoding: 'UTF-8'
      }), new CR(), xliff, new CR()]);
    }
  }, {
    key: "load",
    value: function load(content, url) {
      // xliff to xml nodes
      var xliffParser = new XliffParser();

      var _xliffParser$parse = xliffParser.parse(content, url),
          locale = _xliffParser$parse.locale,
          msgIdToHtml = _xliffParser$parse.msgIdToHtml,
          errors = _xliffParser$parse.errors; // xml nodes to i18n nodes


      var i18nNodesByMsgId = {};
      var converter = new XmlToI18n$2();
      Object.keys(msgIdToHtml).forEach(function (msgId) {
        var _converter$convert = converter.convert(msgIdToHtml[msgId], url),
            i18nNodes = _converter$convert.i18nNodes,
            e = _converter$convert.errors;

        errors.push.apply(errors, (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(e));
        i18nNodesByMsgId[msgId] = i18nNodes;
      });

      if (errors.length) {
        throw new Error("xliff parse errors:\n".concat(errors.join('\n')));
      }

      return {
        locale: locale,
        i18nNodesByMsgId: i18nNodesByMsgId
      };
    }
  }, {
    key: "digest",
    value: function digest(message) {
      return digest$1(message);
    }
  }]);

  return Xliff;
}(Serializer);

var _WriteVisitor$1 = /*#__PURE__*/function () {
  function _WriteVisitor$1() {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, _WriteVisitor$1);
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(_WriteVisitor$1, [{
    key: "visitText",
    value: function visitText(text, context) {
      return [new Text$1(text.value)];
    }
  }, {
    key: "visitContainer",
    value: function visitContainer(container, context) {
      var _this162 = this;

      var nodes = [];
      container.children.forEach(function (node) {
        return nodes.push.apply(nodes, (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(node.visit(_this162)));
      });
      return nodes;
    }
  }, {
    key: "visitIcu",
    value: function visitIcu(icu, context) {
      var _this163 = this;

      var nodes = [new Text$1("{".concat(icu.expressionPlaceholder, ", ").concat(icu.type, ", "))];
      Object.keys(icu.cases).forEach(function (c) {
        nodes.push.apply(nodes, [new Text$1("".concat(c, " {"))].concat((0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(icu.cases[c].visit(_this163)), [new Text$1("} ")]));
      });
      nodes.push(new Text$1("}"));
      return nodes;
    }
  }, {
    key: "visitTagPlaceholder",
    value: function visitTagPlaceholder(ph, context) {
      var ctype = getCtypeForTag(ph.tag);

      if (ph.isVoid) {
        // void tags have no children nor closing tags
        return [new Tag(_PLACEHOLDER_TAG$2, {
          id: ph.startName,
          ctype: ctype,
          'equiv-text': "<".concat(ph.tag, "/>")
        })];
      }

      var startTagPh = new Tag(_PLACEHOLDER_TAG$2, {
        id: ph.startName,
        ctype: ctype,
        'equiv-text': "<".concat(ph.tag, ">")
      });
      var closeTagPh = new Tag(_PLACEHOLDER_TAG$2, {
        id: ph.closeName,
        ctype: ctype,
        'equiv-text': "</".concat(ph.tag, ">")
      });
      return [startTagPh].concat((0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(this.serialize(ph.children)), [closeTagPh]);
    }
  }, {
    key: "visitPlaceholder",
    value: function visitPlaceholder(ph, context) {
      return [new Tag(_PLACEHOLDER_TAG$2, {
        id: ph.name,
        'equiv-text': "{{".concat(ph.value, "}}")
      })];
    }
  }, {
    key: "visitIcuPlaceholder",
    value: function visitIcuPlaceholder(ph, context) {
      var equivText = "{".concat(ph.value.expression, ", ").concat(ph.value.type, ", ").concat(Object.keys(ph.value.cases).map(function (value) {
        return value + ' {...}';
      }).join(' '), "}");
      return [new Tag(_PLACEHOLDER_TAG$2, {
        id: ph.name,
        'equiv-text': equivText
      })];
    }
  }, {
    key: "serialize",
    value: function serialize(nodes) {
      var _ref18,
          _this164 = this;

      return (_ref18 = []).concat.apply(_ref18, (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(nodes.map(function (node) {
        return node.visit(_this164);
      })));
    }
  }]);

  return _WriteVisitor$1;
}(); // TODO(vicb): add error management (structure)
// Extract messages as xml nodes from the xliff file


var XliffParser = /*#__PURE__*/function () {
  function XliffParser() {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, XliffParser);

    this._locale = null;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(XliffParser, [{
    key: "parse",
    value: function parse(xliff, url) {
      this._unitMlString = null;
      this._msgIdToHtml = {};
      var xml = new XmlParser().parse(xliff, url);
      this._errors = xml.errors;
      visitAll(this, xml.rootNodes, null);
      return {
        msgIdToHtml: this._msgIdToHtml,
        errors: this._errors,
        locale: this._locale
      };
    }
  }, {
    key: "visitElement",
    value: function visitElement(element, context) {
      switch (element.name) {
        case _UNIT_TAG$1:
          this._unitMlString = null;
          var idAttr = element.attrs.find(function (attr) {
            return attr.name === 'id';
          });

          if (!idAttr) {
            this._addError(element, "<".concat(_UNIT_TAG$1, "> misses the \"id\" attribute"));
          } else {
            var id = idAttr.value;

            if (this._msgIdToHtml.hasOwnProperty(id)) {
              this._addError(element, "Duplicated translations for msg ".concat(id));
            } else {
              visitAll(this, element.children, null);

              if (typeof this._unitMlString === 'string') {
                this._msgIdToHtml[id] = this._unitMlString;
              } else {
                this._addError(element, "Message ".concat(id, " misses a translation"));
              }
            }
          }

          break;
        // ignore those tags

        case _SOURCE_TAG$1:
        case _SEGMENT_SOURCE_TAG:
        case _ALT_TRANS_TAG:
          break;

        case _TARGET_TAG$1:
          var innerTextStart = element.startSourceSpan.end.offset;
          var innerTextEnd = element.endSourceSpan.start.offset;
          var content = element.startSourceSpan.start.file.content;
          var innerText = content.slice(innerTextStart, innerTextEnd);
          this._unitMlString = innerText;
          break;

        case _FILE_TAG:
          var localeAttr = element.attrs.find(function (attr) {
            return attr.name === 'target-language';
          });

          if (localeAttr) {
            this._locale = localeAttr.value;
          }

          visitAll(this, element.children, null);
          break;

        default:
          // TODO(vicb): assert file structure, xliff version
          // For now only recurse on unhandled nodes
          visitAll(this, element.children, null);
      }
    }
  }, {
    key: "visitAttribute",
    value: function visitAttribute(attribute, context) {}
  }, {
    key: "visitText",
    value: function visitText(text, context) {}
  }, {
    key: "visitComment",
    value: function visitComment(comment, context) {}
  }, {
    key: "visitExpansion",
    value: function visitExpansion(expansion, context) {}
  }, {
    key: "visitExpansionCase",
    value: function visitExpansionCase(expansionCase, context) {}
  }, {
    key: "_addError",
    value: function _addError(node, message) {
      this._errors.push(new I18nError(node.sourceSpan, message));
    }
  }]);

  return XliffParser;
}(); // Convert ml nodes (xliff syntax) to i18n nodes


var XmlToI18n$2 = /*#__PURE__*/function () {
  function XmlToI18n$2() {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, XmlToI18n$2);
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(XmlToI18n$2, [{
    key: "convert",
    value: function convert(message, url) {
      var _ref19;

      var xmlIcu = new XmlParser().parse(message, url, {
        tokenizeExpansionForms: true
      });
      this._errors = xmlIcu.errors;
      var i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ? [] : (_ref19 = []).concat.apply(_ref19, (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(visitAll(this, xmlIcu.rootNodes)));
      return {
        i18nNodes: i18nNodes,
        errors: this._errors
      };
    }
  }, {
    key: "visitText",
    value: function visitText(text, context) {
      return new Text$2(text.value, text.sourceSpan);
    }
  }, {
    key: "visitElement",
    value: function visitElement(el, context) {
      if (el.name === _PLACEHOLDER_TAG$2) {
        var nameAttr = el.attrs.find(function (attr) {
          return attr.name === 'id';
        });

        if (nameAttr) {
          return new Placeholder('', nameAttr.value, el.sourceSpan);
        }

        this._addError(el, "<".concat(_PLACEHOLDER_TAG$2, "> misses the \"id\" attribute"));

        return null;
      }

      if (el.name === _MARKER_TAG$1) {
        var _ref20;

        return (_ref20 = []).concat.apply(_ref20, (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(visitAll(this, el.children)));
      }

      this._addError(el, "Unexpected tag");

      return null;
    }
  }, {
    key: "visitExpansion",
    value: function visitExpansion(icu, context) {
      var caseMap = {};
      visitAll(this, icu.cases).forEach(function (c) {
        caseMap[c.value] = new Container(c.nodes, icu.sourceSpan);
      });
      return new Icu(icu.switchValue, icu.type, caseMap, icu.sourceSpan);
    }
  }, {
    key: "visitExpansionCase",
    value: function visitExpansionCase(icuCase, context) {
      return {
        value: icuCase.value,
        nodes: visitAll(this, icuCase.expression)
      };
    }
  }, {
    key: "visitComment",
    value: function visitComment(comment, context) {}
  }, {
    key: "visitAttribute",
    value: function visitAttribute(attribute, context) {}
  }, {
    key: "_addError",
    value: function _addError(node, message) {
      this._errors.push(new I18nError(node.sourceSpan, message));
    }
  }]);

  return XmlToI18n$2;
}();

function getCtypeForTag(tag) {
  switch (tag.toLowerCase()) {
    case 'br':
      return 'lb';

    case 'img':
      return 'image';

    default:
      return "x-".concat(tag);
  }
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */


var _VERSION = '2.0';
var _XMLNS = 'urn:oasis:names:tc:xliff:document:2.0'; // TODO(vicb): make this a param (s/_/-/)

var _DEFAULT_SOURCE_LANG = 'en';
var _PLACEHOLDER_TAG$1 = 'ph';
var _PLACEHOLDER_SPANNING_TAG = 'pc';
var _MARKER_TAG = 'mrk';
var _XLIFF_TAG = 'xliff';
var _SOURCE_TAG = 'source';
var _TARGET_TAG = 'target';
var _UNIT_TAG = 'unit'; // https://docs.oasis-open.org/xliff/xliff-core/v2.0/os/xliff-core-v2.0-os.html

var Xliff2 = /*#__PURE__*/function (_Serializer3) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(Xliff2, _Serializer3);

  var _super82 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(Xliff2);

  function Xliff2() {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, Xliff2);

    return _super82.apply(this, arguments);
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(Xliff2, [{
    key: "write",
    value: function write(messages, locale) {
      var visitor = new _WriteVisitor();
      var units = [];
      messages.forEach(function (message) {
        var unit = new Tag(_UNIT_TAG, {
          id: message.id
        });
        var notes = new Tag('notes');

        if (message.description || message.meaning) {
          if (message.description) {
            notes.children.push(new CR(8), new Tag('note', {
              category: 'description'
            }, [new Text$1(message.description)]));
          }

          if (message.meaning) {
            notes.children.push(new CR(8), new Tag('note', {
              category: 'meaning'
            }, [new Text$1(message.meaning)]));
          }
        }

        message.sources.forEach(function (source) {
          notes.children.push(new CR(8), new Tag('note', {
            category: 'location'
          }, [new Text$1("".concat(source.filePath, ":").concat(source.startLine).concat(source.endLine !== source.startLine ? ',' + source.endLine : ''))]));
        });
        notes.children.push(new CR(6));
        unit.children.push(new CR(6), notes);
        var segment = new Tag('segment');
        segment.children.push(new CR(8), new Tag(_SOURCE_TAG, {}, visitor.serialize(message.nodes)), new CR(6));
        unit.children.push(new CR(6), segment, new CR(4));
        units.push(new CR(4), unit);
      });
      var file = new Tag('file', {
        'original': 'ng.template',
        id: 'ngi18n'
      }, [].concat(units, [new CR(2)]));
      var xliff = new Tag(_XLIFF_TAG, {
        version: _VERSION,
        xmlns: _XMLNS,
        srcLang: locale || _DEFAULT_SOURCE_LANG
      }, [new CR(2), file, new CR()]);
      return serialize([new Declaration({
        version: '1.0',
        encoding: 'UTF-8'
      }), new CR(), xliff, new CR()]);
    }
  }, {
    key: "load",
    value: function load(content, url) {
      // xliff to xml nodes
      var xliff2Parser = new Xliff2Parser();

      var _xliff2Parser$parse = xliff2Parser.parse(content, url),
          locale = _xliff2Parser$parse.locale,
          msgIdToHtml = _xliff2Parser$parse.msgIdToHtml,
          errors = _xliff2Parser$parse.errors; // xml nodes to i18n nodes


      var i18nNodesByMsgId = {};
      var converter = new XmlToI18n$1();
      Object.keys(msgIdToHtml).forEach(function (msgId) {
        var _converter$convert2 = converter.convert(msgIdToHtml[msgId], url),
            i18nNodes = _converter$convert2.i18nNodes,
            e = _converter$convert2.errors;

        errors.push.apply(errors, (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(e));
        i18nNodesByMsgId[msgId] = i18nNodes;
      });

      if (errors.length) {
        throw new Error("xliff2 parse errors:\n".concat(errors.join('\n')));
      }

      return {
        locale: locale,
        i18nNodesByMsgId: i18nNodesByMsgId
      };
    }
  }, {
    key: "digest",
    value: function digest(message) {
      return decimalDigest(message);
    }
  }]);

  return Xliff2;
}(Serializer);

var _WriteVisitor = /*#__PURE__*/function () {
  function _WriteVisitor() {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, _WriteVisitor);
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(_WriteVisitor, [{
    key: "visitText",
    value: function visitText(text, context) {
      return [new Text$1(text.value)];
    }
  }, {
    key: "visitContainer",
    value: function visitContainer(container, context) {
      var _this165 = this;

      var nodes = [];
      container.children.forEach(function (node) {
        return nodes.push.apply(nodes, (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(node.visit(_this165)));
      });
      return nodes;
    }
  }, {
    key: "visitIcu",
    value: function visitIcu(icu, context) {
      var _this166 = this;

      var nodes = [new Text$1("{".concat(icu.expressionPlaceholder, ", ").concat(icu.type, ", "))];
      Object.keys(icu.cases).forEach(function (c) {
        nodes.push.apply(nodes, [new Text$1("".concat(c, " {"))].concat((0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(icu.cases[c].visit(_this166)), [new Text$1("} ")]));
      });
      nodes.push(new Text$1("}"));
      return nodes;
    }
  }, {
    key: "visitTagPlaceholder",
    value: function visitTagPlaceholder(ph, context) {
      var _ref21,
          _this167 = this;

      var type = getTypeForTag(ph.tag);

      if (ph.isVoid) {
        var tagPh = new Tag(_PLACEHOLDER_TAG$1, {
          id: (this._nextPlaceholderId++).toString(),
          equiv: ph.startName,
          type: type,
          disp: "<".concat(ph.tag, "/>")
        });
        return [tagPh];
      }

      var tagPc = new Tag(_PLACEHOLDER_SPANNING_TAG, {
        id: (this._nextPlaceholderId++).toString(),
        equivStart: ph.startName,
        equivEnd: ph.closeName,
        type: type,
        dispStart: "<".concat(ph.tag, ">"),
        dispEnd: "</".concat(ph.tag, ">")
      });

      var nodes = (_ref21 = []).concat.apply(_ref21, (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(ph.children.map(function (node) {
        return node.visit(_this167);
      })));

      if (nodes.length) {
        nodes.forEach(function (node) {
          return tagPc.children.push(node);
        });
      } else {
        tagPc.children.push(new Text$1(''));
      }

      return [tagPc];
    }
  }, {
    key: "visitPlaceholder",
    value: function visitPlaceholder(ph, context) {
      var idStr = (this._nextPlaceholderId++).toString();
      return [new Tag(_PLACEHOLDER_TAG$1, {
        id: idStr,
        equiv: ph.name,
        disp: "{{".concat(ph.value, "}}")
      })];
    }
  }, {
    key: "visitIcuPlaceholder",
    value: function visitIcuPlaceholder(ph, context) {
      var cases = Object.keys(ph.value.cases).map(function (value) {
        return value + ' {...}';
      }).join(' ');
      var idStr = (this._nextPlaceholderId++).toString();
      return [new Tag(_PLACEHOLDER_TAG$1, {
        id: idStr,
        equiv: ph.name,
        disp: "{".concat(ph.value.expression, ", ").concat(ph.value.type, ", ").concat(cases, "}")
      })];
    }
  }, {
    key: "serialize",
    value: function serialize(nodes) {
      var _ref22,
          _this168 = this;

      this._nextPlaceholderId = 0;
      return (_ref22 = []).concat.apply(_ref22, (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(nodes.map(function (node) {
        return node.visit(_this168);
      })));
    }
  }]);

  return _WriteVisitor;
}(); // Extract messages as xml nodes from the xliff file


var Xliff2Parser = /*#__PURE__*/function () {
  function Xliff2Parser() {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, Xliff2Parser);

    this._locale = null;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(Xliff2Parser, [{
    key: "parse",
    value: function parse(xliff, url) {
      this._unitMlString = null;
      this._msgIdToHtml = {};
      var xml = new XmlParser().parse(xliff, url);
      this._errors = xml.errors;
      visitAll(this, xml.rootNodes, null);
      return {
        msgIdToHtml: this._msgIdToHtml,
        errors: this._errors,
        locale: this._locale
      };
    }
  }, {
    key: "visitElement",
    value: function visitElement(element, context) {
      switch (element.name) {
        case _UNIT_TAG:
          this._unitMlString = null;
          var idAttr = element.attrs.find(function (attr) {
            return attr.name === 'id';
          });

          if (!idAttr) {
            this._addError(element, "<".concat(_UNIT_TAG, "> misses the \"id\" attribute"));
          } else {
            var id = idAttr.value;

            if (this._msgIdToHtml.hasOwnProperty(id)) {
              this._addError(element, "Duplicated translations for msg ".concat(id));
            } else {
              visitAll(this, element.children, null);

              if (typeof this._unitMlString === 'string') {
                this._msgIdToHtml[id] = this._unitMlString;
              } else {
                this._addError(element, "Message ".concat(id, " misses a translation"));
              }
            }
          }

          break;

        case _SOURCE_TAG:
          // ignore source message
          break;

        case _TARGET_TAG:
          var innerTextStart = element.startSourceSpan.end.offset;
          var innerTextEnd = element.endSourceSpan.start.offset;
          var content = element.startSourceSpan.start.file.content;
          var innerText = content.slice(innerTextStart, innerTextEnd);
          this._unitMlString = innerText;
          break;

        case _XLIFF_TAG:
          var localeAttr = element.attrs.find(function (attr) {
            return attr.name === 'trgLang';
          });

          if (localeAttr) {
            this._locale = localeAttr.value;
          }

          var versionAttr = element.attrs.find(function (attr) {
            return attr.name === 'version';
          });

          if (versionAttr) {
            var version = versionAttr.value;

            if (version !== '2.0') {
              this._addError(element, "The XLIFF file version ".concat(version, " is not compatible with XLIFF 2.0 serializer"));
            } else {
              visitAll(this, element.children, null);
            }
          }

          break;

        default:
          visitAll(this, element.children, null);
      }
    }
  }, {
    key: "visitAttribute",
    value: function visitAttribute(attribute, context) {}
  }, {
    key: "visitText",
    value: function visitText(text, context) {}
  }, {
    key: "visitComment",
    value: function visitComment(comment, context) {}
  }, {
    key: "visitExpansion",
    value: function visitExpansion(expansion, context) {}
  }, {
    key: "visitExpansionCase",
    value: function visitExpansionCase(expansionCase, context) {}
  }, {
    key: "_addError",
    value: function _addError(node, message) {
      this._errors.push(new I18nError(node.sourceSpan, message));
    }
  }]);

  return Xliff2Parser;
}(); // Convert ml nodes (xliff syntax) to i18n nodes


var XmlToI18n$1 = /*#__PURE__*/function () {
  function XmlToI18n$1() {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, XmlToI18n$1);
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(XmlToI18n$1, [{
    key: "convert",
    value: function convert(message, url) {
      var _ref23;

      var xmlIcu = new XmlParser().parse(message, url, {
        tokenizeExpansionForms: true
      });
      this._errors = xmlIcu.errors;
      var i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ? [] : (_ref23 = []).concat.apply(_ref23, (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(visitAll(this, xmlIcu.rootNodes)));
      return {
        i18nNodes: i18nNodes,
        errors: this._errors
      };
    }
  }, {
    key: "visitText",
    value: function visitText(text, context) {
      return new Text$2(text.value, text.sourceSpan);
    }
  }, {
    key: "visitElement",
    value: function visitElement(el, context) {
      var _this169 = this,
          _ref24;

      switch (el.name) {
        case _PLACEHOLDER_TAG$1:
          var nameAttr = el.attrs.find(function (attr) {
            return attr.name === 'equiv';
          });

          if (nameAttr) {
            return [new Placeholder('', nameAttr.value, el.sourceSpan)];
          }

          this._addError(el, "<".concat(_PLACEHOLDER_TAG$1, "> misses the \"equiv\" attribute"));

          break;

        case _PLACEHOLDER_SPANNING_TAG:
          var startAttr = el.attrs.find(function (attr) {
            return attr.name === 'equivStart';
          });
          var endAttr = el.attrs.find(function (attr) {
            return attr.name === 'equivEnd';
          });

          if (!startAttr) {
            this._addError(el, "<".concat(_PLACEHOLDER_TAG$1, "> misses the \"equivStart\" attribute"));
          } else if (!endAttr) {
            this._addError(el, "<".concat(_PLACEHOLDER_TAG$1, "> misses the \"equivEnd\" attribute"));
          } else {
            var startId = startAttr.value;
            var endId = endAttr.value;
            var nodes = [];
            return nodes.concat.apply(nodes, [new Placeholder('', startId, el.sourceSpan)].concat((0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(el.children.map(function (node) {
              return node.visit(_this169, null);
            })), [new Placeholder('', endId, el.sourceSpan)]));
          }

          break;

        case _MARKER_TAG:
          return (_ref24 = []).concat.apply(_ref24, (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(visitAll(this, el.children)));

        default:
          this._addError(el, "Unexpected tag");

      }

      return null;
    }
  }, {
    key: "visitExpansion",
    value: function visitExpansion(icu, context) {
      var caseMap = {};
      visitAll(this, icu.cases).forEach(function (c) {
        caseMap[c.value] = new Container(c.nodes, icu.sourceSpan);
      });
      return new Icu(icu.switchValue, icu.type, caseMap, icu.sourceSpan);
    }
  }, {
    key: "visitExpansionCase",
    value: function visitExpansionCase(icuCase, context) {
      var _ref25;

      return {
        value: icuCase.value,
        nodes: (_ref25 = []).concat.apply(_ref25, (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(visitAll(this, icuCase.expression)))
      };
    }
  }, {
    key: "visitComment",
    value: function visitComment(comment, context) {}
  }, {
    key: "visitAttribute",
    value: function visitAttribute(attribute, context) {}
  }, {
    key: "_addError",
    value: function _addError(node, message) {
      this._errors.push(new I18nError(node.sourceSpan, message));
    }
  }]);

  return XmlToI18n$1;
}();

function getTypeForTag(tag) {
  switch (tag.toLowerCase()) {
    case 'br':
    case 'b':
    case 'i':
    case 'u':
      return 'fmt';

    case 'img':
      return 'image';

    case 'a':
      return 'link';

    default:
      return 'other';
  }
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */


var _TRANSLATIONS_TAG = 'translationbundle';
var _TRANSLATION_TAG = 'translation';
var _PLACEHOLDER_TAG = 'ph';

var Xtb = /*#__PURE__*/function (_Serializer4) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(Xtb, _Serializer4);

  var _super83 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(Xtb);

  function Xtb() {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, Xtb);

    return _super83.apply(this, arguments);
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(Xtb, [{
    key: "write",
    value: function write(messages, locale) {
      throw new Error('Unsupported');
    }
  }, {
    key: "load",
    value: function load(content, url) {
      // xtb to xml nodes
      var xtbParser = new XtbParser();

      var _xtbParser$parse = xtbParser.parse(content, url),
          locale = _xtbParser$parse.locale,
          msgIdToHtml = _xtbParser$parse.msgIdToHtml,
          errors = _xtbParser$parse.errors; // xml nodes to i18n nodes


      var i18nNodesByMsgId = {};
      var converter = new XmlToI18n(); // Because we should be able to load xtb files that rely on features not supported by angular,
      // we need to delay the conversion of html to i18n nodes so that non angular messages are not
      // converted

      Object.keys(msgIdToHtml).forEach(function (msgId) {
        var valueFn = function valueFn() {
          var _converter$convert3 = converter.convert(msgIdToHtml[msgId], url),
              i18nNodes = _converter$convert3.i18nNodes,
              errors = _converter$convert3.errors;

          if (errors.length) {
            throw new Error("xtb parse errors:\n".concat(errors.join('\n')));
          }

          return i18nNodes;
        };

        createLazyProperty(i18nNodesByMsgId, msgId, valueFn);
      });

      if (errors.length) {
        throw new Error("xtb parse errors:\n".concat(errors.join('\n')));
      }

      return {
        locale: locale,
        i18nNodesByMsgId: i18nNodesByMsgId
      };
    }
  }, {
    key: "digest",
    value: function digest(message) {
      return _digest2(message);
    }
  }, {
    key: "createNameMapper",
    value: function createNameMapper(message) {
      return new SimplePlaceholderMapper(message, toPublicName);
    }
  }]);

  return Xtb;
}(Serializer);

function createLazyProperty(messages, id, valueFn) {
  Object.defineProperty(messages, id, {
    configurable: true,
    enumerable: true,
    get: function get() {
      var value = valueFn();
      Object.defineProperty(messages, id, {
        enumerable: true,
        value: value
      });
      return value;
    },
    set: function set(_) {
      throw new Error('Could not overwrite an XTB translation');
    }
  });
} // Extract messages as xml nodes from the xtb file


var XtbParser = /*#__PURE__*/function () {
  function XtbParser() {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, XtbParser);

    this._locale = null;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(XtbParser, [{
    key: "parse",
    value: function parse(xtb, url) {
      this._bundleDepth = 0;
      this._msgIdToHtml = {}; // We can not parse the ICU messages at this point as some messages might not originate
      // from Angular that could not be lex'd.

      var xml = new XmlParser().parse(xtb, url);
      this._errors = xml.errors;
      visitAll(this, xml.rootNodes);
      return {
        msgIdToHtml: this._msgIdToHtml,
        errors: this._errors,
        locale: this._locale
      };
    }
  }, {
    key: "visitElement",
    value: function visitElement(element, context) {
      switch (element.name) {
        case _TRANSLATIONS_TAG:
          this._bundleDepth++;

          if (this._bundleDepth > 1) {
            this._addError(element, "<".concat(_TRANSLATIONS_TAG, "> elements can not be nested"));
          }

          var langAttr = element.attrs.find(function (attr) {
            return attr.name === 'lang';
          });

          if (langAttr) {
            this._locale = langAttr.value;
          }

          visitAll(this, element.children, null);
          this._bundleDepth--;
          break;

        case _TRANSLATION_TAG:
          var idAttr = element.attrs.find(function (attr) {
            return attr.name === 'id';
          });

          if (!idAttr) {
            this._addError(element, "<".concat(_TRANSLATION_TAG, "> misses the \"id\" attribute"));
          } else {
            var id = idAttr.value;

            if (this._msgIdToHtml.hasOwnProperty(id)) {
              this._addError(element, "Duplicated translations for msg ".concat(id));
            } else {
              var innerTextStart = element.startSourceSpan.end.offset;
              var innerTextEnd = element.endSourceSpan.start.offset;
              var content = element.startSourceSpan.start.file.content;
              var innerText = content.slice(innerTextStart, innerTextEnd);
              this._msgIdToHtml[id] = innerText;
            }
          }

          break;

        default:
          this._addError(element, 'Unexpected tag');

      }
    }
  }, {
    key: "visitAttribute",
    value: function visitAttribute(attribute, context) {}
  }, {
    key: "visitText",
    value: function visitText(text, context) {}
  }, {
    key: "visitComment",
    value: function visitComment(comment, context) {}
  }, {
    key: "visitExpansion",
    value: function visitExpansion(expansion, context) {}
  }, {
    key: "visitExpansionCase",
    value: function visitExpansionCase(expansionCase, context) {}
  }, {
    key: "_addError",
    value: function _addError(node, message) {
      this._errors.push(new I18nError(node.sourceSpan, message));
    }
  }]);

  return XtbParser;
}(); // Convert ml nodes (xtb syntax) to i18n nodes


var XmlToI18n = /*#__PURE__*/function () {
  function XmlToI18n() {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, XmlToI18n);
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(XmlToI18n, [{
    key: "convert",
    value: function convert(message, url) {
      var xmlIcu = new XmlParser().parse(message, url, {
        tokenizeExpansionForms: true
      });
      this._errors = xmlIcu.errors;
      var i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ? [] : visitAll(this, xmlIcu.rootNodes);
      return {
        i18nNodes: i18nNodes,
        errors: this._errors
      };
    }
  }, {
    key: "visitText",
    value: function visitText(text, context) {
      return new Text$2(text.value, text.sourceSpan);
    }
  }, {
    key: "visitExpansion",
    value: function visitExpansion(icu, context) {
      var caseMap = {};
      visitAll(this, icu.cases).forEach(function (c) {
        caseMap[c.value] = new Container(c.nodes, icu.sourceSpan);
      });
      return new Icu(icu.switchValue, icu.type, caseMap, icu.sourceSpan);
    }
  }, {
    key: "visitExpansionCase",
    value: function visitExpansionCase(icuCase, context) {
      return {
        value: icuCase.value,
        nodes: visitAll(this, icuCase.expression)
      };
    }
  }, {
    key: "visitElement",
    value: function visitElement(el, context) {
      if (el.name === _PLACEHOLDER_TAG) {
        var nameAttr = el.attrs.find(function (attr) {
          return attr.name === 'name';
        });

        if (nameAttr) {
          return new Placeholder('', nameAttr.value, el.sourceSpan);
        }

        this._addError(el, "<".concat(_PLACEHOLDER_TAG, "> misses the \"name\" attribute"));
      } else {
        this._addError(el, "Unexpected tag");
      }

      return null;
    }
  }, {
    key: "visitComment",
    value: function visitComment(comment, context) {}
  }, {
    key: "visitAttribute",
    value: function visitAttribute(attribute, context) {}
  }, {
    key: "_addError",
    value: function _addError(node, message) {
      this._errors.push(new I18nError(node.sourceSpan, message));
    }
  }]);

  return XmlToI18n;
}();
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * A container for translated messages
 */


var TranslationBundle = /*#__PURE__*/function () {
  function TranslationBundle() {
    var _i18nNodesByMsgId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    var locale = arguments.length > 1 ? arguments[1] : undefined;
    var digest = arguments.length > 2 ? arguments[2] : undefined;
    var mapperFactory = arguments.length > 3 ? arguments[3] : undefined;
    var missingTranslationStrategy = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : MissingTranslationStrategy.Warning;
    var console = arguments.length > 5 ? arguments[5] : undefined;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, TranslationBundle);

    this._i18nNodesByMsgId = _i18nNodesByMsgId;
    this.digest = digest;
    this.mapperFactory = mapperFactory;
    this._i18nToHtml = new I18nToHtmlVisitor(_i18nNodesByMsgId, locale, digest, mapperFactory, missingTranslationStrategy, console);
  } // Creates a `TranslationBundle` by parsing the given `content` with the `serializer`.


  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(TranslationBundle, [{
    key: "get",
    value: // Returns the translation as HTML nodes from the given source message.
    function get(srcMsg) {
      var html = this._i18nToHtml.convert(srcMsg);

      if (html.errors.length) {
        throw new Error(html.errors.join('\n'));
      }

      return html.nodes;
    }
  }, {
    key: "has",
    value: function has(srcMsg) {
      return this.digest(srcMsg) in this._i18nNodesByMsgId;
    }
  }], [{
    key: "load",
    value: function load(content, url, serializer, missingTranslationStrategy, console) {
      var _serializer$load = serializer.load(content, url),
          locale = _serializer$load.locale,
          i18nNodesByMsgId = _serializer$load.i18nNodesByMsgId;

      var digestFn = function digestFn(m) {
        return serializer.digest(m);
      };

      var mapperFactory = function mapperFactory(m) {
        return serializer.createNameMapper(m);
      };

      return new TranslationBundle(i18nNodesByMsgId, locale, digestFn, mapperFactory, missingTranslationStrategy, console);
    }
  }]);

  return TranslationBundle;
}();

var I18nToHtmlVisitor = /*#__PURE__*/function () {
  function I18nToHtmlVisitor() {
    var _i18nNodesByMsgId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    var _locale = arguments.length > 1 ? arguments[1] : undefined;

    var _digest = arguments.length > 2 ? arguments[2] : undefined;

    var _mapperFactory = arguments.length > 3 ? arguments[3] : undefined;

    var _missingTranslationStrategy = arguments.length > 4 ? arguments[4] : undefined;

    var _console = arguments.length > 5 ? arguments[5] : undefined;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, I18nToHtmlVisitor);

    this._i18nNodesByMsgId = _i18nNodesByMsgId;
    this._locale = _locale;
    this._digest = _digest;
    this._mapperFactory = _mapperFactory;
    this._missingTranslationStrategy = _missingTranslationStrategy;
    this._console = _console;
    this._contextStack = [];
    this._errors = [];
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(I18nToHtmlVisitor, [{
    key: "convert",
    value: function convert(srcMsg) {
      this._contextStack.length = 0;
      this._errors.length = 0; // i18n to text

      var text = this._convertToText(srcMsg); // text to html


      var url = srcMsg.nodes[0].sourceSpan.start.file.url;
      var html = new HtmlParser().parse(text, url, {
        tokenizeExpansionForms: true
      });
      return {
        nodes: html.rootNodes,
        errors: [].concat((0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(this._errors), (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(html.errors))
      };
    }
  }, {
    key: "visitText",
    value: function visitText(text, context) {
      // `convert()` uses an `HtmlParser` to return `html.Node`s
      // we should then make sure that any special characters are escaped
      return escapeXml(text.value);
    }
  }, {
    key: "visitContainer",
    value: function visitContainer(container, context) {
      var _this170 = this;

      return container.children.map(function (n) {
        return n.visit(_this170);
      }).join('');
    }
  }, {
    key: "visitIcu",
    value: function visitIcu(icu, context) {
      var _this171 = this;

      var cases = Object.keys(icu.cases).map(function (k) {
        return "".concat(k, " {").concat(icu.cases[k].visit(_this171), "}");
      }); // TODO(vicb): Once all format switch to using expression placeholders
      // we should throw when the placeholder is not in the source message

      var exp = this._srcMsg.placeholders.hasOwnProperty(icu.expression) ? this._srcMsg.placeholders[icu.expression].text : icu.expression;
      return "{".concat(exp, ", ").concat(icu.type, ", ").concat(cases.join(' '), "}");
    }
  }, {
    key: "visitPlaceholder",
    value: function visitPlaceholder(ph, context) {
      var phName = this._mapper(ph.name);

      if (this._srcMsg.placeholders.hasOwnProperty(phName)) {
        return this._srcMsg.placeholders[phName].text;
      }

      if (this._srcMsg.placeholderToMessage.hasOwnProperty(phName)) {
        return this._convertToText(this._srcMsg.placeholderToMessage[phName]);
      }

      this._addError(ph, "Unknown placeholder \"".concat(ph.name, "\""));

      return '';
    } // Loaded message contains only placeholders (vs tag and icu placeholders).
    // However when a translation can not be found, we need to serialize the source message
    // which can contain tag placeholders

  }, {
    key: "visitTagPlaceholder",
    value: function visitTagPlaceholder(ph, context) {
      var _this172 = this;

      var tag = "".concat(ph.tag);
      var attrs = Object.keys(ph.attrs).map(function (name) {
        return "".concat(name, "=\"").concat(ph.attrs[name], "\"");
      }).join(' ');

      if (ph.isVoid) {
        return "<".concat(tag, " ").concat(attrs, "/>");
      }

      var children = ph.children.map(function (c) {
        return c.visit(_this172);
      }).join('');
      return "<".concat(tag, " ").concat(attrs, ">").concat(children, "</").concat(tag, ">");
    } // Loaded message contains only placeholders (vs tag and icu placeholders).
    // However when a translation can not be found, we need to serialize the source message
    // which can contain tag placeholders

  }, {
    key: "visitIcuPlaceholder",
    value: function visitIcuPlaceholder(ph, context) {
      // An ICU placeholder references the source message to be serialized
      return this._convertToText(this._srcMsg.placeholderToMessage[ph.name]);
    }
    /**
     * Convert a source message to a translated text string:
     * - text nodes are replaced with their translation,
     * - placeholders are replaced with their content,
     * - ICU nodes are converted to ICU expressions.
     */

  }, {
    key: "_convertToText",
    value: function _convertToText(srcMsg) {
      var _this173 = this;

      var id = this._digest(srcMsg);

      var mapper = this._mapperFactory ? this._mapperFactory(srcMsg) : null;
      var nodes;

      this._contextStack.push({
        msg: this._srcMsg,
        mapper: this._mapper
      });

      this._srcMsg = srcMsg;

      if (this._i18nNodesByMsgId.hasOwnProperty(id)) {
        // When there is a translation use its nodes as the source
        // And create a mapper to convert serialized placeholder names to internal names
        nodes = this._i18nNodesByMsgId[id];

        this._mapper = function (name) {
          return mapper ? mapper.toInternalName(name) : name;
        };
      } else {
        // When no translation has been found
        // - report an error / a warning / nothing,
        // - use the nodes from the original message
        // - placeholders are already internal and need no mapper
        if (this._missingTranslationStrategy === MissingTranslationStrategy.Error) {
          var ctx = this._locale ? " for locale \"".concat(this._locale, "\"") : '';

          this._addError(srcMsg.nodes[0], "Missing translation for message \"".concat(id, "\"").concat(ctx));
        } else if (this._console && this._missingTranslationStrategy === MissingTranslationStrategy.Warning) {
          var _ctx = this._locale ? " for locale \"".concat(this._locale, "\"") : '';

          this._console.warn("Missing translation for message \"".concat(id, "\"").concat(_ctx));
        }

        nodes = srcMsg.nodes;

        this._mapper = function (name) {
          return name;
        };
      }

      var text = nodes.map(function (node) {
        return node.visit(_this173);
      }).join('');

      var context = this._contextStack.pop();

      this._srcMsg = context.msg;
      this._mapper = context.mapper;
      return text;
    }
  }, {
    key: "_addError",
    value: function _addError(el, msg) {
      this._errors.push(new I18nError(el.sourceSpan, msg));
    }
  }]);

  return I18nToHtmlVisitor;
}();
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */


var I18NHtmlParser = /*#__PURE__*/function () {
  function I18NHtmlParser(_htmlParser, translations, translationsFormat) {
    var missingTranslation = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : MissingTranslationStrategy.Warning;
    var console = arguments.length > 4 ? arguments[4] : undefined;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, I18NHtmlParser);

    this._htmlParser = _htmlParser;

    if (translations) {
      var _serializer = createSerializer(translationsFormat);

      this._translationBundle = TranslationBundle.load(translations, 'i18n', _serializer, missingTranslation, console);
    } else {
      this._translationBundle = new TranslationBundle({}, null, digest$1, undefined, missingTranslation, console);
    }
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(I18NHtmlParser, [{
    key: "parse",
    value: function parse(source, url) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var interpolationConfig = options.interpolationConfig || DEFAULT_INTERPOLATION_CONFIG;

      var parseResult = this._htmlParser.parse(source, url, Object.assign({
        interpolationConfig: interpolationConfig
      }, options));

      if (parseResult.errors.length) {
        return new ParseTreeResult(parseResult.rootNodes, parseResult.errors);
      }

      return mergeTranslations(parseResult.rootNodes, this._translationBundle, interpolationConfig, [], {});
    }
  }]);

  return I18NHtmlParser;
}();

function createSerializer(format) {
  format = (format || 'xlf').toLowerCase();

  switch (format) {
    case 'xmb':
      return new Xmb();

    case 'xtb':
      return new Xtb();

    case 'xliff2':
    case 'xlf2':
      return new Xliff2();

    case 'xliff':
    case 'xlf':
    default:
      return new Xliff();
  }
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * A container for message extracted from the templates.
 */


var MessageBundle = /*#__PURE__*/function () {
  function MessageBundle(_htmlParser, _implicitTags, _implicitAttrs) {
    var _locale = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, MessageBundle);

    this._htmlParser = _htmlParser;
    this._implicitTags = _implicitTags;
    this._implicitAttrs = _implicitAttrs;
    this._locale = _locale;
    this._messages = [];
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(MessageBundle, [{
    key: "updateFromTemplate",
    value: function updateFromTemplate(html, url, interpolationConfig) {
      var _this$_messages;

      var htmlParserResult = this._htmlParser.parse(html, url, {
        tokenizeExpansionForms: true,
        interpolationConfig: interpolationConfig
      });

      if (htmlParserResult.errors.length) {
        return htmlParserResult.errors;
      }

      var i18nParserResult = extractMessages(htmlParserResult.rootNodes, interpolationConfig, this._implicitTags, this._implicitAttrs);

      if (i18nParserResult.errors.length) {
        return i18nParserResult.errors;
      }

      (_this$_messages = this._messages).push.apply(_this$_messages, (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(i18nParserResult.messages));

      return [];
    } // Return the message in the internal format
    // The public (serialized) format might be different, see the `write` method.

  }, {
    key: "getMessages",
    value: function getMessages() {
      return this._messages;
    }
  }, {
    key: "write",
    value: function write(serializer, filterSources) {
      var messages = {};
      var mapperVisitor = new MapPlaceholderNames(); // Deduplicate messages based on their ID

      this._messages.forEach(function (message) {
        var id = serializer.digest(message);

        if (!messages.hasOwnProperty(id)) {
          messages[id] = message;
        } else {
          var _messages$id$sources;

          (_messages$id$sources = messages[id].sources).push.apply(_messages$id$sources, (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(message.sources));
        }
      }); // Transform placeholder names using the serializer mapping


      var msgList = Object.keys(messages).map(function (id) {
        var mapper = serializer.createNameMapper(messages[id]);
        var src = messages[id];
        var nodes = mapper ? mapperVisitor.convert(src.nodes, mapper) : src.nodes;
        var transformedMessage = new Message(nodes, {}, {}, src.meaning, src.description, id);
        transformedMessage.sources = src.sources;

        if (filterSources) {
          transformedMessage.sources.forEach(function (source) {
            return source.filePath = filterSources(source.filePath);
          });
        }

        return transformedMessage;
      });
      return serializer.write(msgList, this._locale);
    }
  }]);

  return MessageBundle;
}(); // Transform an i18n AST by renaming the placeholder nodes with the given mapper


var MapPlaceholderNames = /*#__PURE__*/function (_CloneVisitor) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(MapPlaceholderNames, _CloneVisitor);

  var _super84 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(MapPlaceholderNames);

  function MapPlaceholderNames() {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, MapPlaceholderNames);

    return _super84.apply(this, arguments);
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(MapPlaceholderNames, [{
    key: "convert",
    value: function convert(nodes, mapper) {
      var _this174 = this;

      return mapper ? nodes.map(function (n) {
        return n.visit(_this174, mapper);
      }) : nodes;
    }
  }, {
    key: "visitTagPlaceholder",
    value: function visitTagPlaceholder(ph, mapper) {
      var _this175 = this;

      var startName = mapper.toPublicName(ph.startName);
      var closeName = ph.closeName ? mapper.toPublicName(ph.closeName) : ph.closeName;
      var children = ph.children.map(function (n) {
        return n.visit(_this175, mapper);
      });
      return new TagPlaceholder(ph.tag, ph.attrs, startName, closeName, children, ph.isVoid, ph.sourceSpan, ph.startSourceSpan, ph.endSourceSpan);
    }
  }, {
    key: "visitPlaceholder",
    value: function visitPlaceholder(ph, mapper) {
      return new Placeholder(ph.value, mapper.toPublicName(ph.name), ph.sourceSpan);
    }
  }, {
    key: "visitIcuPlaceholder",
    value: function visitIcuPlaceholder(ph, mapper) {
      return new IcuPlaceholder(ph.value, mapper.toPublicName(ph.name), ph.sourceSpan);
    }
  }]);

  return MapPlaceholderNames;
}(CloneVisitor);
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */


var FactoryTarget;

(function (FactoryTarget) {
  FactoryTarget[FactoryTarget["Directive"] = 0] = "Directive";
  FactoryTarget[FactoryTarget["Component"] = 1] = "Component";
  FactoryTarget[FactoryTarget["Injectable"] = 2] = "Injectable";
  FactoryTarget[FactoryTarget["Pipe"] = 3] = "Pipe";
  FactoryTarget[FactoryTarget["NgModule"] = 4] = "NgModule";
})(FactoryTarget || (FactoryTarget = {}));
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * Processes `Target`s with a given set of directives and performs a binding operation, which
 * returns an object similar to TypeScript's `ts.TypeChecker` that contains knowledge about the
 * target.
 */


var R3TargetBinder = /*#__PURE__*/function () {
  function R3TargetBinder(directiveMatcher) {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, R3TargetBinder);

    this.directiveMatcher = directiveMatcher;
  }
  /**
   * Perform a binding operation on the given `Target` and return a `BoundTarget` which contains
   * metadata about the types referenced in the template.
   */


  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(R3TargetBinder, [{
    key: "bind",
    value: function bind(target) {
      if (!target.template) {
        // TODO(alxhub): handle targets which contain things like HostBindings, etc.
        throw new Error('Binding without a template not yet supported');
      } // First, parse the template into a `Scope` structure. This operation captures the syntactic
      // scopes in the template and makes them available for later use.


      var scope = Scope.apply(target.template); // Use the `Scope` to extract the entities present at every level of the template.

      var templateEntities = extractTemplateEntities(scope); // Next, perform directive matching on the template using the `DirectiveBinder`. This returns:
      //   - directives: Map of nodes (elements & ng-templates) to the directives on them.
      //   - bindings: Map of inputs, outputs, and attributes to the directive/element that claims
      //     them. TODO(alxhub): handle multiple directives claiming an input/output/etc.
      //   - references: Map of #references to their targets.

      var _DirectiveBinder$appl = DirectiveBinder.apply(target.template, this.directiveMatcher),
          directives = _DirectiveBinder$appl.directives,
          bindings = _DirectiveBinder$appl.bindings,
          references = _DirectiveBinder$appl.references; // Finally, run the TemplateBinder to bind references, variables, and other entities within the
      // template. This extracts all the metadata that doesn't depend on directive matching.


      var _TemplateBinder$apply = TemplateBinder.applyWithScope(target.template, scope),
          expressions = _TemplateBinder$apply.expressions,
          symbols = _TemplateBinder$apply.symbols,
          nestingLevel = _TemplateBinder$apply.nestingLevel,
          usedPipes = _TemplateBinder$apply.usedPipes;

      return new R3BoundTarget(target, directives, bindings, references, expressions, symbols, nestingLevel, templateEntities, usedPipes);
    }
  }]);

  return R3TargetBinder;
}();
/**
 * Represents a binding scope within a template.
 *
 * Any variables, references, or other named entities declared within the template will
 * be captured and available by name in `namedEntities`. Additionally, child templates will
 * be analyzed and have their child `Scope`s available in `childScopes`.
 */


var Scope = /*#__PURE__*/function () {
  function Scope(parentScope, template) {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, Scope);

    this.parentScope = parentScope;
    this.template = template;
    /**
     * Named members of the `Scope`, such as `Reference`s or `Variable`s.
     */

    this.namedEntities = new Map();
    /**
     * Child `Scope`s for immediately nested `Template`s.
     */

    this.childScopes = new Map();
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(Scope, [{
    key: "ingest",
    value:
    /**
     * Internal method to process the template and populate the `Scope`.
     */
    function ingest(template) {
      var _this176 = this;

      if (template instanceof Template) {
        // Variables on an <ng-template> are defined in the inner scope.
        template.variables.forEach(function (node) {
          return _this176.visitVariable(node);
        }); // Process the nodes of the template.

        template.children.forEach(function (node) {
          return node.visit(_this176);
        });
      } else {
        // No overarching `Template` instance, so process the nodes directly.
        template.forEach(function (node) {
          return node.visit(_this176);
        });
      }
    }
  }, {
    key: "visitElement",
    value: function visitElement(element) {
      var _this177 = this;

      // `Element`s in the template may have `Reference`s which are captured in the scope.
      element.references.forEach(function (node) {
        return _this177.visitReference(node);
      }); // Recurse into the `Element`'s children.

      element.children.forEach(function (node) {
        return node.visit(_this177);
      });
    }
  }, {
    key: "visitTemplate",
    value: function visitTemplate(template) {
      var _this178 = this;

      // References on a <ng-template> are defined in the outer scope, so capture them before
      // processing the template's child scope.
      template.references.forEach(function (node) {
        return _this178.visitReference(node);
      }); // Next, create an inner scope and process the template within it.

      var scope = new Scope(this, template);
      scope.ingest(template);
      this.childScopes.set(template, scope);
    }
  }, {
    key: "visitVariable",
    value: function visitVariable(variable) {
      // Declare the variable if it's not already.
      this.maybeDeclare(variable);
    }
  }, {
    key: "visitReference",
    value: function visitReference(reference) {
      // Declare the variable if it's not already.
      this.maybeDeclare(reference);
    } // Unused visitors.

  }, {
    key: "visitContent",
    value: function visitContent(content) {}
  }, {
    key: "visitBoundAttribute",
    value: function visitBoundAttribute(attr) {}
  }, {
    key: "visitBoundEvent",
    value: function visitBoundEvent(event) {}
  }, {
    key: "visitBoundText",
    value: function visitBoundText(text) {}
  }, {
    key: "visitText",
    value: function visitText(text) {}
  }, {
    key: "visitTextAttribute",
    value: function visitTextAttribute(attr) {}
  }, {
    key: "visitIcu",
    value: function visitIcu(icu) {}
  }, {
    key: "maybeDeclare",
    value: function maybeDeclare(thing) {
      // Declare something with a name, as long as that name isn't taken.
      if (!this.namedEntities.has(thing.name)) {
        this.namedEntities.set(thing.name, thing);
      }
    }
    /**
     * Look up a variable within this `Scope`.
     *
     * This can recurse into a parent `Scope` if it's available.
     */

  }, {
    key: "lookup",
    value: function lookup(name) {
      if (this.namedEntities.has(name)) {
        // Found in the local scope.
        return this.namedEntities.get(name);
      } else if (this.parentScope !== null) {
        // Not in the local scope, but there's a parent scope so check there.
        return this.parentScope.lookup(name);
      } else {
        // At the top level and it wasn't found.
        return null;
      }
    }
    /**
     * Get the child scope for a `Template`.
     *
     * This should always be defined.
     */

  }, {
    key: "getChildScope",
    value: function getChildScope(template) {
      var res = this.childScopes.get(template);

      if (res === undefined) {
        throw new Error("Assertion error: child scope for ".concat(template, " not found"));
      }

      return res;
    }
  }], [{
    key: "newRootScope",
    value: function newRootScope() {
      return new Scope(null, null);
    }
    /**
     * Process a template (either as a `Template` sub-template with variables, or a plain array of
     * template `Node`s) and construct its `Scope`.
     */

  }, {
    key: "apply",
    value: function apply(template) {
      var scope = Scope.newRootScope();
      scope.ingest(template);
      return scope;
    }
  }]);

  return Scope;
}();
/**
 * Processes a template and matches directives on nodes (elements and templates).
 *
 * Usually used via the static `apply()` method.
 */


var DirectiveBinder = /*#__PURE__*/function () {
  function DirectiveBinder(matcher, directives, bindings, references) {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, DirectiveBinder);

    this.matcher = matcher;
    this.directives = directives;
    this.bindings = bindings;
    this.references = references;
  }
  /**
   * Process a template (list of `Node`s) and perform directive matching against each node.
   *
   * @param template the list of template `Node`s to match (recursively).
   * @param selectorMatcher a `SelectorMatcher` containing the directives that are in scope for
   * this template.
   * @returns three maps which contain information about directives in the template: the
   * `directives` map which lists directives matched on each node, the `bindings` map which
   * indicates which directives claimed which bindings (inputs, outputs, etc), and the `references`
   * map which resolves #references (`Reference`s) within the template to the named directive or
   * template node.
   */


  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(DirectiveBinder, [{
    key: "ingest",
    value: function ingest(template) {
      var _this179 = this;

      template.forEach(function (node) {
        return node.visit(_this179);
      });
    }
  }, {
    key: "visitElement",
    value: function visitElement(element) {
      this.visitElementOrTemplate(element.name, element);
    }
  }, {
    key: "visitTemplate",
    value: function visitTemplate(template) {
      this.visitElementOrTemplate('ng-template', template);
    }
  }, {
    key: "visitElementOrTemplate",
    value: function visitElementOrTemplate(elementName, node) {
      var _this180 = this;

      // First, determine the HTML shape of the node for the purpose of directive matching.
      // Do this by building up a `CssSelector` for the node.
      var cssSelector = createCssSelector(elementName, getAttrsForDirectiveMatching(node)); // Next, use the `SelectorMatcher` to get the list of directives on the node.

      var directives = [];
      this.matcher.match(cssSelector, function (_, directive) {
        return directives.push(directive);
      });

      if (directives.length > 0) {
        this.directives.set(node, directives);
      } // Resolve any references that are created on this node.


      node.references.forEach(function (ref) {
        var dirTarget = null; // If the reference expression is empty, then it matches the "primary" directive on the node
        // (if there is one). Otherwise it matches the host node itself (either an element or
        // <ng-template> node).

        if (ref.value.trim() === '') {
          // This could be a reference to a component if there is one.
          dirTarget = directives.find(function (dir) {
            return dir.isComponent;
          }) || null;
        } else {
          // This should be a reference to a directive exported via exportAs.
          dirTarget = directives.find(function (dir) {
            return dir.exportAs !== null && dir.exportAs.some(function (value) {
              return value === ref.value;
            });
          }) || null; // Check if a matching directive was found.

          if (dirTarget === null) {
            // No matching directive was found - this reference points to an unknown target. Leave it
            // unmapped.
            return;
          }
        }

        if (dirTarget !== null) {
          // This reference points to a directive.
          _this180.references.set(ref, {
            directive: dirTarget,
            node: node
          });
        } else {
          // This reference points to the node itself.
          _this180.references.set(ref, node);
        }
      });

      var setAttributeBinding = function setAttributeBinding(attribute, ioType) {
        var dir = directives.find(function (dir) {
          return dir[ioType].hasBindingPropertyName(attribute.name);
        });
        var binding = dir !== undefined ? dir : node;

        _this180.bindings.set(attribute, binding);
      }; // Node inputs (bound attributes) and text attributes can be bound to an
      // input on a directive.


      node.inputs.forEach(function (input) {
        return setAttributeBinding(input, 'inputs');
      });
      node.attributes.forEach(function (attr) {
        return setAttributeBinding(attr, 'inputs');
      });

      if (node instanceof Template) {
        node.templateAttrs.forEach(function (attr) {
          return setAttributeBinding(attr, 'inputs');
        });
      } // Node outputs (bound events) can be bound to an output on a directive.


      node.outputs.forEach(function (output) {
        return setAttributeBinding(output, 'outputs');
      }); // Recurse into the node's children.

      node.children.forEach(function (child) {
        return child.visit(_this180);
      });
    } // Unused visitors.

  }, {
    key: "visitContent",
    value: function visitContent(content) {}
  }, {
    key: "visitVariable",
    value: function visitVariable(variable) {}
  }, {
    key: "visitReference",
    value: function visitReference(reference) {}
  }, {
    key: "visitTextAttribute",
    value: function visitTextAttribute(attribute) {}
  }, {
    key: "visitBoundAttribute",
    value: function visitBoundAttribute(attribute) {}
  }, {
    key: "visitBoundEvent",
    value: function visitBoundEvent(attribute) {}
  }, {
    key: "visitBoundAttributeOrEvent",
    value: function visitBoundAttributeOrEvent(node) {}
  }, {
    key: "visitText",
    value: function visitText(text) {}
  }, {
    key: "visitBoundText",
    value: function visitBoundText(text) {}
  }, {
    key: "visitIcu",
    value: function visitIcu(icu) {}
  }], [{
    key: "apply",
    value: function apply(template, selectorMatcher) {
      var directives = new Map();
      var bindings = new Map();
      var references = new Map();
      var matcher = new DirectiveBinder(selectorMatcher, directives, bindings, references);
      matcher.ingest(template);
      return {
        directives: directives,
        bindings: bindings,
        references: references
      };
    }
  }]);

  return DirectiveBinder;
}();
/**
 * Processes a template and extract metadata about expressions and symbols within.
 *
 * This is a companion to the `DirectiveBinder` that doesn't require knowledge of directives matched
 * within the template in order to operate.
 *
 * Expressions are visited by the superclass `RecursiveAstVisitor`, with custom logic provided
 * by overridden methods from that visitor.
 */


var TemplateBinder = /*#__PURE__*/function (_RecursiveAstVisitor3) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_7__["default"])(TemplateBinder, _RecursiveAstVisitor3);

  var _super85 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_8__["default"])(TemplateBinder);

  function TemplateBinder(bindings, symbols, usedPipes, nestingLevel, scope, template, level) {
    var _this181;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, TemplateBinder);

    _this181 = _super85.call(this);
    _this181.bindings = bindings;
    _this181.symbols = symbols;
    _this181.usedPipes = usedPipes;
    _this181.nestingLevel = nestingLevel;
    _this181.scope = scope;
    _this181.template = template;
    _this181.level = level;
    _this181.pipesUsed = []; // Save a bit of processing time by constructing this closure in advance.

    _this181.visitNode = function (node) {
      return node.visit((0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_assertThisInitialized_js__WEBPACK_IMPORTED_MODULE_4__["default"])(_this181));
    };

    return _this181;
  } // This method is defined to reconcile the type of TemplateBinder since both
  // RecursiveAstVisitor and Visitor define the visit() method in their
  // interfaces.


  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(TemplateBinder, [{
    key: "visit",
    value: function visit(node, context) {
      if (node instanceof AST) {
        node.visit(this, context);
      } else {
        node.visit(this);
      }
    }
    /**
     * Process a template and extract metadata about expressions and symbols within.
     *
     * @param template the nodes of the template to process
     * @param scope the `Scope` of the template being processed.
     * @returns three maps which contain metadata about the template: `expressions` which interprets
     * special `AST` nodes in expressions as pointing to references or variables declared within the
     * template, `symbols` which maps those variables and references to the nested `Template` which
     * declares them, if any, and `nestingLevel` which associates each `Template` with a integer
     * nesting level (how many levels deep within the template structure the `Template` is), starting
     * at 1.
     */

  }, {
    key: "ingest",
    value: function ingest(template) {
      if (template instanceof Template) {
        // For <ng-template>s, process only variables and child nodes. Inputs, outputs, templateAttrs,
        // and references were all processed in the scope of the containing template.
        template.variables.forEach(this.visitNode);
        template.children.forEach(this.visitNode); // Set the nesting level.

        this.nestingLevel.set(template, this.level);
      } else {
        // Visit each node from the top-level template.
        template.forEach(this.visitNode);
      }
    }
  }, {
    key: "visitElement",
    value: function visitElement(element) {
      // Visit the inputs, outputs, and children of the element.
      element.inputs.forEach(this.visitNode);
      element.outputs.forEach(this.visitNode);
      element.children.forEach(this.visitNode);
    }
  }, {
    key: "visitTemplate",
    value: function visitTemplate(template) {
      // First, visit inputs, outputs and template attributes of the template node.
      template.inputs.forEach(this.visitNode);
      template.outputs.forEach(this.visitNode);
      template.templateAttrs.forEach(this.visitNode); // References are also evaluated in the outer context.

      template.references.forEach(this.visitNode); // Next, recurse into the template using its scope, and bumping the nesting level up by one.

      var childScope = this.scope.getChildScope(template);
      var binder = new TemplateBinder(this.bindings, this.symbols, this.usedPipes, this.nestingLevel, childScope, template, this.level + 1);
      binder.ingest(template);
    }
  }, {
    key: "visitVariable",
    value: function visitVariable(variable) {
      // Register the `Variable` as a symbol in the current `Template`.
      if (this.template !== null) {
        this.symbols.set(variable, this.template);
      }
    }
  }, {
    key: "visitReference",
    value: function visitReference(reference) {
      // Register the `Reference` as a symbol in the current `Template`.
      if (this.template !== null) {
        this.symbols.set(reference, this.template);
      }
    } // Unused template visitors

  }, {
    key: "visitText",
    value: function visitText(text) {}
  }, {
    key: "visitContent",
    value: function visitContent(content) {}
  }, {
    key: "visitTextAttribute",
    value: function visitTextAttribute(attribute) {}
  }, {
    key: "visitIcu",
    value: function visitIcu(icu) {
      var _this182 = this;

      Object.keys(icu.vars).forEach(function (key) {
        return icu.vars[key].visit(_this182);
      });
      Object.keys(icu.placeholders).forEach(function (key) {
        return icu.placeholders[key].visit(_this182);
      });
    } // The remaining visitors are concerned with processing AST expressions within template bindings

  }, {
    key: "visitBoundAttribute",
    value: function visitBoundAttribute(attribute) {
      attribute.value.visit(this);
    }
  }, {
    key: "visitBoundEvent",
    value: function visitBoundEvent(event) {
      event.handler.visit(this);
    }
  }, {
    key: "visitBoundText",
    value: function visitBoundText(text) {
      text.value.visit(this);
    }
  }, {
    key: "visitPipe",
    value: function visitPipe(ast, context) {
      this.usedPipes.add(ast.name);
      return (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_5__["default"])((0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_6__["default"])(TemplateBinder.prototype), "visitPipe", this).call(this, ast, context);
    } // These five types of AST expressions can refer to expression roots, which could be variables
    // or references in the current scope.

  }, {
    key: "visitPropertyRead",
    value: function visitPropertyRead(ast, context) {
      this.maybeMap(context, ast, ast.name);
      return (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_5__["default"])((0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_6__["default"])(TemplateBinder.prototype), "visitPropertyRead", this).call(this, ast, context);
    }
  }, {
    key: "visitSafePropertyRead",
    value: function visitSafePropertyRead(ast, context) {
      this.maybeMap(context, ast, ast.name);
      return (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_5__["default"])((0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_6__["default"])(TemplateBinder.prototype), "visitSafePropertyRead", this).call(this, ast, context);
    }
  }, {
    key: "visitPropertyWrite",
    value: function visitPropertyWrite(ast, context) {
      this.maybeMap(context, ast, ast.name);
      return (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_get_js__WEBPACK_IMPORTED_MODULE_5__["default"])((0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_6__["default"])(TemplateBinder.prototype), "visitPropertyWrite", this).call(this, ast, context);
    }
  }, {
    key: "maybeMap",
    value: function maybeMap(scope, ast, name) {
      // If the receiver of the expression isn't the `ImplicitReceiver`, this isn't the root of an
      // `AST` expression that maps to a `Variable` or `Reference`.
      if (!(ast.receiver instanceof ImplicitReceiver)) {
        return;
      } // Check whether the name exists in the current scope. If so, map it. Otherwise, the name is
      // probably a property on the top-level component context.


      var target = this.scope.lookup(name);

      if (target !== null) {
        this.bindings.set(ast, target);
      }
    }
  }], [{
    key: "applyWithScope",
    value: function applyWithScope(template, scope) {
      var expressions = new Map();
      var symbols = new Map();
      var nestingLevel = new Map();
      var usedPipes = new Set(); // The top-level template has nesting level 0.

      var binder = new TemplateBinder(expressions, symbols, usedPipes, nestingLevel, scope, template instanceof Template ? template : null, 0);
      binder.ingest(template);
      return {
        expressions: expressions,
        symbols: symbols,
        nestingLevel: nestingLevel,
        usedPipes: usedPipes
      };
    }
  }]);

  return TemplateBinder;
}(RecursiveAstVisitor);
/**
 * Metadata container for a `Target` that allows queries for specific bits of metadata.
 *
 * See `BoundTarget` for documentation on the individual methods.
 */


var R3BoundTarget = /*#__PURE__*/function () {
  function R3BoundTarget(target, directives, bindings, references, exprTargets, symbols, nestingLevel, templateEntities, usedPipes) {
    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_11__["default"])(this, R3BoundTarget);

    this.target = target;
    this.directives = directives;
    this.bindings = bindings;
    this.references = references;
    this.exprTargets = exprTargets;
    this.symbols = symbols;
    this.nestingLevel = nestingLevel;
    this.templateEntities = templateEntities;
    this.usedPipes = usedPipes;
  }

  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_12__["default"])(R3BoundTarget, [{
    key: "getEntitiesInTemplateScope",
    value: function getEntitiesInTemplateScope(template) {
      var _a;

      return (_a = this.templateEntities.get(template)) !== null && _a !== void 0 ? _a : new Set();
    }
  }, {
    key: "getDirectivesOfNode",
    value: function getDirectivesOfNode(node) {
      return this.directives.get(node) || null;
    }
  }, {
    key: "getReferenceTarget",
    value: function getReferenceTarget(ref) {
      return this.references.get(ref) || null;
    }
  }, {
    key: "getConsumerOfBinding",
    value: function getConsumerOfBinding(binding) {
      return this.bindings.get(binding) || null;
    }
  }, {
    key: "getExpressionTarget",
    value: function getExpressionTarget(expr) {
      return this.exprTargets.get(expr) || null;
    }
  }, {
    key: "getTemplateOfSymbol",
    value: function getTemplateOfSymbol(symbol) {
      return this.symbols.get(symbol) || null;
    }
  }, {
    key: "getNestingLevel",
    value: function getNestingLevel(template) {
      return this.nestingLevel.get(template) || 0;
    }
  }, {
    key: "getUsedDirectives",
    value: function getUsedDirectives() {
      var set = new Set();
      this.directives.forEach(function (dirs) {
        return dirs.forEach(function (dir) {
          return set.add(dir);
        });
      });
      return Array.from(set.values());
    }
  }, {
    key: "getUsedPipes",
    value: function getUsedPipes() {
      return Array.from(this.usedPipes);
    }
  }]);

  return R3BoundTarget;
}();

function extractTemplateEntities(rootScope) {
  var entityMap = new Map();

  function extractScopeEntities(scope) {
    if (entityMap.has(scope.template)) {
      return entityMap.get(scope.template);
    }

    var currentEntities = scope.namedEntities;
    var templateEntities;

    if (scope.parentScope !== null) {
      templateEntities = new Map([].concat((0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(extractScopeEntities(scope.parentScope)), (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toConsumableArray_js__WEBPACK_IMPORTED_MODULE_10__["default"])(currentEntities)));
    } else {
      templateEntities = new Map(currentEntities);
    }

    entityMap.set(scope.template, templateEntities);
    return templateEntities;
  }

  var scopesToProcess = [rootScope];

  while (scopesToProcess.length > 0) {
    var scope = scopesToProcess.pop();

    var _iterator33 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper_js__WEBPACK_IMPORTED_MODULE_9__["default"])(scope.childScopes.values()),
        _step33;

    try {
      for (_iterator33.s(); !(_step33 = _iterator33.n()).done;) {
        var childScope = _step33.value;
        scopesToProcess.push(childScope);
      }
    } catch (err) {
      _iterator33.e(err);
    } finally {
      _iterator33.f();
    }

    extractScopeEntities(scope);
  }

  var templateEntities = new Map();

  var _iterator34 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper_js__WEBPACK_IMPORTED_MODULE_9__["default"])(entityMap),
      _step34;

  try {
    for (_iterator34.s(); !(_step34 = _iterator34.n()).done;) {
      var _step34$value = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_slicedToArray_js__WEBPACK_IMPORTED_MODULE_3__["default"])(_step34.value, 2),
          template = _step34$value[0],
          entities = _step34$value[1];

      templateEntities.set(template, new Set(entities.values()));
    }
  } catch (err) {
    _iterator34.e(err);
  } finally {
    _iterator34.f();
  }

  return templateEntities;
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */


function compileClassMetadata(metadata) {
  var _a, _b; // Generate an ngDevMode guarded call to setClassMetadata with the class identifier and its
  // metadata.


  var fnCall = importExpr(Identifiers.setClassMetadata).callFn([metadata.type, metadata.decorators, (_a = metadata.ctorParameters) !== null && _a !== void 0 ? _a : literal(null), (_b = metadata.propDecorators) !== null && _b !== void 0 ? _b : literal(null)]);
  var iife = fn([], [devOnlyGuardedExpression(fnCall).toStmt()]);
  return iife.callFn([]);
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * Every time we make a breaking change to the declaration interface or partial-linker behavior, we
 * must update this constant to prevent old partial-linkers from incorrectly processing the
 * declaration.
 *
 * Do not include any prerelease in these versions as they are ignored.
 */


var MINIMUM_PARTIAL_LINKER_VERSION$6 = '12.0.0';

function compileDeclareClassMetadata(metadata) {
  var definitionMap = new DefinitionMap();
  definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION$6));
  definitionMap.set('version', literal('14.0.2'));
  definitionMap.set('ngImport', importExpr(Identifiers.core));
  definitionMap.set('type', metadata.type);
  definitionMap.set('decorators', metadata.decorators);
  definitionMap.set('ctorParameters', metadata.ctorParameters);
  definitionMap.set('propDecorators', metadata.propDecorators);
  return importExpr(Identifiers.declareClassMetadata).callFn([definitionMap.toLiteralMap()]);
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * Creates an array literal expression from the given array, mapping all values to an expression
 * using the provided mapping function. If the array is empty or null, then null is returned.
 *
 * @param values The array to transfer into literal array expression.
 * @param mapper The logic to use for creating an expression for the array's values.
 * @returns An array literal expression representing `values`, or null if `values` is empty or
 * is itself null.
 */


function toOptionalLiteralArray(values, mapper) {
  if (values === null || values.length === 0) {
    return null;
  }

  return literalArr(values.map(function (value) {
    return mapper(value);
  }));
}
/**
 * Creates an object literal expression from the given object, mapping all values to an expression
 * using the provided mapping function. If the object has no keys, then null is returned.
 *
 * @param object The object to transfer into an object literal expression.
 * @param mapper The logic to use for creating an expression for the object's values.
 * @returns An object literal expression representing `object`, or null if `object` does not have
 * any keys.
 */


function toOptionalLiteralMap(object, mapper) {
  var entries = Object.keys(object).map(function (key) {
    var value = object[key];
    return {
      key: key,
      value: mapper(value),
      quoted: true
    };
  });

  if (entries.length > 0) {
    return literalMap(entries);
  } else {
    return null;
  }
}

function compileDependencies(deps) {
  if (deps === 'invalid') {
    // The `deps` can be set to the string "invalid"  by the `unwrapConstructorDependencies()`
    // function, which tries to convert `ConstructorDeps` into `R3DependencyMetadata[]`.
    return literal('invalid');
  } else if (deps === null) {
    return literal(null);
  } else {
    return literalArr(deps.map(compileDependency));
  }
}

function compileDependency(dep) {
  var depMeta = new DefinitionMap();
  depMeta.set('token', dep.token);

  if (dep.attributeNameType !== null) {
    depMeta.set('attribute', literal(true));
  }

  if (dep.host) {
    depMeta.set('host', literal(true));
  }

  if (dep.optional) {
    depMeta.set('optional', literal(true));
  }

  if (dep.self) {
    depMeta.set('self', literal(true));
  }

  if (dep.skipSelf) {
    depMeta.set('skipSelf', literal(true));
  }

  return depMeta.toLiteralMap();
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * Every time we make a breaking change to the declaration interface or partial-linker behavior, we
 * must update this constant to prevent old partial-linkers from incorrectly processing the
 * declaration.
 *
 * Do not include any prerelease in these versions as they are ignored.
 */


var MINIMUM_PARTIAL_LINKER_VERSION$5 = '14.0.0';
/**
 * Compile a directive declaration defined by the `R3DirectiveMetadata`.
 */

function compileDeclareDirectiveFromMetadata(meta) {
  var definitionMap = createDirectiveDefinitionMap(meta);
  var expression = importExpr(Identifiers.declareDirective).callFn([definitionMap.toLiteralMap()]);
  var type = createDirectiveType(meta);
  return {
    expression: expression,
    type: type,
    statements: []
  };
}
/**
 * Gathers the declaration fields for a directive into a `DefinitionMap`. This allows for reusing
 * this logic for components, as they extend the directive metadata.
 */


function createDirectiveDefinitionMap(meta) {
  var definitionMap = new DefinitionMap();
  definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION$5));
  definitionMap.set('version', literal('14.0.2')); // e.g. `type: MyDirective`

  definitionMap.set('type', meta.internalType);

  if (meta.isStandalone) {
    definitionMap.set('isStandalone', literal(meta.isStandalone));
  } // e.g. `selector: 'some-dir'`


  if (meta.selector !== null) {
    definitionMap.set('selector', literal(meta.selector));
  }

  definitionMap.set('inputs', conditionallyCreateMapObjectLiteral(meta.inputs, true));
  definitionMap.set('outputs', conditionallyCreateMapObjectLiteral(meta.outputs));
  definitionMap.set('host', compileHostMetadata(meta.host));
  definitionMap.set('providers', meta.providers);

  if (meta.queries.length > 0) {
    definitionMap.set('queries', literalArr(meta.queries.map(compileQuery)));
  }

  if (meta.viewQueries.length > 0) {
    definitionMap.set('viewQueries', literalArr(meta.viewQueries.map(compileQuery)));
  }

  if (meta.exportAs !== null) {
    definitionMap.set('exportAs', asLiteral(meta.exportAs));
  }

  if (meta.usesInheritance) {
    definitionMap.set('usesInheritance', literal(true));
  }

  if (meta.lifecycle.usesOnChanges) {
    definitionMap.set('usesOnChanges', literal(true));
  }

  definitionMap.set('ngImport', importExpr(Identifiers.core));
  return definitionMap;
}
/**
 * Compiles the metadata of a single query into its partial declaration form as declared
 * by `R3DeclareQueryMetadata`.
 */


function compileQuery(query) {
  var meta = new DefinitionMap();
  meta.set('propertyName', literal(query.propertyName));

  if (query.first) {
    meta.set('first', literal(true));
  }

  meta.set('predicate', Array.isArray(query.predicate) ? asLiteral(query.predicate) : convertFromMaybeForwardRefExpression(query.predicate));

  if (!query.emitDistinctChangesOnly) {
    // `emitDistinctChangesOnly` is special because we expect it to be `true`.
    // Therefore we explicitly emit the field, and explicitly place it only when it's `false`.
    meta.set('emitDistinctChangesOnly', literal(false));
  } else {// The linker will assume that an absent `emitDistinctChangesOnly` flag is by default `true`.
  }

  if (query.descendants) {
    meta.set('descendants', literal(true));
  }

  meta.set('read', query.read);

  if (query.static) {
    meta.set('static', literal(true));
  }

  return meta.toLiteralMap();
}
/**
 * Compiles the host metadata into its partial declaration form as declared
 * in `R3DeclareDirectiveMetadata['host']`
 */


function compileHostMetadata(meta) {
  var hostMetadata = new DefinitionMap();
  hostMetadata.set('attributes', toOptionalLiteralMap(meta.attributes, function (expression) {
    return expression;
  }));
  hostMetadata.set('listeners', toOptionalLiteralMap(meta.listeners, literal));
  hostMetadata.set('properties', toOptionalLiteralMap(meta.properties, literal));

  if (meta.specialAttributes.styleAttr) {
    hostMetadata.set('styleAttribute', literal(meta.specialAttributes.styleAttr));
  }

  if (meta.specialAttributes.classAttr) {
    hostMetadata.set('classAttribute', literal(meta.specialAttributes.classAttr));
  }

  if (hostMetadata.values.length > 0) {
    return hostMetadata.toLiteralMap();
  } else {
    return null;
  }
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * Compile a component declaration defined by the `R3ComponentMetadata`.
 */


function compileDeclareComponentFromMetadata(meta, template, additionalTemplateInfo) {
  var definitionMap = createComponentDefinitionMap(meta, template, additionalTemplateInfo);
  var expression = importExpr(Identifiers.declareComponent).callFn([definitionMap.toLiteralMap()]);
  var type = createComponentType(meta);
  return {
    expression: expression,
    type: type,
    statements: []
  };
}
/**
 * Gathers the declaration fields for a component into a `DefinitionMap`.
 */


function createComponentDefinitionMap(meta, template, templateInfo) {
  var definitionMap = createDirectiveDefinitionMap(meta);
  definitionMap.set('template', getTemplateExpression(template, templateInfo));

  if (templateInfo.isInline) {
    definitionMap.set('isInline', literal(true));
  }

  definitionMap.set('styles', toOptionalLiteralArray(meta.styles, literal));
  definitionMap.set('dependencies', compileUsedDependenciesMetadata(meta));
  definitionMap.set('viewProviders', meta.viewProviders);
  definitionMap.set('animations', meta.animations);

  if (meta.changeDetection !== undefined) {
    definitionMap.set('changeDetection', importExpr(Identifiers.ChangeDetectionStrategy).prop(ChangeDetectionStrategy[meta.changeDetection]));
  }

  if (meta.encapsulation !== ViewEncapsulation.Emulated) {
    definitionMap.set('encapsulation', importExpr(Identifiers.ViewEncapsulation).prop(ViewEncapsulation[meta.encapsulation]));
  }

  if (meta.interpolation !== DEFAULT_INTERPOLATION_CONFIG) {
    definitionMap.set('interpolation', literalArr([literal(meta.interpolation.start), literal(meta.interpolation.end)]));
  }

  if (template.preserveWhitespaces === true) {
    definitionMap.set('preserveWhitespaces', literal(true));
  }

  return definitionMap;
}

function getTemplateExpression(template, templateInfo) {
  // If the template has been defined using a direct literal, we use that expression directly
  // without any modifications. This is ensures proper source mapping from the partially
  // compiled code to the source file declaring the template. Note that this does not capture
  // template literals referenced indirectly through an identifier.
  if (templateInfo.inlineTemplateLiteralExpression !== null) {
    return templateInfo.inlineTemplateLiteralExpression;
  } // If the template is defined inline but not through a literal, the template has been resolved
  // through static interpretation. We create a literal but cannot provide any source span. Note
  // that we cannot use the expression defining the template because the linker expects the template
  // to be defined as a literal in the declaration.


  if (templateInfo.isInline) {
    return literal(templateInfo.content, null, null);
  } // The template is external so we must synthesize an expression node with
  // the appropriate source-span.


  var contents = templateInfo.content;
  var file = new ParseSourceFile(contents, templateInfo.sourceUrl);
  var start = new ParseLocation(file, 0, 0, 0);
  var end = computeEndLocation(file, contents);
  var span = new ParseSourceSpan(start, end);
  return literal(contents, null, span);
}

function computeEndLocation(file, contents) {
  var length = contents.length;
  var lineStart = 0;
  var lastLineStart = 0;
  var line = 0;

  do {
    lineStart = contents.indexOf('\n', lastLineStart);

    if (lineStart !== -1) {
      lastLineStart = lineStart + 1;
      line++;
    }
  } while (lineStart !== -1);

  return new ParseLocation(file, length, line, length - lastLineStart);
}

function compileUsedDependenciesMetadata(meta) {
  var wrapType = meta.declarationListEmitMode !== 0
  /* DeclarationListEmitMode.Direct */
  ? generateForwardRef : function (expr) {
    return expr;
  };
  return toOptionalLiteralArray(meta.declarations, function (decl) {
    switch (decl.kind) {
      case R3TemplateDependencyKind.Directive:
        var dirMeta = new DefinitionMap();
        dirMeta.set('kind', literal(decl.isComponent ? 'component' : 'directive'));
        dirMeta.set('type', wrapType(decl.type));
        dirMeta.set('selector', literal(decl.selector));
        dirMeta.set('inputs', toOptionalLiteralArray(decl.inputs, literal));
        dirMeta.set('outputs', toOptionalLiteralArray(decl.outputs, literal));
        dirMeta.set('exportAs', toOptionalLiteralArray(decl.exportAs, literal));
        return dirMeta.toLiteralMap();

      case R3TemplateDependencyKind.Pipe:
        var pipeMeta = new DefinitionMap();
        pipeMeta.set('kind', literal('pipe'));
        pipeMeta.set('type', wrapType(decl.type));
        pipeMeta.set('name', literal(decl.name));
        return pipeMeta.toLiteralMap();

      case R3TemplateDependencyKind.NgModule:
        var ngModuleMeta = new DefinitionMap();
        ngModuleMeta.set('kind', literal('ngmodule'));
        ngModuleMeta.set('type', wrapType(decl.type));
        return ngModuleMeta.toLiteralMap();
    }
  });
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * Every time we make a breaking change to the declaration interface or partial-linker behavior, we
 * must update this constant to prevent old partial-linkers from incorrectly processing the
 * declaration.
 *
 * Do not include any prerelease in these versions as they are ignored.
 */


var MINIMUM_PARTIAL_LINKER_VERSION$4 = '12.0.0';

function compileDeclareFactoryFunction(meta) {
  var definitionMap = new DefinitionMap();
  definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION$4));
  definitionMap.set('version', literal('14.0.2'));
  definitionMap.set('ngImport', importExpr(Identifiers.core));
  definitionMap.set('type', meta.internalType);
  definitionMap.set('deps', compileDependencies(meta.deps));
  definitionMap.set('target', importExpr(Identifiers.FactoryTarget).prop(FactoryTarget$1[meta.target]));
  return {
    expression: importExpr(Identifiers.declareFactory).callFn([definitionMap.toLiteralMap()]),
    statements: [],
    type: createFactoryType(meta)
  };
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * Every time we make a breaking change to the declaration interface or partial-linker behavior, we
 * must update this constant to prevent old partial-linkers from incorrectly processing the
 * declaration.
 *
 * Do not include any prerelease in these versions as they are ignored.
 */


var MINIMUM_PARTIAL_LINKER_VERSION$3 = '12.0.0';
/**
 * Compile a Injectable declaration defined by the `R3InjectableMetadata`.
 */

function compileDeclareInjectableFromMetadata(meta) {
  var definitionMap = createInjectableDefinitionMap(meta);
  var expression = importExpr(Identifiers.declareInjectable).callFn([definitionMap.toLiteralMap()]);
  var type = createInjectableType(meta);
  return {
    expression: expression,
    type: type,
    statements: []
  };
}
/**
 * Gathers the declaration fields for a Injectable into a `DefinitionMap`.
 */


function createInjectableDefinitionMap(meta) {
  var definitionMap = new DefinitionMap();
  definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION$3));
  definitionMap.set('version', literal('14.0.2'));
  definitionMap.set('ngImport', importExpr(Identifiers.core));
  definitionMap.set('type', meta.internalType); // Only generate providedIn property if it has a non-null value

  if (meta.providedIn !== undefined) {
    var providedIn = convertFromMaybeForwardRefExpression(meta.providedIn);

    if (providedIn.value !== null) {
      definitionMap.set('providedIn', providedIn);
    }
  }

  if (meta.useClass !== undefined) {
    definitionMap.set('useClass', convertFromMaybeForwardRefExpression(meta.useClass));
  }

  if (meta.useExisting !== undefined) {
    definitionMap.set('useExisting', convertFromMaybeForwardRefExpression(meta.useExisting));
  }

  if (meta.useValue !== undefined) {
    definitionMap.set('useValue', convertFromMaybeForwardRefExpression(meta.useValue));
  } // Factories do not contain `ForwardRef`s since any types are already wrapped in a function call
  // so the types will not be eagerly evaluated. Therefore we do not need to process this expression
  // with `convertFromProviderExpression()`.


  if (meta.useFactory !== undefined) {
    definitionMap.set('useFactory', meta.useFactory);
  }

  if (meta.deps !== undefined) {
    definitionMap.set('deps', literalArr(meta.deps.map(compileDependency)));
  }

  return definitionMap;
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * Every time we make a breaking change to the declaration interface or partial-linker behavior, we
 * must update this constant to prevent old partial-linkers from incorrectly processing the
 * declaration.
 *
 * Do not include any prerelease in these versions as they are ignored.
 */


var MINIMUM_PARTIAL_LINKER_VERSION$2 = '12.0.0';

function compileDeclareInjectorFromMetadata(meta) {
  var definitionMap = createInjectorDefinitionMap(meta);
  var expression = importExpr(Identifiers.declareInjector).callFn([definitionMap.toLiteralMap()]);
  var type = createInjectorType(meta);
  return {
    expression: expression,
    type: type,
    statements: []
  };
}
/**
 * Gathers the declaration fields for an Injector into a `DefinitionMap`.
 */


function createInjectorDefinitionMap(meta) {
  var definitionMap = new DefinitionMap();
  definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION$2));
  definitionMap.set('version', literal('14.0.2'));
  definitionMap.set('ngImport', importExpr(Identifiers.core));
  definitionMap.set('type', meta.internalType);
  definitionMap.set('providers', meta.providers);

  if (meta.imports.length > 0) {
    definitionMap.set('imports', literalArr(meta.imports));
  }

  return definitionMap;
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * Every time we make a breaking change to the declaration interface or partial-linker behavior, we
 * must update this constant to prevent old partial-linkers from incorrectly processing the
 * declaration.
 *
 * Do not include any prerelease in these versions as they are ignored.
 */


var MINIMUM_PARTIAL_LINKER_VERSION$1 = '14.0.0';

function compileDeclareNgModuleFromMetadata(meta) {
  var definitionMap = createNgModuleDefinitionMap(meta);
  var expression = importExpr(Identifiers.declareNgModule).callFn([definitionMap.toLiteralMap()]);
  var type = createNgModuleType(meta);
  return {
    expression: expression,
    type: type,
    statements: []
  };
}
/**
 * Gathers the declaration fields for an NgModule into a `DefinitionMap`.
 */


function createNgModuleDefinitionMap(meta) {
  var definitionMap = new DefinitionMap();
  definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION$1));
  definitionMap.set('version', literal('14.0.2'));
  definitionMap.set('ngImport', importExpr(Identifiers.core));
  definitionMap.set('type', meta.internalType); // We only generate the keys in the metadata if the arrays contain values.
  // We must wrap the arrays inside a function if any of the values are a forward reference to a
  // not-yet-declared class. This is to support JIT execution of the `ɵɵngDeclareNgModule()` call.
  // In the linker these wrappers are stripped and then reapplied for the `ɵɵdefineNgModule()` call.

  if (meta.bootstrap.length > 0) {
    definitionMap.set('bootstrap', refsToArray(meta.bootstrap, meta.containsForwardDecls));
  }

  if (meta.declarations.length > 0) {
    definitionMap.set('declarations', refsToArray(meta.declarations, meta.containsForwardDecls));
  }

  if (meta.imports.length > 0) {
    definitionMap.set('imports', refsToArray(meta.imports, meta.containsForwardDecls));
  }

  if (meta.exports.length > 0) {
    definitionMap.set('exports', refsToArray(meta.exports, meta.containsForwardDecls));
  }

  if (meta.schemas !== null && meta.schemas.length > 0) {
    definitionMap.set('schemas', literalArr(meta.schemas.map(function (ref) {
      return ref.value;
    })));
  }

  if (meta.id !== null) {
    definitionMap.set('id', meta.id);
  }

  return definitionMap;
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * Every time we make a breaking change to the declaration interface or partial-linker behavior, we
 * must update this constant to prevent old partial-linkers from incorrectly processing the
 * declaration.
 *
 * Do not include any prerelease in these versions as they are ignored.
 */


var MINIMUM_PARTIAL_LINKER_VERSION = '14.0.0';
/**
 * Compile a Pipe declaration defined by the `R3PipeMetadata`.
 */

function compileDeclarePipeFromMetadata(meta) {
  var definitionMap = createPipeDefinitionMap(meta);
  var expression = importExpr(Identifiers.declarePipe).callFn([definitionMap.toLiteralMap()]);
  var type = createPipeType(meta);
  return {
    expression: expression,
    type: type,
    statements: []
  };
}
/**
 * Gathers the declaration fields for a Pipe into a `DefinitionMap`.
 */


function createPipeDefinitionMap(meta) {
  var definitionMap = new DefinitionMap();
  definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION));
  definitionMap.set('version', literal('14.0.2'));
  definitionMap.set('ngImport', importExpr(Identifiers.core)); // e.g. `type: MyPipe`

  definitionMap.set('type', meta.internalType);

  if (meta.isStandalone) {
    definitionMap.set('isStandalone', literal(meta.isStandalone));
  } // e.g. `name: "myPipe"`


  definitionMap.set('name', literal(meta.pipeName));

  if (meta.pure === false) {
    // e.g. `pure: false`
    definitionMap.set('pure', literal(meta.pure));
  }

  return definitionMap;
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
// This file only reexports content of the `src` folder. Keep it that way.
// This function call has a global side effects and publishes the compiler into global namespace for
// the late binding of the Compiler to the @angular/core for jit compilation.


publishFacade(_global);
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
// This file only reexports content of the `src` folder. Keep it that way.

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */



/***/ }),

/***/ 43757:
/*!**********************************************************!*\
  !*** ./node_modules/@angular/localize/fesm2015/init.mjs ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$localize": function() { return /* reexport safe */ _angular_localize__WEBPACK_IMPORTED_MODULE_0__["ɵ$localize"]; }
/* harmony export */ });
/* harmony import */ var _angular_localize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/localize */ 78642);
/**
 * @license Angular v14.0.2
 * (c) 2010-2022 Google LLC. https://angular.io/
 * License: MIT
 */


/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
// Attach $localize to the global context, as a side-effect of this module.

_angular_localize__WEBPACK_IMPORTED_MODULE_0__["ɵ_global"].$localize = _angular_localize__WEBPACK_IMPORTED_MODULE_0__["ɵ$localize"];

/***/ }),

/***/ 78642:
/*!**************************************************************!*\
  !*** ./node_modules/@angular/localize/fesm2015/localize.mjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "clearTranslations": function() { return /* binding */ clearTranslations; },
/* harmony export */   "loadTranslations": function() { return /* binding */ loadTranslations; },
/* harmony export */   "ɵ$localize": function() { return /* binding */ $localize$1; },
/* harmony export */   "ɵMissingTranslationError": function() { return /* binding */ MissingTranslationError; },
/* harmony export */   "ɵ_global": function() { return /* binding */ _global; },
/* harmony export */   "ɵcomputeMsgId": function() { return /* reexport safe */ _angular_compiler__WEBPACK_IMPORTED_MODULE_7__.computeMsgId; },
/* harmony export */   "ɵfindEndOfBlock": function() { return /* binding */ findEndOfBlock; },
/* harmony export */   "ɵisMissingTranslationError": function() { return /* binding */ isMissingTranslationError; },
/* harmony export */   "ɵmakeParsedTranslation": function() { return /* binding */ makeParsedTranslation; },
/* harmony export */   "ɵmakeTemplateObject": function() { return /* binding */ makeTemplateObject; },
/* harmony export */   "ɵparseMessage": function() { return /* binding */ parseMessage; },
/* harmony export */   "ɵparseMetadata": function() { return /* binding */ parseMetadata; },
/* harmony export */   "ɵparseTranslation": function() { return /* binding */ parseTranslation; },
/* harmony export */   "ɵsplitBlock": function() { return /* binding */ splitBlock; },
/* harmony export */   "ɵtranslate": function() { return /* binding */ translate$1; }
/* harmony export */ });
/* harmony import */ var _Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/createClass.js */ 48047);
/* harmony import */ var _Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js */ 78069);
/* harmony import */ var _Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/inherits.js */ 24582);
/* harmony import */ var _Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/createSuper.js */ 2496);
/* harmony import */ var _Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_wrapNativeSuper_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js */ 68926);
/* harmony import */ var _Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_slicedToArray_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/slicedToArray.js */ 10507);
/* harmony import */ var _Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toArray_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/toArray.js */ 60609);
/* harmony import */ var _angular_compiler__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/compiler */ 28305);








/**
 * @license Angular v14.0.2
 * (c) 2010-2022 Google LLC. https://angular.io/
 * License: MIT
 */


/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * The character used to mark the start and end of a "block" in a `$localize` tagged string.
 * A block can indicate metadata about the message or specify a name of a placeholder for a
 * substitution expressions.
 *
 * For example:
 *
 * ```ts
 * $localize`Hello, ${title}:title:!`;
 * $localize`:meaning|description@@id:source message text`;
 * ```
 */

var BLOCK_MARKER$1 = ':';
/**
 * The marker used to separate a message's "meaning" from its "description" in a metadata block.
 *
 * For example:
 *
 * ```ts
 * $localize `:correct|Indicates that the user got the answer correct: Right!`;
 * $localize `:movement|Button label for moving to the right: Right!`;
 * ```
 */

var MEANING_SEPARATOR = '|';
/**
 * The marker used to separate a message's custom "id" from its "description" in a metadata block.
 *
 * For example:
 *
 * ```ts
 * $localize `:A welcome message on the home page@@myApp-homepage-welcome: Welcome!`;
 * ```
 */

var ID_SEPARATOR = '@@';
/**
 * The marker used to separate legacy message ids from the rest of a metadata block.
 *
 * For example:
 *
 * ```ts
 * $localize `:@@custom-id␟2df64767cd895a8fabe3e18b94b5b6b6f9e2e3f0: Welcome!`;
 * ```
 *
 * Note that this character is the "symbol for the unit separator" (␟) not the "unit separator
 * character" itself, since that has no visual representation. See https://graphemica.com/%E2%90%9F.
 *
 * Here is some background for the original "unit separator character":
 * https://stackoverflow.com/questions/8695118/whats-the-file-group-record-unit-separator-control-characters-and-its-usage
 */

var LEGACY_ID_INDICATOR = "\u241F";
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * Parse a `$localize` tagged string into a structure that can be used for translation or
 * extraction.
 *
 * See `ParsedMessage` for an example.
 */

function parseMessage(messageParts, expressions, location, messagePartLocations) {
  var expressionLocations = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];
  var substitutions = {};
  var substitutionLocations = {};
  var associatedMessageIds = {};
  var metadata = parseMetadata(messageParts[0], messageParts.raw[0]);
  var cleanedMessageParts = [metadata.text];
  var placeholderNames = [];
  var messageString = metadata.text;

  for (var i = 1; i < messageParts.length; i++) {
    var _parsePlaceholder = parsePlaceholder(messageParts[i], messageParts.raw[i]),
        messagePart = _parsePlaceholder.messagePart,
        _parsePlaceholder$pla = _parsePlaceholder.placeholderName,
        placeholderName = _parsePlaceholder$pla === void 0 ? computePlaceholderName(i) : _parsePlaceholder$pla,
        associatedMessageId = _parsePlaceholder.associatedMessageId;

    messageString += "{$".concat(placeholderName, "}").concat(messagePart);

    if (expressions !== undefined) {
      substitutions[placeholderName] = expressions[i - 1];
      substitutionLocations[placeholderName] = expressionLocations[i - 1];
    }

    placeholderNames.push(placeholderName);

    if (associatedMessageId !== undefined) {
      associatedMessageIds[placeholderName] = associatedMessageId;
    }

    cleanedMessageParts.push(messagePart);
  }

  var messageId = metadata.customId || (0,_angular_compiler__WEBPACK_IMPORTED_MODULE_7__.computeMsgId)(messageString, metadata.meaning || '');
  var legacyIds = metadata.legacyIds ? metadata.legacyIds.filter(function (id) {
    return id !== messageId;
  }) : [];
  return {
    id: messageId,
    legacyIds: legacyIds,
    substitutions: substitutions,
    substitutionLocations: substitutionLocations,
    text: messageString,
    customId: metadata.customId,
    meaning: metadata.meaning || '',
    description: metadata.description || '',
    messageParts: cleanedMessageParts,
    messagePartLocations: messagePartLocations,
    placeholderNames: placeholderNames,
    associatedMessageIds: associatedMessageIds,
    location: location
  };
}
/**
 * Parse the given message part (`cooked` + `raw`) to extract the message metadata from the text.
 *
 * If the message part has a metadata block this function will extract the `meaning`,
 * `description`, `customId` and `legacyId` (if provided) from the block. These metadata properties
 * are serialized in the string delimited by `|`, `@@` and `␟` respectively.
 *
 * (Note that `␟` is the `LEGACY_ID_INDICATOR` - see `constants.ts`.)
 *
 * For example:
 *
 * ```ts
 * `:meaning|description@@custom-id:`
 * `:meaning|@@custom-id:`
 * `:meaning|description:`
 * `:description@@custom-id:`
 * `:meaning|:`
 * `:description:`
 * `:@@custom-id:`
 * `:meaning|description@@custom-id␟legacy-id-1␟legacy-id-2:`
 * ```
 *
 * @param cooked The cooked version of the message part to parse.
 * @param raw The raw version of the message part to parse.
 * @returns A object containing any metadata that was parsed from the message part.
 */


function parseMetadata(cooked, raw) {
  var _splitBlock = splitBlock(cooked, raw),
      messageString = _splitBlock.text,
      block = _splitBlock.block;

  if (block === undefined) {
    return {
      text: messageString
    };
  } else {
    var _block$split = block.split(LEGACY_ID_INDICATOR),
        _block$split2 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_toArray_js__WEBPACK_IMPORTED_MODULE_6__["default"])(_block$split),
        meaningDescAndId = _block$split2[0],
        legacyIds = _block$split2.slice(1);

    var _meaningDescAndId$spl = meaningDescAndId.split(ID_SEPARATOR, 2),
        _meaningDescAndId$spl2 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_slicedToArray_js__WEBPACK_IMPORTED_MODULE_5__["default"])(_meaningDescAndId$spl, 2),
        meaningAndDesc = _meaningDescAndId$spl2[0],
        customId = _meaningDescAndId$spl2[1];

    var _meaningAndDesc$split = meaningAndDesc.split(MEANING_SEPARATOR, 2),
        _meaningAndDesc$split2 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_slicedToArray_js__WEBPACK_IMPORTED_MODULE_5__["default"])(_meaningAndDesc$split, 2),
        meaning = _meaningAndDesc$split2[0],
        description = _meaningAndDesc$split2[1];

    if (description === undefined) {
      description = meaning;
      meaning = undefined;
    }

    if (description === '') {
      description = undefined;
    }

    return {
      text: messageString,
      meaning: meaning,
      description: description,
      customId: customId,
      legacyIds: legacyIds
    };
  }
}
/**
 * Parse the given message part (`cooked` + `raw`) to extract any placeholder metadata from the
 * text.
 *
 * If the message part has a metadata block this function will extract the `placeholderName` and
 * `associatedMessageId` (if provided) from the block.
 *
 * These metadata properties are serialized in the string delimited by `@@`.
 *
 * For example:
 *
 * ```ts
 * `:placeholder-name@@associated-id:`
 * ```
 *
 * @param cooked The cooked version of the message part to parse.
 * @param raw The raw version of the message part to parse.
 * @returns A object containing the metadata (`placeholderName` and `associatedMesssageId`) of the
 *     preceding placeholder, along with the static text that follows.
 */


function parsePlaceholder(cooked, raw) {
  var _splitBlock2 = splitBlock(cooked, raw),
      messagePart = _splitBlock2.text,
      block = _splitBlock2.block;

  if (block === undefined) {
    return {
      messagePart: messagePart
    };
  } else {
    var _block$split3 = block.split(ID_SEPARATOR),
        _block$split4 = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_slicedToArray_js__WEBPACK_IMPORTED_MODULE_5__["default"])(_block$split3, 2),
        placeholderName = _block$split4[0],
        associatedMessageId = _block$split4[1];

    return {
      messagePart: messagePart,
      placeholderName: placeholderName,
      associatedMessageId: associatedMessageId
    };
  }
}
/**
 * Split a message part (`cooked` + `raw`) into an optional delimited "block" off the front and the
 * rest of the text of the message part.
 *
 * Blocks appear at the start of message parts. They are delimited by a colon `:` character at the
 * start and end of the block.
 *
 * If the block is in the first message part then it will be metadata about the whole message:
 * meaning, description, id.  Otherwise it will be metadata about the immediately preceding
 * substitution: placeholder name.
 *
 * Since blocks are optional, it is possible that the content of a message block actually starts
 * with a block marker. In this case the marker must be escaped `\:`.
 *
 * @param cooked The cooked version of the message part to parse.
 * @param raw The raw version of the message part to parse.
 * @returns An object containing the `text` of the message part and the text of the `block`, if it
 * exists.
 * @throws an error if the `block` is unterminated
 */


function splitBlock(cooked, raw) {
  if (raw.charAt(0) !== BLOCK_MARKER$1) {
    return {
      text: cooked
    };
  } else {
    var endOfBlock = findEndOfBlock(cooked, raw);
    return {
      block: cooked.substring(1, endOfBlock),
      text: cooked.substring(endOfBlock + 1)
    };
  }
}

function computePlaceholderName(index) {
  return index === 1 ? 'PH' : "PH_".concat(index - 1);
}
/**
 * Find the end of a "marked block" indicated by the first non-escaped colon.
 *
 * @param cooked The cooked string (where escaped chars have been processed)
 * @param raw The raw string (where escape sequences are still in place)
 *
 * @returns the index of the end of block marker
 * @throws an error if the block is unterminated
 */


function findEndOfBlock(cooked, raw) {
  for (var cookedIndex = 1, rawIndex = 1; cookedIndex < cooked.length; cookedIndex++, rawIndex++) {
    if (raw[rawIndex] === '\\') {
      rawIndex++;
    } else if (cooked[cookedIndex] === BLOCK_MARKER$1) {
      return cookedIndex;
    }
  }

  throw new Error("Unterminated $localize metadata block in \"".concat(raw, "\"."));
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */


var MissingTranslationError = /*#__PURE__*/function (_Error) {
  (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_inherits_js__WEBPACK_IMPORTED_MODULE_2__["default"])(MissingTranslationError, _Error);

  var _super = (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createSuper_js__WEBPACK_IMPORTED_MODULE_3__["default"])(MissingTranslationError);

  function MissingTranslationError(parsedMessage) {
    var _this;

    (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_1__["default"])(this, MissingTranslationError);

    _this = _super.call(this, "No translation found for ".concat(describeMessage(parsedMessage), "."));
    _this.parsedMessage = parsedMessage;
    _this.type = 'MissingTranslationError';
    return _this;
  }

  return (0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_0__["default"])(MissingTranslationError);
}( /*#__PURE__*/(0,_Users_elpoloxrodriguez_Desktop_Developer_Sinfona_node_modules_babel_runtime_helpers_esm_wrapNativeSuper_js__WEBPACK_IMPORTED_MODULE_4__["default"])(Error));

function isMissingTranslationError(e) {
  return e.type === 'MissingTranslationError';
}
/**
 * Translate the text of the `$localize` tagged-string (i.e. `messageParts` and
 * `substitutions`) using the given `translations`.
 *
 * The tagged-string is parsed to extract its `messageId` which is used to find an appropriate
 * `ParsedTranslation`. If this doesn't match and there are legacy ids then try matching a
 * translation using those.
 *
 * If one is found then it is used to translate the message into a new set of `messageParts` and
 * `substitutions`.
 * The translation may reorder (or remove) substitutions as appropriate.
 *
 * If there is no translation with a matching message id then an error is thrown.
 * If a translation contains a placeholder that is not found in the message being translated then an
 * error is thrown.
 */


function translate$1(translations, messageParts, substitutions) {
  var message = parseMessage(messageParts, substitutions); // Look up the translation using the messageId, and then the legacyId if available.

  var translation = translations[message.id]; // If the messageId did not match a translation, try matching the legacy ids instead

  if (message.legacyIds !== undefined) {
    for (var i = 0; i < message.legacyIds.length && translation === undefined; i++) {
      translation = translations[message.legacyIds[i]];
    }
  }

  if (translation === undefined) {
    throw new MissingTranslationError(message);
  }

  return [translation.messageParts, translation.placeholderNames.map(function (placeholder) {
    if (message.substitutions.hasOwnProperty(placeholder)) {
      return message.substitutions[placeholder];
    } else {
      throw new Error("There is a placeholder name mismatch with the translation provided for the message ".concat(describeMessage(message), ".\n") + "The translation contains a placeholder with name ".concat(placeholder, ", which does not exist in the message."));
    }
  })];
}
/**
 * Parse the `messageParts` and `placeholderNames` out of a target `message`.
 *
 * Used by `loadTranslations()` to convert target message strings into a structure that is more
 * appropriate for doing translation.
 *
 * @param message the message to be parsed.
 */


function parseTranslation(messageString) {
  var parts = messageString.split(/{\$([^}]*)}/);
  var messageParts = [parts[0]];
  var placeholderNames = [];

  for (var i = 1; i < parts.length - 1; i += 2) {
    placeholderNames.push(parts[i]);
    messageParts.push("".concat(parts[i + 1]));
  }

  var rawMessageParts = messageParts.map(function (part) {
    return part.charAt(0) === BLOCK_MARKER$1 ? '\\' + part : part;
  });
  return {
    text: messageString,
    messageParts: makeTemplateObject(messageParts, rawMessageParts),
    placeholderNames: placeholderNames
  };
}
/**
 * Create a `ParsedTranslation` from a set of `messageParts` and `placeholderNames`.
 *
 * @param messageParts The message parts to appear in the ParsedTranslation.
 * @param placeholderNames The names of the placeholders to intersperse between the `messageParts`.
 */


function makeParsedTranslation(messageParts) {
  var placeholderNames = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var messageString = messageParts[0];

  for (var i = 0; i < placeholderNames.length; i++) {
    messageString += "{$".concat(placeholderNames[i], "}").concat(messageParts[i + 1]);
  }

  return {
    text: messageString,
    messageParts: makeTemplateObject(messageParts, messageParts),
    placeholderNames: placeholderNames
  };
}
/**
 * Create the specialized array that is passed to tagged-string tag functions.
 *
 * @param cooked The message parts with their escape codes processed.
 * @param raw The message parts with their escaped codes as-is.
 */


function makeTemplateObject(cooked, raw) {
  Object.defineProperty(cooked, 'raw', {
    value: raw
  });
  return cooked;
}

function describeMessage(message) {
  var meaningString = message.meaning && " - \"".concat(message.meaning, "\"");
  var legacy = message.legacyIds && message.legacyIds.length > 0 ? " [".concat(message.legacyIds.map(function (l) {
    return "\"".concat(l, "\"");
  }).join(', '), "]") : '';
  return "\"".concat(message.id, "\"").concat(legacy, " (\"").concat(message.text, "\"").concat(meaningString, ")");
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * Load translations for use by `$localize`, if doing runtime translation.
 *
 * If the `$localize` tagged strings are not going to be replaced at compiled time, it is possible
 * to load a set of translations that will be applied to the `$localize` tagged strings at runtime,
 * in the browser.
 *
 * Loading a new translation will overwrite a previous translation if it has the same `MessageId`.
 *
 * Note that `$localize` messages are only processed once, when the tagged string is first
 * encountered, and does not provide dynamic language changing without refreshing the browser.
 * Loading new translations later in the application life-cycle will not change the translated text
 * of messages that have already been translated.
 *
 * The message IDs and translations are in the same format as that rendered to "simple JSON"
 * translation files when extracting messages. In particular, placeholders in messages are rendered
 * using the `{$PLACEHOLDER_NAME}` syntax. For example the message from the following template:
 *
 * ```html
 * <div i18n>pre<span>inner-pre<b>bold</b>inner-post</span>post</div>
 * ```
 *
 * would have the following form in the `translations` map:
 *
 * ```ts
 * {
 *   "2932901491976224757":
 *      "pre{$START_TAG_SPAN}inner-pre{$START_BOLD_TEXT}bold{$CLOSE_BOLD_TEXT}inner-post{$CLOSE_TAG_SPAN}post"
 * }
 * ```
 *
 * @param translations A map from message ID to translated message.
 *
 * These messages are processed and added to a lookup based on their `MessageId`.
 *
 * @see `clearTranslations()` for removing translations loaded using this function.
 * @see `$localize` for tagging messages as needing to be translated.
 * @publicApi
 */


function loadTranslations(translations) {
  // Ensure the translate function exists
  if (!$localize.translate) {
    $localize.translate = translate;
  }

  if (!$localize.TRANSLATIONS) {
    $localize.TRANSLATIONS = {};
  }

  Object.keys(translations).forEach(function (key) {
    $localize.TRANSLATIONS[key] = parseTranslation(translations[key]);
  });
}
/**
 * Remove all translations for `$localize`, if doing runtime translation.
 *
 * All translations that had been loading into memory using `loadTranslations()` will be removed.
 *
 * @see `loadTranslations()` for loading translations at runtime.
 * @see `$localize` for tagging messages as needing to be translated.
 *
 * @publicApi
 */


function clearTranslations() {
  $localize.translate = undefined;
  $localize.TRANSLATIONS = {};
}
/**
 * Translate the text of the given message, using the loaded translations.
 *
 * This function may reorder (or remove) substitutions as indicated in the matching translation.
 */


function translate(messageParts, substitutions) {
  try {
    return translate$1($localize.TRANSLATIONS, messageParts, substitutions);
  } catch (e) {
    console.warn(e.message);
    return [messageParts, substitutions];
  }
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
// Always use __globalThis if available, which is the spec-defined global variable across all
// environments, then fallback to __global first, because in Node tests both __global and
// __window may be defined and _global should be __global in that case. Note: Typeof/Instanceof
// checks are considered side-effects in Terser. We explicitly mark this as side-effect free:
// https://github.com/terser/terser/issues/250.


var _global = /* @__PURE__ */function () {
  return typeof globalThis !== 'undefined' && globalThis || typeof global !== 'undefined' && global || typeof window !== 'undefined' && window || typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope && self;
}();
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * Tag a template literal string for localization.
 *
 * For example:
 *
 * ```ts
 * $localize `some string to localize`
 * ```
 *
 * **Providing meaning, description and id**
 *
 * You can optionally specify one or more of `meaning`, `description` and `id` for a localized
 * string by pre-pending it with a colon delimited block of the form:
 *
 * ```ts
 * $localize`:meaning|description@@id:source message text`;
 *
 * $localize`:meaning|:source message text`;
 * $localize`:description:source message text`;
 * $localize`:@@id:source message text`;
 * ```
 *
 * This format is the same as that used for `i18n` markers in Angular templates. See the
 * [Angular i18n guide](guide/i18n-common-prepare#mark-text-in-component-template).
 *
 * **Naming placeholders**
 *
 * If the template literal string contains expressions, then the expressions will be automatically
 * associated with placeholder names for you.
 *
 * For example:
 *
 * ```ts
 * $localize `Hi ${name}! There are ${items.length} items.`;
 * ```
 *
 * will generate a message-source of `Hi {$PH}! There are {$PH_1} items`.
 *
 * The recommended practice is to name the placeholder associated with each expression though.
 *
 * Do this by providing the placeholder name wrapped in `:` characters directly after the
 * expression. These placeholder names are stripped out of the rendered localized string.
 *
 * For example, to name the `items.length` expression placeholder `itemCount` you write:
 *
 * ```ts
 * $localize `There are ${items.length}:itemCount: items`;
 * ```
 *
 * **Escaping colon markers**
 *
 * If you need to use a `:` character directly at the start of a tagged string that has no
 * metadata block, or directly after a substitution expression that has no name you must escape
 * the `:` by preceding it with a backslash:
 *
 * For example:
 *
 * ```ts
 * // message has a metadata block so no need to escape colon
 * $localize `:some description::this message starts with a colon (:)`;
 * // no metadata block so the colon must be escaped
 * $localize `\:this message starts with a colon (:)`;
 * ```
 *
 * ```ts
 * // named substitution so no need to escape colon
 * $localize `${label}:label:: ${}`
 * // anonymous substitution so colon must be escaped
 * $localize `${label}\: ${}`
 * ```
 *
 * **Processing localized strings:**
 *
 * There are three scenarios:
 *
 * * **compile-time inlining**: the `$localize` tag is transformed at compile time by a
 * transpiler, removing the tag and replacing the template literal string with a translated
 * literal string from a collection of translations provided to the transpilation tool.
 *
 * * **run-time evaluation**: the `$localize` tag is a run-time function that replaces and
 * reorders the parts (static strings and expressions) of the template literal string with strings
 * from a collection of translations loaded at run-time.
 *
 * * **pass-through evaluation**: the `$localize` tag is a run-time function that simply evaluates
 * the original template literal string without applying any translations to the parts. This
 * version is used during development or where there is no need to translate the localized
 * template literals.
 *
 * @param messageParts a collection of the static parts of the template string.
 * @param expressions a collection of the values of each placeholder in the template string.
 * @returns the translated string, with the `messageParts` and `expressions` interleaved together.
 *
 * @globalApi
 * @publicApi
 */


var $localize$1 = function $localize$1(messageParts) {
  for (var _len = arguments.length, expressions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    expressions[_key - 1] = arguments[_key];
  }

  if ($localize$1.translate) {
    // Don't use array expansion here to avoid the compiler adding `__read()` helper unnecessarily.
    var translation = $localize$1.translate(messageParts, expressions);
    messageParts = translation[0];
    expressions = translation[1];
  }

  var message = stripBlock(messageParts[0], messageParts.raw[0]);

  for (var i = 1; i < messageParts.length; i++) {
    message += expressions[i - 1] + stripBlock(messageParts[i], messageParts.raw[i]);
  }

  return message;
};

var BLOCK_MARKER = ':';
/**
 * Strip a delimited "block" from the start of the `messagePart`, if it is found.
 *
 * If a marker character (:) actually appears in the content at the start of a tagged string or
 * after a substitution expression, where a block has not been provided the character must be
 * escaped with a backslash, `\:`. This function checks for this by looking at the `raw`
 * messagePart, which should still contain the backslash.
 *
 * @param messagePart The cooked message part to process.
 * @param rawMessagePart The raw message part to check.
 * @returns the message part with the placeholder name stripped, if found.
 * @throws an error if the block is unterminated
 */

function stripBlock(messagePart, rawMessagePart) {
  return rawMessagePart.charAt(0) === BLOCK_MARKER ? messagePart.substring(findEndOfBlock(messagePart, rawMessagePart) + 1) : messagePart;
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */




/***/ }),

/***/ 44841:
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _arrayLikeToArray; }
/* harmony export */ });
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

/***/ }),

/***/ 8091:
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _arrayWithHoles; }
/* harmony export */ });
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

/***/ }),

/***/ 46300:
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _arrayWithoutHoles; }
/* harmony export */ });
/* harmony import */ var _arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayLikeToArray.js */ 44841);

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return (0,_arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(arr);
}

/***/ }),

/***/ 35488:
/*!**************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _assertThisInitialized; }
/* harmony export */ });
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

/***/ }),

/***/ 78069:
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _classCallCheck; }
/* harmony export */ });
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/***/ }),

/***/ 32162:
/*!**************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/construct.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _construct; }
/* harmony export */ });
/* harmony import */ var _setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./setPrototypeOf.js */ 10006);
/* harmony import */ var _isNativeReflectConstruct_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isNativeReflectConstruct.js */ 98568);


function _construct(Parent, args, Class) {
  if ((0,_isNativeReflectConstruct_js__WEBPACK_IMPORTED_MODULE_1__["default"])()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) (0,_setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__["default"])(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

/***/ }),

/***/ 48047:
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/createClass.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _createClass; }
/* harmony export */ });
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

/***/ }),

/***/ 95106:
/*!******************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _createForOfIteratorHelper; }
/* harmony export */ });
/* harmony import */ var _unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./unsupportedIterableToArray.js */ 44206);

function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

  if (!it) {
    if (Array.isArray(o) || (it = (0,_unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function F() {};

      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

/***/ }),

/***/ 2496:
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/createSuper.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _createSuper; }
/* harmony export */ });
/* harmony import */ var _getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getPrototypeOf.js */ 20265);
/* harmony import */ var _isNativeReflectConstruct_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isNativeReflectConstruct.js */ 98568);
/* harmony import */ var _possibleConstructorReturn_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./possibleConstructorReturn.js */ 8633);



function _createSuper(Derived) {
  var hasNativeReflectConstruct = (0,_isNativeReflectConstruct_js__WEBPACK_IMPORTED_MODULE_1__["default"])();
  return function _createSuperInternal() {
    var Super = (0,_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__["default"])(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = (0,_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return (0,_possibleConstructorReturn_js__WEBPACK_IMPORTED_MODULE_2__["default"])(this, result);
  };
}

/***/ }),

/***/ 64756:
/*!********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/get.js ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _get; }
/* harmony export */ });
/* harmony import */ var _superPropBase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./superPropBase.js */ 87984);

function _get() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = (0,_superPropBase_js__WEBPACK_IMPORTED_MODULE_0__["default"])(target, property);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }

      return desc.value;
    };
  }

  return _get.apply(this, arguments);
}

/***/ }),

/***/ 20265:
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _getPrototypeOf; }
/* harmony export */ });
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

/***/ }),

/***/ 24582:
/*!*************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/inherits.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _inherits; }
/* harmony export */ });
/* harmony import */ var _setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./setPrototypeOf.js */ 10006);

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) (0,_setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__["default"])(subClass, superClass);
}

/***/ }),

/***/ 98759:
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/isNativeFunction.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _isNativeFunction; }
/* harmony export */ });
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

/***/ }),

/***/ 98568:
/*!*****************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _isNativeReflectConstruct; }
/* harmony export */ });
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

/***/ }),

/***/ 4826:
/*!********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/iterableToArray.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _iterableToArray; }
/* harmony export */ });
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

/***/ }),

/***/ 12256:
/*!*************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _iterableToArrayLimit; }
/* harmony export */ });
function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

/***/ }),

/***/ 8217:
/*!********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _nonIterableRest; }
/* harmony export */ });
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

/***/ }),

/***/ 25305:
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _nonIterableSpread; }
/* harmony export */ });
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

/***/ }),

/***/ 8633:
/*!******************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _possibleConstructorReturn; }
/* harmony export */ });
/* harmony import */ var _typeof_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./typeof.js */ 43445);
/* harmony import */ var _assertThisInitialized_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./assertThisInitialized.js */ 35488);


function _possibleConstructorReturn(self, call) {
  if (call && ((0,_typeof_js__WEBPACK_IMPORTED_MODULE_0__["default"])(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return (0,_assertThisInitialized_js__WEBPACK_IMPORTED_MODULE_1__["default"])(self);
}

/***/ }),

/***/ 10006:
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _setPrototypeOf; }
/* harmony export */ });
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

/***/ }),

/***/ 10507:
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/slicedToArray.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _slicedToArray; }
/* harmony export */ });
/* harmony import */ var _arrayWithHoles_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayWithHoles.js */ 8091);
/* harmony import */ var _iterableToArrayLimit_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./iterableToArrayLimit.js */ 12256);
/* harmony import */ var _unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./unsupportedIterableToArray.js */ 44206);
/* harmony import */ var _nonIterableRest_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./nonIterableRest.js */ 8217);




function _slicedToArray(arr, i) {
  return (0,_arrayWithHoles_js__WEBPACK_IMPORTED_MODULE_0__["default"])(arr) || (0,_iterableToArrayLimit_js__WEBPACK_IMPORTED_MODULE_1__["default"])(arr, i) || (0,_unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_2__["default"])(arr, i) || (0,_nonIterableRest_js__WEBPACK_IMPORTED_MODULE_3__["default"])();
}

/***/ }),

/***/ 87984:
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/superPropBase.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _superPropBase; }
/* harmony export */ });
/* harmony import */ var _getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getPrototypeOf.js */ 20265);

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = (0,_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__["default"])(object);
    if (object === null) break;
  }

  return object;
}

/***/ }),

/***/ 60609:
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/toArray.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _toArray; }
/* harmony export */ });
/* harmony import */ var _arrayWithHoles_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayWithHoles.js */ 8091);
/* harmony import */ var _iterableToArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./iterableToArray.js */ 4826);
/* harmony import */ var _unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./unsupportedIterableToArray.js */ 44206);
/* harmony import */ var _nonIterableRest_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./nonIterableRest.js */ 8217);




function _toArray(arr) {
  return (0,_arrayWithHoles_js__WEBPACK_IMPORTED_MODULE_0__["default"])(arr) || (0,_iterableToArray_js__WEBPACK_IMPORTED_MODULE_1__["default"])(arr) || (0,_unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_2__["default"])(arr) || (0,_nonIterableRest_js__WEBPACK_IMPORTED_MODULE_3__["default"])();
}

/***/ }),

/***/ 58277:
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _toConsumableArray; }
/* harmony export */ });
/* harmony import */ var _arrayWithoutHoles_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayWithoutHoles.js */ 46300);
/* harmony import */ var _iterableToArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./iterableToArray.js */ 4826);
/* harmony import */ var _unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./unsupportedIterableToArray.js */ 44206);
/* harmony import */ var _nonIterableSpread_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./nonIterableSpread.js */ 25305);




function _toConsumableArray(arr) {
  return (0,_arrayWithoutHoles_js__WEBPACK_IMPORTED_MODULE_0__["default"])(arr) || (0,_iterableToArray_js__WEBPACK_IMPORTED_MODULE_1__["default"])(arr) || (0,_unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_2__["default"])(arr) || (0,_nonIterableSpread_js__WEBPACK_IMPORTED_MODULE_3__["default"])();
}

/***/ }),

/***/ 43445:
/*!***********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/typeof.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _typeof; }
/* harmony export */ });
function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

/***/ }),

/***/ 44206:
/*!*******************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _unsupportedIterableToArray; }
/* harmony export */ });
/* harmony import */ var _arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayLikeToArray.js */ 44841);

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return (0,_arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return (0,_arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(o, minLen);
}

/***/ }),

/***/ 68926:
/*!********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _wrapNativeSuper; }
/* harmony export */ });
/* harmony import */ var _getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getPrototypeOf.js */ 20265);
/* harmony import */ var _setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./setPrototypeOf.js */ 10006);
/* harmony import */ var _isNativeFunction_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isNativeFunction.js */ 98759);
/* harmony import */ var _construct_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./construct.js */ 32162);




function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !(0,_isNativeFunction_js__WEBPACK_IMPORTED_MODULE_2__["default"])(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return (0,_construct_js__WEBPACK_IMPORTED_MODULE_3__["default"])(Class, arguments, (0,_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return (0,_setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__["default"])(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ var __webpack_exports__ = (__webpack_exec__(7435));
/******/ }
]);
//# sourceMappingURL=polyfills.js.map